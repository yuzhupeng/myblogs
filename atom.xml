<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yuzhupeng.top/myblogs/</id>
    <title>fishyue</title>
    <updated>2025-08-18T07:44:13.559Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yuzhupeng.top/myblogs/"/>
    <link rel="self" href="https://yuzhupeng.top/myblogs/atom.xml"/>
    <subtitle>由奢入俭难，由俭入奢易</subtitle>
    <logo>https://yuzhupeng.top/myblogs/images/avatar.png</logo>
    <icon>https://yuzhupeng.top/myblogs/favicon.ico</icon>
    <rights>All rights reserved 2025, fishyue</rights>
    <entry>
        <title type="html"><![CDATA[MySQL 索引核心要点摘要（结构化）]]></title>
        <id>https://yuzhupeng.top/myblogs/post/mysql-suo-yin-he-xin-yao-dian-zhai-yao-jie-gou-hua/</id>
        <link href="https://yuzhupeng.top/myblogs/post/mysql-suo-yin-he-xin-yao-dian-zhai-yao-jie-gou-hua/">
        </link>
        <updated>2025-08-18T01:30:56.000Z</updated>
        <content type="html"><![CDATA[<p><strong>MySQL 索引核心要点摘要（结构化）</strong></p>
<hr>
<h2 id="1-模糊匹配like与索引">1. 模糊匹配（LIKE）与索引</h2>
<table>
<thead>
<tr>
<th>匹配方式</th>
<th>能否使用索引</th>
<th>解决方案</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>LIKE 'prefix%'</code>（前缀匹配）</td>
<td>✅ 能使用普通 B‑Tree 索引</td>
<td>直接建普通索引</td>
</tr>
<tr>
<td><code>LIKE '%suffix'</code>（后缀匹配）</td>
<td>❌ 索引失效（全表扫描）</td>
<td>① 生成 <strong>反转列</strong> <code>REVERSE(col)</code> 并建索引；<br>② MySQL 8.0+ 可用 <strong>函数索引</strong>（生成列）</td>
</tr>
<tr>
<td><code>LIKE '%mid%'</code>（左右模糊）</td>
<td>❌ 索引失效</td>
<td>同上，使用 N‑gram、全文索引或 Elasticsearch 等外部检索方案</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="2-函数表达式索引generated-column">2. 函数/表达式索引（Generated Column）</h2>
<ul>
<li>MySQL 8.0 起支持 <strong>函数索引</strong>：把表达式结果存入隐藏/显式生成列，再对该列建索引。</li>
</ul>
<pre><code class="language-sql">ALTER TABLE t ADD COLUMN rev_name VARCHAR(255) AS (REVERSE(name)) STORED;
CREATE INDEX idx_rev_name ON t (rev_name);
</code></pre>
<ul>
<li>仅在 <strong>WHERE / ON</strong> 条件中使用该函数时才能走索引；在 SELECT、ORDER BY、GROUP BY 等仅做展示的地方不影响索引使用。</li>
</ul>
<hr>
<h2 id="3-数据类型转换与索引">3. 数据类型转换与索引</h2>
<ul>
<li><strong>列是数值型</strong>，查询条件写成字符串（如 <code>'123'</code>）仍会走索引，因为 MySQL 会把字符串转为数值后比较。</li>
<li><strong>列是字符串型</strong>，查询条件写成数值（如 <code>WHERE name = 123</code>）会导致 <strong>隐式转为数值</strong>，索引失效，回到全表扫描。<br>
<strong>建议</strong>：</li>
</ul>
<ul>
<li>数值列不加引号；</li>
<li>字符串列加单/双引号。</li>
</ul>
<hr>
<h2 id="4-联合索引复合索引与最左前缀原则">4. 联合索引（复合索引）与最左前缀原则</h2>
<ul>
<li>索引列的顺序决定查询能否使用该索引。</li>
<li><strong>最左匹配</strong>：只有从索引最左边开始连续的等值列才会被使用。</li>
</ul>
<p><strong>可用示例</strong>（索引 <code>(a,b,c)</code>）</p>
<table>
<thead>
<tr>
<th>查询条件</th>
<th>是否走索引</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>WHERE a=1</code></td>
<td>✅</td>
</tr>
<tr>
<td><code>WHERE a=1 AND b=2</code></td>
<td>✅</td>
</tr>
<tr>
<td><code>WHERE a=1 AND b=2 AND c=3</code></td>
<td>✅</td>
</tr>
<tr>
<td><code>WHERE b=2</code></td>
<td>❌</td>
</tr>
<tr>
<td><code>WHERE c=3</code></td>
<td>❌</td>
</tr>
<tr>
<td><code>WHERE b=2 AND c=3</code></td>
<td>❌</td>
</tr>
<tr>
<td><code>WHERE a=1 AND c=0</code></td>
<td>✅（仅使用 <code>a</code>）</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>范围条件</strong>（<code>&gt;、&gt;=、&lt;、BETWEEN、LIKE 'p%'</code>）一旦出现，就会 <strong>阻断</strong>后续列的索引使用。</li>
</ul>
<hr>
<h2 id="5-where-条件的书写顺序">5. WHERE 条件的书写顺序</h2>
<ul>
<li>MySQL 优化器会 <strong>重新排列</strong> WHERE 子句以获得最佳执行计划，顺序本身不决定是否走索引。</li>
<li>但 <strong>把最左索引列的等值条件写在前面</strong>，有助于阅读和调试，也避免因错误的提示误以为顺序有影响。</li>
</ul>
<hr>
<h2 id="6-or-in-not-系列">6. OR / IN / NOT 系列</h2>
<table>
<thead>
<tr>
<th>场景</th>
<th>索引使用情况</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>WHERE col1 = 'a' OR col1 = 'b'</code></td>
<td>✅ (同一列的 OR)</td>
<td>可走索引的 <strong>合并</strong>（union）</td>
</tr>
<tr>
<td><code>WHERE indexed_col = 1 OR non_indexed_col = 2</code></td>
<td>❌ 触发全表扫描</td>
<td>任意一个条件不走索引，整体失效</td>
</tr>
<tr>
<td><code>WHERE col IN (1,2,3,…)</code></td>
<td>✅ 在大多数情况下走索引</td>
<td><strong>IN 元素 ≤ 1000</strong> 且匹配度 &lt;≈30% 时更佳</td>
</tr>
<tr>
<td><code>WHERE col NOT IN (…)</code>、<code>col != …</code>、<code>NOT LIKE</code></td>
<td>❌ 通常不能走索引</td>
<td>只在 <strong>极端低基数</strong>、<strong>小表</strong> 时可能走索引</td>
</tr>
<tr>
<td><strong>例外</strong></td>
<td>当优化器评估<strong>全表扫描成本更低</strong>（如返回 &gt;30% 行）时，即使写 <code>IN</code> 也会放弃索引</td>
<td>需通过 <code>FORCE INDEX</code> 或统计信息调优纠正</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="7-范围查询对复合索引的影响">7. 范围查询对复合索引的影响</h2>
<pre><code class="language-sql">-- 索引 (shop_id, created_at, order_status)
SELECT * FROM _order
WHERE shop_id = 1               -- 等值，可用
  AND created_at &gt; '2021-01-01' -- 范围，阻断后续列
  AND order_status = 10;       -- **不走索引**（因为已被范围查询阻断）
</code></pre>
<ul>
<li>若范围条件在最左列，则后续列全部失效。</li>
<li>若需要同时过滤 <code>order_status</code>，考虑 <strong>拆分索引</strong> 或使用 <strong>覆盖索引</strong>（包括 <code>order_status</code>）与 <code>WHERE</code> 重排。</li>
</ul>
<hr>
<h2 id="8-覆盖索引covering-index">8. 覆盖索引（Covering Index）</h2>
<ul>
<li>当查询的 <strong>所有列</strong>（包括 SELECT、WHERE、ORDER BY、GROUP BY）都包含在同一个二级索引的叶子节点时，<strong>不需要回表</strong>，直接返回结果。</li>
<li>常见做法：在联合索引中把 <strong>需要返回的列</strong>（非主键列）也加入索引。</li>
</ul>
<pre><code class="language-sql">CREATE INDEX idx_user_name_addr ON user (name, address);
SELECT name, address FROM user WHERE name='seven';
-- 直接从索引返回，无回表
</code></pre>
<hr>
<h2 id="9-asc-desc-混合排序与索引">9. ASC / DESC 混合排序与索引</h2>
<ul>
<li>MySQL 8.0+ 支持 <strong>显式指定排序方向</strong>的二级索引（如 <code>(a ASC, b DESC)</code>），但 <strong>老版本只能使用 ASC</strong>。</li>
<li>当 <code>ORDER BY</code> 的列顺序或方向与索引定义不一致时，索引会失效，导致 <strong>文件排序</strong>（filesort）。</li>
</ul>
<pre><code class="language-sql">-- 索引 (customer_id ASC, order_date ASC)
SELECT * FROM orders ORDER BY customer_id DESC, order_date; -- 索引失效
</code></pre>
<ul>
<li>解决办法：
<ul>
<li>创建匹配的 <code>(customer_id DESC, order_date ASC)</code> 索引（MySQL 8.0+）。</li>
<li>或者只使用 <strong>单列索引</strong> + 二次排序。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="10-更新索引列的代价">10. 更新索引列的代价</h2>
<ul>
<li><strong>INSERT / UPDATE / DELETE</strong> 涉及索引列时，需要 <strong>维护 B‑Tree</strong>（分裂、合并、重新平衡）。</li>
<li>对高并发写入、频繁更新的列（如状态位）<strong>不建议建索引</strong>，或使用 <strong>延迟写、分表</strong> 等方案。</li>
</ul>
<hr>
<h2 id="11-必须建立索引的关键字段">11. 必须建立索引的关键字段</h2>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐索引类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>UPDATE</code> / <code>DELETE</code> 的 <code>WHERE</code> 条件</td>
<td>单列或复合索引</td>
</tr>
<tr>
<td><code>SELECT … ORDER BY</code>、<code>GROUP BY</code>、<code>DISTINCT</code></td>
<td>包含排序/分组列的索引</td>
</tr>
<tr>
<td>多表 <code>JOIN</code>（ON 条件）</td>
<td>连接列的索引</td>
</tr>
<tr>
<td>高频过滤的业务字段（如 <code>status</code>、<code>type</code>）</td>
<td>视基数决定，必要时使用 <strong>位图索引</strong>（MySQL 不直接支持）</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="12-子查询-vs-join">12. 子查询 vs. JOIN</h2>
<ul>
<li><strong>JOIN</strong> 更易被优化器利用 <strong>索引合并、哈希/嵌套循环</strong> 等高级执行计划。</li>
<li><strong>子查询</strong>（尤其是相关子查询）往往导致 <strong>多次扫描</strong>，性能劣于等价的 JOIN。</li>
<li>推荐：把可改写为 <strong>等价的内连接</strong> 的子查询改写为 JOIN。</li>
</ul>
<hr>
<h2 id="13-order-by-与-limit-的深分页优化">13. ORDER BY 与 LIMIT 的深分页优化</h2>
<h3 id="131-limit-的成本">13.1 LIMIT 的成本</h3>
<table>
<thead>
<tr>
<th>语句</th>
<th>执行过程</th>
<th>性能影响</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SELECT * FROM t ORDER BY id LIMIT 0, 10</code></td>
<td>直接取前 10 条索引行</td>
<td>快</td>
</tr>
<tr>
<td><code>SELECT * FROM t ORDER BY id LIMIT 500000, 10</code></td>
<td>读取 500010 条索引行 → 丢弃前 500000 条</td>
<td>较慢（I/O、CPU）</td>
</tr>
</tbody>
</table>
<h3 id="132-优化方案">13.2 优化方案</h3>
<ol>
<li><strong>Keyset Pagination（基于索引的分页）</strong><pre><code class="language-sql">SELECT * FROM t WHERE id &gt; :last_id ORDER BY id LIMIT 10;
</code></pre>
</li>
<li><strong>子查询获取起始点</strong>（仅返回主键列）<pre><code class="language-sql">SELECT * FROM t
WHERE id &gt;= (SELECT id FROM t ORDER BY id LIMIT 500000, 1)
ORDER BY id LIMIT 10;
</code></pre>
</li>
<li><strong>使用覆盖索引</strong>：只查询主键列，减少回表数据量。</li>
<li><strong>使用更高效的存储引擎/缓存</strong>（如 <strong>InnoDB</strong> 的自适应哈希）或 <strong>物化视图</strong>。</li>
</ol>
<hr>
<h2 id="14-大表千万级性能提升手段">14. 大表（千万级+）性能提升手段</h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>适用场景</th>
<th>关键点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>合理建索引</strong>（最左前缀、覆盖索引）</td>
<td>常用过滤/排序列</td>
<td><code>EXPLAIN</code> 检查是否走索引</td>
</tr>
<tr>
<td><strong>水平分区</strong>（基于时间、业务维度）</td>
<td>时间范围查询频繁</td>
<td>分区裁剪，避免扫描无关分区</td>
</tr>
<tr>
<td><strong>读写分离</strong></td>
<td>写入压力大、读请求多</td>
<td>主库写，多个从库读</td>
</tr>
<tr>
<td><strong>分库分表</strong>（垂直/水平）</td>
<td>单库并发/容量到达上限</td>
<td>业务拆分、统一路由层</td>
</tr>
<tr>
<td><strong>缓存</strong>（Redis、Memcached）</td>
<td>热点数据、计数、查询结果</td>
<td>缓存失效策略、缓存穿透防护</td>
</tr>
<tr>
<td><strong>外部搜索</strong>（Elasticsearch、OpenSearch）</td>
<td>高级全文、模糊搜索</td>
<td>业务层同步、双写</td>
</tr>
<tr>
<td><strong>冷热数据分离</strong></td>
<td>老数据访问少</td>
<td>冷库归档、热库保留活跃数据</td>
</tr>
<tr>
<td><strong>升级数据库引擎</strong>（TiDB、OceanBase）</td>
<td>需要分布式水平扩展</td>
<td>兼容 MySQL 协议，评估迁移成本</td>
</tr>
<tr>
<td><strong>表结构优化</strong>（列裁剪、压缩）</td>
<td>大宽表</td>
<td>只保留必要列、使用 <code>ROW_FORMAT=COMPRESSED</code></td>
</tr>
<tr>
<td><strong>统计信息维护</strong></td>
<td>优化器判断失误</td>
<td><code>ANALYZE TABLE</code>、<code>UPDATE STATISTICS</code></td>
</tr>
</tbody>
</table>
<hr>
<h2 id="15-索引失效却提升性能的典型情形">15. 索引失效却提升性能的典型情形</h2>
<table>
<thead>
<tr>
<th>场景</th>
<th>原因</th>
<th>建议</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>小表（行数几千以下）</strong></td>
<td>全表扫描顺序读硬盘，比随机读索引更快</td>
<td>可不建索引，或使用 <code>FORCE INDEX</code> 让优化器走索引</td>
</tr>
<tr>
<td><strong>查询返回大量行（&gt;30%）</strong></td>
<td>索引查找 + 回表成本 &gt; 顺序全表扫描</td>
<td>考虑 <strong>覆盖索引</strong>，或拆分查询</td>
</tr>
<tr>
<td><strong>低基数列（布尔、枚举）</strong></td>
<td>索引选择性低，查找大量相同值</td>
<td>不为此类列单独建索引；合并到复合索引中提升过滤</td>
</tr>
<tr>
<td><strong>写入频繁且更新索引列</strong></td>
<td>索引维护开销大</td>
<td>减少索引列、延迟写、使用 <strong>延迟更新</strong>（如异步批量）</td>
</tr>
<tr>
<td>**优化器误估</td>
<td>统计信息过时、数据分布不均**</td>
<td>手动 <code>ANALYZE TABLE</code>、使用 <code>FORCE INDEX</code> 或 <code>USE INDEX</code> 调整计划</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="16-常用调优小技巧">16. 常用调优小技巧</h2>
<ul>
<li><strong>使用 <code>EXPLAIN</code> 检查执行计划</strong>：关注 <code>type</code>、<code>possible_keys</code>、<code>key</code>、<code>rows</code>、<code>Extra</code> 中的 “Using where”, “Using index”, “Using filesort”, “Using temporary”。</li>
<li><strong>利用 <code>INFORMATION_SCHEMA.STATISTICS</code> 与 <code>ANALYZE</code></strong> 更新统计信息。</li>
<li><strong>避免函数/表达式在 WHERE 左侧</strong>（除非已建函数索引）。</li>
<li><strong>对经常 <code>GROUP BY</code> / <code>ORDER BY</code> 的列</strong>，使用 <strong>前缀索引</strong> 或 <strong>覆盖索引</strong>。</li>
<li><strong>开启 <code>innodb_buffer_pool_size</code></strong> 至机器物理内存的 70% 左右，提升缓存命中率。</li>
<li><strong>监控慢查询日志</strong>、<code>performance_schema</code>、<code>sys.schema_table_statistics</code>，定位热点。</li>
</ul>
<hr>
<blockquote>
<p><strong>核心结论</strong>：</p>
<ul>
<li><strong>最左前缀原则</strong>是复合索引的根本，任何破坏该原则的查询（范围、% 开头的 LIKE、OR/NOT 等）都会导致索引失效。</li>
<li><strong>覆盖索引</strong>、<strong>函数索引</strong>、<strong>键值分页</strong>是提升查询效率的关键手段。</li>
<li><strong>合理规划索引（列顺序、方向、基数）</strong>、<strong>维护统计信息</strong>、<strong>结合分区/缓存</strong>，才能在大表、高并发场景下保持 MySQL 的高性能。</li>
</ul>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[分析慢查询 总结]]></title>
        <id>https://yuzhupeng.top/myblogs/post/fen-xi-man-cha-xun-zong-jie/</id>
        <link href="https://yuzhupeng.top/myblogs/post/fen-xi-man-cha-xun-zong-jie/">
        </link>
        <updated>2025-08-15T05:39:07.000Z</updated>
        <content type="html"><![CDATA[<p>分析慢查询是数据库性能优化的关键一环。一个慢查询可能导致应用响应延迟、用户体验下降，甚至拖垮整个系统。以下是分析慢查询的详细步骤和常用工具、技巧：</p>
<h3 id="1-开启慢查询日志">1. 开启慢查询日志</h3>
<p>首先，要能找到慢查询，你需要确保数据库的慢查询日志功能已开启，并设置合理的阈值。</p>
<ul>
<li>
<p></p><p></p><p>**MySQL:**</p><p></p><p></p><ul><p></p><p></p><li><p></p><p></p><p>在&nbsp;<code>my.cnf</code>&nbsp;(或&nbsp;<code>my.ini</code>) 配置中设置：</p><p></p><p></p><pre class="highlighter-hljs" highlighted="true"><code class="highlighter-hljs hljs language-ini"><span class="hljs-attr">slow_query_log</span> = <span class="hljs-number">1</span> <span class="hljs-comment"># 开启慢查询日志</span><p></p>
</li>
</ul>
<p><span class="hljs-attr">slow_query_log_file</span> = /var/log/mysql/mysql-slow.log <span class="hljs-comment"># 日志文件路径</span></p>
<p><span class="hljs-attr">long_query_time</span> = <span class="hljs-number">1</span> <span class="hljs-comment"># 慢查询阈值，单位秒。表示查询时间超过1秒的记录。</span></p>
<p><span class="hljs-attr">log_queries_not_using_indexes</span> = <span class="hljs-number">1</span> <span class="hljs-comment"># 记录没有使用索引的查询 (可选，但非常有用)</span></p>
<p></code><p><code class="highlighter-hljs hljs language-ini"></code></p></pre><p></p><p></p></li><p></p><p></p><li><p></p><p></p><p>修改配置后重启 MySQL 服务。</p><p></p><p></p></li><p></p><p></p><li><p></p><p></p><p>也可以在运行时通过 SQL 命令设置，但重启后会失效：</p><p></p><p></p><pre class="highlighter-hljs" highlighted="true"><code class="highlighter-hljs hljs language-sql"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> slow_query_log <span class="hljs-operator">=</span> <span class="hljs-string">'ON'</span>;<p></p></p>
<p><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> slow_query_log_file <span class="hljs-operator">=</span> <span class="hljs-string">'/var/log/mysql/mysql-slow.log'</span>;</p>
<p><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> long_query_time <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;</p>
<p><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> log_queries_not_using_indexes <span class="hljs-operator">=</span> <span class="hljs-string">'ON'</span>;</p>
<p></code><p><code class="highlighter-hljs hljs language-sql"></code></p></pre><p></p><p></p></li><p></p><p></p></ul><p></p><p></p></p>
<ul>
<li>
<p></p><p></p><p>**PostgreSQL:**</p><p></p><p></p><ul><p></p><p></p><li><p></p><p></p><p>在&nbsp;<code>postgresql.conf</code>&nbsp;配置中设置：</p><p></p><p></p><pre class="highlighter-hljs" highlighted="true"><code class="highlighter-hljs hljs language-bash">ini复制代码log_min_duration_statement = 1000 <span class="hljs-comment"># 慢查询阈值，单位毫秒。表示查询时间超过1000毫秒（1秒）的记录。-1表示禁用。</span><p></p>
</li>
</ul>
<p>log_directory = <span class="hljs-string">'pg_log'</span> <span class="hljs-comment"># 日志目录</span></p>
<p>log_filename = <span class="hljs-string">'postgresql-%Y-%m-%d_%H%M%S.log'</span> <span class="hljs-comment"># 日志文件名格式</span></p>
<p></code><p><code class="highlighter-hljs hljs language-bash"></code></p></pre><p></p><p></p></li><p></p><p></p><li><p></p><p></p><p>修改配置后重启 PostgreSQL 服务，或者重新加载配置（<code>pg_ctl reload</code>）。</p><p></p><p></p></li><p></p><p></p></ul><p></p><p></p></p>
<ul>
<li>
<p></p><p></p><p>**SQL Server:**</p><p></p><p></p><ul><p></p><p></p><li>使用 SQL Server Profiler 或 Extended Events 来捕获慢查询事件。Extended Events 是更推荐的方式，性能开销更小。</li><p></p><p></p></ul><p></p><p></p>
</li>
<li>
<p></p><p></p><p>**Oracle:**</p><p></p><p></p><ul><p></p><p></p><li>通过 AWR (Automatic Workload Repository) 报告或 ASH (Active Session History) 报告来分析慢查询。</li><p></p><p></p></ul><p></p><p></p>
</li>
</ul>
<h3 id="2-定位慢查询语句">2. 定位慢查询语句</h3>
<p>读取和分析慢查询日志是第一步。</p>
<ul>
<li>
<p></p><p></p><p>**手动查看日志：**</p><p></p><p></p><ul><p></p><p></p><li>直接打开日志文件，通常是文本文件，可以按时间或执行时间排序。</li><p></p><p></p></ul><p></p><p></p>
</li>
<li>
<p></p><p></p><p>**使用日志分析工具：**</p><p></p><p></p><ul><p></p><p></p><li><p></p><p></p><p>**MySQL:**&nbsp;<code>mysqldumpslow</code>&nbsp;是 MySQL 官方提供的一个命令行工具，用于汇总和分析慢查询日志。</p><p></p><p></p><ul><p></p><p></p><li><code>mysqldumpslow -s t -t 10 /var/log/mysql/mysql-slow.log</code>：按总耗时排序，显示前10条慢查询。</li><p></p><p></p><li><code>mysqldumpslow -s c -t 10 /var/log/mysql/mysql-slow.log</code>：按查询次数排序。</li><p></p><p></p><li><code>mysqldumpslow -s r -t 10 /var/log/mysql/mysql-slow.log</code>：按返回行数排序。</li><p></p><p></p></ul><p></p><p></p></li><p></p><p></p><li><p></p><p></p><p>**Percona Toolkit (pt-query-digest):**&nbsp;更强大、更专业的慢查询日志分析工具，可以生成详细的报告，包括查询模板、执行次数、平均/最大/最小执行时间、锁等待时间、扫描行数等。</p><p></p><p></p><ul><p></p><p></p><li><code>pt-query-digest /var/log/mysql/mysql-slow.log</code></li><p></p><p></p></ul><p></p><p></p></li><p></p><p></p></ul><p></p><p></p>
</li>
<li>
<p></p><p></p><p>**其他数据库特定工具：**&nbsp;根据数据库类型，使用相应的性能监控和分析工具。</p><p></p><p></p>
</li>
</ul>
<h3 id="3-理解-explain-计划">3. 理解 <code>EXPLAIN</code> 计划</h3>
<p>一旦定位到具体的慢查询语句，下一步就是使用数据库的 <code>EXPLAIN</code> (或 <code>EXPLAIN ANALYZE</code>、<code>DESCRIBE</code>) 命令来分析其执行计划。这是分析慢查询的核心步骤。</p>
<ul>
<li>
<p></p><p></p><p>**什么是执行计划？** 执行计划是数据库优化器为 SQL 查询生成的执行步骤蓝图。它展示了数据库如何访问表（全表扫描、索引扫描）、如何连接表（嵌套循环、哈希连接、合并连接）、如何排序、如何聚合等。</p><p></p><p></p>
</li>
<li>
<p></p><p></p><p>**如何使用 <code>EXPLAIN</code>？**</p><p></p><p></p><ul><p></p><p></p><li>在慢查询语句前加上&nbsp;<code>EXPLAIN</code>&nbsp;关键字。</li><p></p><p></p><li>**MySQL:**&nbsp;<code>EXPLAIN SELECT * FROM users WHERE age &gt; 30;</code></li><p></p><p></p><li>**PostgreSQL:**&nbsp;<code>EXPLAIN ANALYZE SELECT * FROM users WHERE age &gt; 30;</code>&nbsp;(<code>ANALYZE</code>&nbsp;会实际执行查询并显示实际的行数和时间，非常有用)</li><p></p><p></p><li>**SQL Server:**&nbsp;在 SSMS 中，点击“显示实际执行计划”或使用&nbsp;<code>SET SHOWPLAN_ALL ON;</code>。</li><p></p><p></p><li>**Oracle:**&nbsp;<code>EXPLAIN PLAN FOR SELECT ...</code>，然后使用&nbsp;<code>SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);</code>&nbsp;查看。</li><p></p><p></p></ul><p></p><p></p>
</li>
<li>
<p></p><p></p><p>**执行计划的关键指标和解读：**</p><p></p><p></p><p>**MySQL <code>EXPLAIN</code> 输出的重要列：**</p><p></p><p></p><ul><p></p><p></p><li><p></p><p></p><p><code>id</code>: select 查询的序列号，越大越优先执行。</p><p></p><p></p></li><p></p><p></p><li><p></p><p></p><p><code>select_type</code>: 查询类型（SIMPLE, PRIMARY, SUBQUERY, UNION等）。</p><p></p><p></p></li><p></p><p></p><li><p></p><p></p><p><code>table</code>: 正在访问的表。</p><p></p><p></p></li><p></p><p></p><li><p></p><p></p><p><code>partitions</code>: 匹配记录所在的分区。</p><p></p><p></p></li><p></p><p></p><li><p></p><p></p><p><code>type</code>:&nbsp;**连接类型/访问类型**，这是最重要的指标之一，反映了表是如何被访问的。</p><p></p><p></p><ul><p></p><p></p><li>**<code>system</code>**: 表只有一行，是&nbsp;<code>const</code>&nbsp;类型的一个特例。</li><p></p><p></p><li>**<code>const</code>**: 通过主键或唯一索引访问一行，非常快。</li><p></p><p></p><li>**<code>eq_ref</code>**: 主键或唯一索引等值查找，用于多表连接，非常快。</li><p></p><p></p><li>**<code>ref</code>**: 非唯一索引查找，返回匹配多行。</li><p></p><p></p><li>**<code>range</code>**: 索引范围扫描，比全索引扫描好。</li><p></p><p></p><li>**<code>index</code>**: 全索引扫描，比全表扫描快，但仍要扫描整个索引。</li><p></p><p></p><li>**<code>all</code>**:&nbsp;**全表扫描**，通常是性能瓶颈，应尽量避免。</li><p></p><p></p></ul><p></p><p></p></li><p></p><p></p><li><p></p><p></p><p><code>possible_keys</code>: 可能使用的索引。</p><p></p><p></p></li><p></p><p></p><li><p></p><p></p><p><code>key</code>: 实际使用的索引。</p><p></p><p></p></li><p></p><p></p><li><p></p><p></p><p><code>key_len</code>: 使用的索引的长度。</p><p></p><p></p></li><p></p><p></p><li><p></p><p></p><p><code>ref</code>: 哪些列或常量被用于查找索引列上的值。</p><p></p><p></p></li><p></p><p></p><li><p></p><p></p><p><code>rows</code>: 估算的扫描行数，越少越好。</p><p></p><p></p></li><p></p><p></p><li><p></p><p></p><p><code>filtered</code>: 表条件过滤出的行百分比。</p><p></p><p></p></li><p></p><p></p><li><p></p><p></p><p><code>Extra</code>: 额外信息，非常重要，指示了优化器执行查询的额外细节。</p><p></p><p></p><ul><p></p><p></p><li><code>Using filesort</code>: 需要额外排序，通常可以优化。</li><p></p><p></p><li><code>Using temporary</code>: 需要使用临时表，通常可以优化。</li><p></p><p></p><li><code>Using index</code>: 覆盖索引，非常高效。</li><p></p><p></p><li><code>Using where</code>: 使用了 WHERE 子句过滤数据。</li><p></p><p></p><li><code>Using join buffer</code>: 使用了连接缓冲区。</li><p></p><p></p><li><code>Using index condition</code>: 索引条件下推，MySQL 5.6+ 特性。</li><p></p><p></p></ul><p></p><p></p></li><p></p><p></p></ul><p></p><p></p>
</li>
</ul>
<h3 id="4-优化策略">4. 优化策略</h3>
<p>根据 <code>EXPLAIN</code> 的结果，针对性地进行优化。</p>
<ul>
<li>
<p></p><p></p><p>**索引优化：**</p><p></p><p></p><ul><p></p><p></p><li><p></p><p></p><p>**添加/优化索引：**&nbsp;这是最常见的优化手段。</p><p></p><p></p><ul><p></p><p></p><li>在&nbsp;<code>WHERE</code>&nbsp;子句、<code>JOIN</code>&nbsp;子句的连接列、<code>ORDER BY</code>&nbsp;和&nbsp;<code>GROUP BY</code>&nbsp;的列上创建索引。</li><p></p><p></p><li>考虑创建复合索引 (联合索引)，并注意其顺序 (最左前缀原则)。</li><p></p><p></p><li>避免在索引列上使用函数操作、模糊查询&nbsp;<code>%xxx</code>&nbsp;开头、类型转换等，这会导致索引失效。</li><p></p><p></p><li>考虑使用覆盖索引 (<code>Using index</code>): 如果查询所需的所有列都包含在索引中，数据库可以直接从索引中获取数据，而无需回表查询，大大提高效率。</li><p></p><p></p></ul><p></p><p></p></li><p></p><p></p><li><p></p><p></p><p>**删除不必要的索引：**&nbsp;过多索引会增加写操作（INSERT/UPDATE/DELETE）的开销，也会占用存储空间。</p><p></p><p></p></li><p></p><p></p></ul><p></p><p></p>
</li>
<li>
<p></p><p></p><p>**SQL 语句优化：**</p><p></p><p></p><ul><p></p><p></p><li><p></p><p></p><p>**避免全表扫描：**&nbsp;确保&nbsp;<code>WHERE</code>&nbsp;子句能有效利用索引。</p><p></p><p></p></li><p></p><p></p><li><p></p><p></p><p>**优化&nbsp;<code>JOIN</code>&nbsp;操作：**</p><p></p><p></p><ul><p></p><p></p><li>确保连接列有索引。</li><p></p><p></p><li>选择合适的连接顺序（小表驱动大表，尽管优化器通常会选择）。</li><p></p><p></p><li>避免笛卡尔积。</li><p></p><p></p></ul><p></p><p></p></li><p></p><p></p><li><p></p><p></p><p>**避免&nbsp;<code>SELECT *</code>：**&nbsp;只选择需要的列，减少数据传输和内存消耗。</p><p></p><p></p></li><p></p><p></p><li><p></p><p></p><p>**优化&nbsp;<code>WHERE</code>&nbsp;子句：**</p><p></p><p></p><ul><p></p><p></p><li>将筛选范围小的条件放在前面（尽管优化器可能调整）。</li><p></p><p></p><li>避免&nbsp;<code>OR</code>&nbsp;连接索引列，可能导致索引失效。考虑使用&nbsp;<code>UNION ALL</code>&nbsp;代替。</li><p></p><p></p><li>使用&nbsp;<code>BETWEEN</code>&nbsp;代替&nbsp;<code>OR</code>&nbsp;进行范围查询。</li><p></p><p></p></ul><p></p><p></p></li><p></p><p></p><li><p></p><p></p><p>**优化&nbsp;<code>ORDER BY</code>&nbsp;和&nbsp;<code>GROUP BY</code>：**&nbsp;尽量利用索引排序/分组，避免&nbsp;<code>Using filesort</code>&nbsp;和&nbsp;<code>Using temporary</code>。</p><p></p><p></p></li><p></p><p></p><li><p></p><p></p><p>**优化子查询：**&nbsp;某些情况下，子查询可以用&nbsp;<code>JOIN</code>&nbsp;或&nbsp;<code>EXISTS</code>/<code>NOT EXISTS</code>&nbsp;代替，可能更高效。</p><p></p><p></p></li><p></p><p></p><li><p></p><p></p><p>**优化&nbsp;<code>LIMIT</code>&nbsp;分页：**&nbsp;对于大数据量分页，尤其是越往后翻，<code>LIMIT offset, count</code>&nbsp;效率越低。可以考虑使用子查询优化或基于游标的分页。</p><p></p><p></p><pre class="highlighter-hljs" highlighted="true"><code class="highlighter-hljs hljs language-sql"><span class="hljs-comment">-- 优化前</span><p></p>
</li>
</ul>
<p><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> large_table <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id LIMIT <span class="hljs-number">100000</span>, <span class="hljs-number">10</span>;</p>
<p><span class="hljs-comment">-- 优化后 (假设id是连续且有索引)</span></p>
<p><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> large_table <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(id) <span class="hljs-keyword">FROM</span> large_table LIMIT <span class="hljs-number">100000</span>, <span class="hljs-number">1</span>) LIMIT <span class="hljs-number">10</span>;</p>
<p><span class="hljs-comment">-- 或</span></p>
<p><span class="hljs-keyword">SELECT</span> t1.<span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> large_table t1 <span class="hljs-keyword">JOIN</span> (<span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> large_table <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id LIMIT <span class="hljs-number">100000</span>, <span class="hljs-number">10</span>) t2 <span class="hljs-keyword">ON</span> t1.id <span class="hljs-operator">=</span> t2.id;</p>
<p></code><p><code class="highlighter-hljs hljs language-sql"></code></p></pre><p></p><p></p></li><p></p><p></p></ul><p></p><p></p></p>
<ul>
<li>
<p></p><p></p><p>**数据库结构优化：**</p><p></p><p></p><ul><p></p><p></p><li>**字段类型优化：**&nbsp;选择最合适、最小的数据类型。例如，如果一个字段只存储0-255，用&nbsp;<code>TINYINT</code>&nbsp;比&nbsp;<code>INT</code>&nbsp;更好。</li><p></p><p></p><li>**范式与反范式：**&nbsp;适当进行反范式设计（数据冗余）以减少 JOIN 操作，但要权衡数据一致性。</li><p></p><p></p><li>**分区表 (Partitioning)：**&nbsp;将大表分成更小的、可管理的部分，提高查询效率，尤其是在涉及时间范围查询时。</li><p></p><p></p></ul><p></p><p></p>
</li>
<li>
<p></p><p></p><p>**硬件和系统配置优化：**</p><p></p><p></p><ul><p></p><p></p><li>增加内存：提升缓存命中率，减少磁盘 I/O。</li><p></p><p></p><li>使用更快的存储设备：SSD 替代 HDD。</li><p></p><p></p><li>优化数据库配置参数：调整缓存大小 (如 MySQL 的&nbsp;<code>innodb_buffer_pool_size</code>)、线程池、连接数等。</li><p></p><p></p><li>升级 CPU。</li><p></p><p></p></ul><p></p><p></p>
</li>
</ul>
<h3 id="5-持续监控和迭代">5. 持续监控和迭代</h3>
<p>性能优化是一个持续的过程。</p>
<ul>
<li>
<p></p><p></p><p>**监控工具：**</p><p></p><p></p><ul><p></p><p></p><li>**数据库内置监控：**&nbsp;MySQL Workbench、pgAdmin、SQL Server Management Studio。</li><p></p><p></p><li>**第三方监控工具：**&nbsp;Prometheus + Grafana、Zabbix、Datadog、阿里云/腾讯云的数据库性能监控服务。</li><p></p><p></p></ul><p></p><p></p>
</li>
<li>
<p></p><p></p><p>**定期审查：**&nbsp;定期检查慢查询日志和系统性能指标，识别新的慢查询或性能瓶颈。</p><p></p><p></p>
</li>
<li>
<p></p><p></p><p>**灰度发布/测试：**&nbsp;对优化后的 SQL 语句或索引变更进行充分的测试，在生产环境小范围灰度发布，观察效果，避免引入新的问题。</p><p></p><p></p>
</li>
</ul>
<h3 id="慢查询分析流程图">慢查询分析流程图：</h3>
<pre><code>+-------------------+      +---------------------+      +---------------------+
| 1. 开启慢查询日志 |-----&gt;| 2. 定位慢查询语句   |-----&gt;| 3. 分析 EXPLAIN 计划|
|   - 设置阈值      |      |   - 查看日志        |      |   - 关键指标解读    |
|   - 配置持久化    |      |   - 使用分析工具    |      |   - 查找瓶颈        |
+-------------------+      +---------------------+      +---------------------+
         |                                                           |
         |                                                           V
         |                           +---------------------+      +-------------------+
         +---------------------------&gt;| 5. 持续监控和迭代   |&lt;-----| 4. 应用优化策略   |
                                     |   - 性能监控        |      |   - 索引优化      |
                                     |   - 定期审查        |      |   - SQL语句优化   |
                                     |   - 灰度/测试       |      |   - 结构/配置优化 |
                                     +---------------------+      +-------------------+
</code></pre>
<p>通过以上系统化的分析方法，你可以有效地识别、诊断和解决数据库中的慢查询问题，从而提升整个应用的性能和用户体验。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[消息中间件  整理]]></title>
        <id>https://yuzhupeng.top/myblogs/post/xiao-xi-zhong-jian-jian-zheng-li/</id>
        <link href="https://yuzhupeng.top/myblogs/post/xiao-xi-zhong-jian-jian-zheng-li/">
        </link>
        <updated>2025-08-05T08:40:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第01章_消息中间件">第01章_消息中间件</h1>
<h2 id="1-消息中间件简介">1. 消息中间件简介</h2>
<h3 id="11-概述">1.1 概述</h3>
<p>中间件（Middleware）用于分布式系统中，它是脱离于具体设计目标，而具备提供普遍独立功能需求的模块。</p>
<p>消息中间件，利用可靠的消息传递机制进行系统和系统之间的通讯，它通过提供消息传递和消息分派机制，可以在分布式系统环境下扩展进程间的通讯。MQ(message queue)是一个FIFO的队列，其中存放的内容是message，MQ是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ是一种非常常见的上下游<code>逻辑解耦+物理解耦</code>的消息通信服务。使用了MQ之后，消息发送上游只需要依赖MQ，不用依赖其他服务。</p>
<h3 id="12-mq的作用">1.2 MQ的作用</h3>
<p><strong>流量削峰</strong></p>
<p>例如，订单系统最多能每秒处理一万个订单，如果在高峰期某一秒有十万次下单，则订单系统无法承受。我们可以使用消息队列做缓冲，将订单消息都保存在消息队列中，而订单系统依旧根据自己的能力每秒取一万个订单消息进行处理。这样，我们就把一秒内下的十万个订单分散成一段时间来处理，虽然用户可能会在下单十几秒后才能收到下单成功的响应，但是总比下单失败的体验要好。这就是MQ削峰填谷的作用。</p>
<p><strong>数据缓冲</strong></p>
<p>例如日志中心的实现方式，通常就是使用Kafka消息队列作数据缓冲，让日志采集服务先将消息写入消息队列，然后日志处理服务再订阅消费。</p>
<p><strong>应用解耦</strong></p>
<p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果串行调用库存系统、物流系统、支付系统，那么任何一个子系统出了故障，都会造成下单操作异常。我们可以在用户创建订单后，发送一个订单消息到消息队列，然后响应给用户。这样，各个子系统通过订阅消息队列的方式来进行各自的业务处理，即使某个子系统故障，也不会影响其他子系统，实现了应用解耦。</p>
<p><strong>异步处理</strong></p>
<p>有些服务间调用是异步的，例如A调用B，B需要花费很长时间执行，但是A需要知道B什么时候可以执行完。使用消息队列，可以很方便解决这个问题，当B处理完成后，会发送一条消息给MQ，MQ会将此消息转发给A服务。这样A服务可以继续执行自己的业务，还能及时得到异步处理成功的消息。</p>
<blockquote>
<p>总结：MQ的核心作用就是<strong>削峰（缓冲）、解耦、异步</strong>。</p>
</blockquote>
<h3 id="13-mq的分类">1.3 MQ的分类</h3>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th>ActiveMQ</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
<th>Kafka</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>开发语言</strong></td>
<td>Java</td>
<td>Erlang</td>
<td>Java</td>
<td>Scala和Java</td>
</tr>
<tr>
<td style="text-align:left"><strong>消息协议</strong></td>
<td>JMS</td>
<td>AMQP</td>
<td>类似JMS</td>
<td>类似JMS</td>
</tr>
<tr>
<td style="text-align:left"><strong>单机吞吐量</strong></td>
<td>万级</td>
<td>十万级不到</td>
<td>十万级以上</td>
<td>接近百万级</td>
</tr>
<tr>
<td style="text-align:left"><strong>消息延时</strong></td>
<td>ms级</td>
<td>us级</td>
<td>ms级</td>
<td>ms级以内</td>
</tr>
<tr>
<td style="text-align:left"><strong>消费模式</strong></td>
<td>默认push，也支持pull</td>
<td>默认push，也支持pull</td>
<td>pull</td>
<td>pull</td>
</tr>
</tbody>
</table>
<p>其他特点：</p>
<ul>
<li>ActiveMQ是早期使用较多的MQ，但现在<strong>官方社区对ActiveMQ的维护越来越少</strong>。</li>
<li>RabbitMQ适用于<strong>数据量不大的场景</strong>，且它基于Erlang语言开发，所以难以进行二次开发。</li>
<li>RocketMQ在设计时参考了Kafka并做出了一些改进，消息可以做到零丢失，适用于<strong>金融互联网领域</strong>等可靠性要求较高的场景。</li>
<li>Kafka吞吐量极高，在<strong>大数据领域和日志领域</strong>应用广泛。缺点是Kafka的功能较为单一，而且单机不支持过多Topic（单机Topic达到百级，吞吐量会大幅度下降）；而RocketMQ就对这一点做了优化（单机Topic即使达到千级，吞吐量也只会有小幅度下降）。</li>
</ul>
<blockquote>
<p>说明：消费者的消费模式有push模式和pull模式。push模式下，MQ会将消息推送给消费者，所以消息延时低、实时性高；pull模式下，消费者主动从MQ中拉取消息，所以消费者可以按照自己的能力来进行消费，不至于被大流量压垮。</p>
</blockquote>
<h2 id="2-rabbitmq简介">2. RabbitMQ简介</h2>
<p>官网地址 https://www.rabbitmq.com/</p>
<h3 id="21-三大核心概念">2.1 三大核心概念</h3>
<ul>
<li>生产者：发送消息的一方</li>
<li>消息队列：存储消息的容器</li>
<li>消费者：接收消息的一方</li>
</ul>
<h3 id="22-rabbitmq工作模型">2.2 RabbitMQ工作模型</h3>
<figure data-type="image" tabindex="1"><img src="images/Snipaste20231217122744.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>Broker</strong>：消息服务器，即RabbitMQ Server</li>
<li><strong>Virtual host</strong>：虚拟主机，即一个虚拟分组，类似于网络中的namespace概念。当多个不同的用户使用同一个RabbitMQ Server时，可以划分出多个Virtual host，每个用户在自己的Virtual host创建exchange或queue等。这样做可以使分类更清晰，且相互隔离。</li>
<li><strong>Connection</strong>：连接RabbitMQ服务器的TCP长连接</li>
<li><strong>Channel</strong>：信道（Channel）是生产者、消费者与 RabbitMQ 通信的渠道，发送和接收消息都是通过信道进行的。信道是建立在 TCP 连接上的虚拟连接，每条 TCP 连接上的信道数量没有限制。就是说 RabbitMQ 在一条 TCP 连接上建立成百上千个信道来达到多个线程处理，这个 TCP 被多个线程共享，每个信道在 RabbitMQ 都有唯一的 ID，保证了信道私有性，每个信道对应一个线程使用。<strong>Channel是轻量级的，能大幅减少操作系统建立TCP连接的开销</strong>。</li>
<li><strong>Exchange</strong>：交换机负责从生产者接收消息，并根据交换机类型分发到对应的消息队列中，起到一个路由的作用</li>
<li><strong>Routing Key</strong>：交换机根据路由键来决定消息分发到哪个队列，路由键就相当于消息的目的地址</li>
<li><strong>Binding</strong>：绑定是队列和交换机的一个关联关系</li>
<li><strong>Queue</strong>：队列，即存储消息的容器</li>
</ul>
<h3 id="23-rabbitmq的工作模式">2.3 RabbitMQ的工作模式</h3>
<p>RabbitMQ主要有以下几种工作模式：</p>
<ul>
<li>work queues（工作队列模式）：多个消费者共同消费同一个队列中的消息（<strong>轮询分发消息</strong>的方式）。一般对于任务较多的场景，可以使用work queues模式提高任务处理的速度。</li>
<li>publish/subscribe（发布订阅模式）：生产者将消息发给交换机（Fanout类型），由交换机将消息转发到绑定此交换机的每个队列，<strong>每个绑定此交换机的队列都将接收到消息</strong>。</li>
<li>routing（路由模式）：生产者将消息发给交换机（Direct类型），由交换机根据routingKey来<strong>转发消息到指定的队列</strong>。</li>
<li>topics（主题模式）：生产者将消息发给交换机（Topic类型），由交换机根据routingKey来转发消息到指定的队列，注意，队列绑定交换机时设置的绑定key可以<strong>带有通配符</strong>。</li>
<li>header：生产者将消息发给交换机（Headers类型），交换机基于消息属性中的headers进行匹配。</li>
</ul>
<h3 id="24-amqp协议">2.4 AMQP协议</h3>
<p>AMQP，即Advanced Message Queuing Protocol，是一个提供统一消息服务的应用层标准<strong>高级消息队列协议</strong>，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受不同开发语言等条件的限制。</p>
<p>RabbitMQ就是AMQP协议的<code>Erlang</code>实现。AMQP的模型架构和RabbitMQ的模型架构是一样的，生产者将消息发送给交换机，交换机和队列绑定。</p>
<blockquote>
<p>说明：RabbitMQ中的交换机、交换机类型、队列、绑定、路由键等都是遵循的AMQP协议中相应的概念。</p>
</blockquote>
<p><strong>AMQP模型的三大组件</strong>：</p>
<ul>
<li><strong>交换机(Exchange)</strong>：消息代理服务器中用于把消息路由到队列的组件。</li>
<li><strong>队列(Queue)</strong>：用来存储消息的数据结构。</li>
<li><strong>绑定(Binding)</strong>：队列和交换机的一个关联关系。</li>
</ul>
<h2 id="3-docker安装rabbitmq">3. Docker安装RabbitMQ</h2>
<p><strong>1、下载rabbitmq镜像</strong></p>
<pre><code class="language-shell">docker pull rabbitmq:management
</code></pre>
<p><strong>2、创建一个数据卷，专门用于持久化RabbitMQ的所有数据</strong></p>
<pre><code class="language-shell">mkdir -p /docker/rabbitmq
</code></pre>
<p><strong>3、启动容器实例，并创建用户</strong></p>
<pre><code class="language-shell">docker run -d --name rabbitmq \
-p 15672:15672 -p 5672:5672 \
--restart=always \
-v /docker/rabbitmq:/var/lib/rabbitmq \
-e RABBITMQ_DEFAULT_USER=admin \
-e RABBITMQ_DEFAULT_PASS=abc666 \
rabbitmq:management
</code></pre>
<p>说明：</p>
<ul>
<li>15672端口：RabbitMQ的web管理页面端口</li>
<li>5672端口：RabbitMQ的消息接收端口</li>
<li>RABBITMQ_DEFAULT_USER环境变量：指定RabbitMQ的用户名</li>
<li>RABBITMQ_DEFAULT_PASS环境变量：指定RabbitMQ的密码</li>
</ul>
<h2 id="4-springboot整合rabbitmq">4. SpringBoot整合RabbitMQ</h2>
<p><strong>引入依赖</strong>：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;
    &lt;artifactId&gt;spring-rabbit-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>配置文件(RabbitMQ单机)</strong>：</p>
<pre><code class="language-properties">spring.rabbitmq.host=192.168.231.101
spring.rabbitmq.port=5672
spring.rabbitmq.username=admin
spring.rabbitmq.password=abc666
spring.rabbitmq.virtual-host=/
</code></pre>
<p><strong>配置文件(RabbitMQ集群)</strong>：</p>
<pre><code class="language-properties">spring.rabbitmq.addresses=192.168.231.101:5672,192.168.231.102:5672,192.168.231.103:5672
spring.rabbitmq.username=admin
spring.rabbitmq.password=abc666
spring.rabbitmq.virtual-host=/
</code></pre>
<h1 id="第02章_常用api">第02章_常用API</h1>
<h2 id="1-exchange">1. Exchange</h2>
<h3 id="11-exchange">1.1 Exchange</h3>
<p>org.springframework.amqp.core.Exchange接口代表交换机。RabbitMQ有四种交换机类型，我们以其中之一DirectExchange为例查看交换机的常用参数。</p>
<pre><code class="language-java">// DirectExchange的构造器
DirectExchange(String name, boolean durable, boolean autoDelete, Map&lt;String, Object&gt; arguments)
</code></pre>
<ul>
<li>name: 交换机的名称</li>
<li>durable: 是否持久化到硬盘，true表示RabbitMQ服务器重启后该交换机仍然存在。一般都设置为true。</li>
<li>autoDelete: 是否自动删除，true表示如果曾经有队列/交换机绑定到该交换机，后来所有与之绑定的队列/交换机全都与之解绑了，则自动删除该交换机。一般都设置为false。</li>
<li>arguments: 交换机的属性参数</li>
</ul>
<blockquote>
<p>说明：事实上一般交换机的属性参数arguments只有一个<code>alternate-exchange</code>，即设置对应的备用交换机。设置该参数后，如果发送到该交换机的消息无法被路由，则会将其转发到所设置的备用交换机。</p>
</blockquote>
<h3 id="12-exchangebuilder">1.2 ExchangeBuilder</h3>
<p>通常我们使用ExchangeBuilder的建造者模式来创建交换机。ExchangeBuilder类的常用API：</p>
<ul>
<li><code>static ExchangeBuilder fanoutExchange(String name)</code>：创建一个扇出交换机</li>
<li><code>static ExchangeBuilder directExchange(String name)</code>：创建一个直接交换机</li>
<li><code>static ExchangeBuilder topicExchange(String name)</code>：创建一个主题交换机</li>
<li><code>static ExchangeBuilder headersExchange(String name)</code>：创建一个头部交换机</li>
<li><code>ExchangeBuilder durable(boolean isDurable)</code>：设置该交换机是否持久化。如果不设置，<strong>默认是持久化的</strong>。</li>
<li><code>ExchangeBuilder autoDelete()</code>：设置该交换机为自动删除的。如果不设置，<strong>默认是不自动删除的</strong>。</li>
<li><code>ExchangeBuilder withArguments(Map&lt;String, Object&gt; arguments)</code>：设置交换机的属性参数</li>
<li><code>ExchangeBuilder withArgument(String key, Object value)</code>：设置交换机的单个属性参数</li>
<li><code>T build()</code>：构建出交换机</li>
</ul>
<p><strong>设置具体属性参数的API</strong></p>
<ul>
<li><code>ExchangeBuilder alternate(String exchange)</code>：设置备用交换机，等价于设置属性参数<code>alternate-exchange</code></li>
</ul>
<h2 id="2-queue">2. Queue</h2>
<h3 id="21-queue">2.1 Queue</h3>
<p>org.springframework.amqp.core.Queue类代表队列，其构造器为</p>
<pre><code class="language-java">Queue(String name, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)
</code></pre>
<ul>
<li>name: 队列的名称</li>
<li>durable: 是否持久化到硬盘，true表示RabbitMQ服务器重启后该队列仍然存在。一般都设置为true。</li>
<li>exclusive: 是否独占，true表示只有第一个连接它的消费者能消费其消息，其他消费者都无法连接该队列，并且当第一个连接它的消费者断开连接后，该队列就直接自动删除。一般都设置为false。</li>
<li>autoDelete: 是否自动删除，true表示如果曾经有消费者连接到该交换机，后来所有与之连接的消费者都断开连接了，则自动删除该队列。一般都设置为false。</li>
<li>arguments: 队列的属性参数</li>
</ul>
<h3 id="22-queuebuilder">2.2 QueueBuilder</h3>
<p>通常我们使用QueueBuilder的建造者模式来创建队列。QueueBuilder的常用API：</p>
<ul>
<li><code>static QueueBuilder durable(String name)</code>：创建一个持久化的队列</li>
<li><code>static QueueBuilder nonDurable(String name)</code>：创建一个非持久化的队列</li>
<li><code>QueueBuilder exclusive()</code>：设置该队列为独占的。如果不设置，<strong>默认是非独占的</strong>。</li>
<li><code>QueueBuilder autoDelete()</code>：设置该队列为自动删除的。如果不设置，<strong>默认是不自动删除的</strong>。</li>
<li><code>QueueBuilder withArguments(Map&lt;String, Object&gt; arguments)</code>：设置队列的属性参数</li>
<li><code>QueueBuilder withArgument(String key, Object value)</code>：设置队列的单个属性参数</li>
<li><code>Queue build()</code>：构建出队列</li>
</ul>
<p><strong>设置具体属性参数的API(常用)</strong></p>
<ul>
<li><code>QueueBuilder ttl(int ttl)</code>：设置队列中消息的TTL(即存活时间，单位ms)。等价于设置属性参数<code>x-message-ttl</code></li>
<li><code>QueueBuilder deadLetterExchange(String dlx)</code>：设置队列对应的死信交换机。等价于设置属性参数<code>x-dead-letter-exchange</code></li>
<li><code>QueueBuilder deadLetterRoutingKey(String dlrk)</code>：设置死信对应的路由key。等价于设置属性参数<code>x-dead-letter-routing-key</code></li>
<li><code>QueueBuilder maxLength(int count)</code>：设置队列的最大长度。等价于设置属性参数<code>x-max-length</code></li>
</ul>
<p><strong>设置具体属性参数的API(不常用)</strong></p>
<ul>
<li><code>QueueBuilder maxPriority(int maxPriority)</code>：设置队列的最大优先级(范围是0-255)。等价于设置属性参数<code>x-max-priority</code>。详细参考优先级队列相关章节。</li>
<li><code>QueueBuilder lazy()</code>：设置队列模式为lazy。等价于设置属性参数<code>x-queue-mode</code>的值为<code>&quot;lazy&quot;</code>。详细参考惰性队列相关章节。</li>
<li><code>QueueBuilder expires(int expires)</code>：当队列在指定时间内(单位ms)未被访问时，会自动删除。等价于设置属性参数<code>x-expires</code></li>
<li><code>QueueBuilder overflow(Overflow overflow)</code>：设置队列的溢出行为，参数只能是以下两种
<ul>
<li><code>QueueBuilder.Overflow.dropHead</code>：这是<strong>默认的策略</strong>，队列满时丢弃队首消息，队尾加入新消息。等价于设置属性参数<code>x-overflow</code>的值为<code>&quot;drop-head&quot;</code></li>
<li><code>QueueBuilder.Overflow.rejectPublish</code>：队列满时直接拒绝新消息，即丢弃新消息。等价于设置属性参数<code>x-overflow</code>的值为<code>&quot;reject-publish&quot;</code></li>
</ul>
</li>
<li><code>QueueBuilder singleActiveConsumer()</code>：设置该队列只能有一个消费者来连接。等价于设置属性参数<code>x-single-active-consumer</code>的值为true</li>
<li><code>QueueBuilder maxLengthBytes(int bytes)</code>：设置队列的最大容量(单位是字节)。等价于设置属性参数<code>x-max-length-bytes</code></li>
</ul>
<h2 id="3-binding">3. Binding</h2>
<h3 id="31-binding">3.1 Binding</h3>
<p>org.springframework.amqp.core.Binding类代表交换机和队列之间的绑定关系。</p>
<h3 id="32-bindingbuilder">3.2 BindingBuilder</h3>
<p>通常我们使用BindingBuilder的建造者模式来创建绑定关系。创建绑定关系的常用写法：</p>
<pre><code class="language-java">// 绑定队列到fanout交换机
return BindingBuilder.bind(queue).to(fanoutExchange);
// 绑定队列到direct交换机
return BindingBuilder.bind(queue).to(directExchange).with(&quot;routingKey&quot;);
// 绑定队列到topic交换机
return BindingBuilder.bind(queue).to(topicExchange).with(&quot;routingKey&quot;);
// 绑定队列到headers交换机
return BindingBuilder.bind(queue).to(headersExchange)
        .whereAll(Map&lt;String, Object&gt; headerValues).match();
</code></pre>
<h2 id="4-message">4. Message</h2>
<h3 id="41-message">4.1 Message</h3>
<p>org.springframework.amqp.core.Message类代表消息。Message的常用API：</p>
<ul>
<li><code>Message(byte[] body)</code>：构造器，设置消息体</li>
<li><code>Message(byte[] body, MessageProperties messageProperties)</code>：构造器，设置消息体和消息属性</li>
<li><code>byte[] getBody()</code>：获取消息体</li>
<li><code>MessageProperties getMessageProperties()</code>：获取消息属性</li>
</ul>
<h3 id="42-messagebuilder">4.2 MessageBuilder</h3>
<p>通常我们使用MessageBuilder的建造者模式来创建消息。MessageBuilder的常用API：</p>
<ul>
<li><code>static MessageBuilder withBody(byte[] body)</code>：设置消息体，即消息的内容</li>
<li><code>MessageBuilder andProperties(MessageProperties properties)</code>：设置消息的属性</li>
<li><code>Message build()</code>：构建出消息</li>
</ul>
<h3 id="43-messageproperties">4.3 MessageProperties</h3>
<p>MessageProperties代表消息属性，它的常用成员变量如下（有对应的getter和setter方法）：</p>
<ul>
<li><code>Map&lt;String, Object&gt; headers;</code> 消息头</li>
<li><code>String expiration;</code> 消息的存活时间，单位ms</li>
<li><code>long deliveryTag;</code> 消息的投递序号</li>
</ul>
<p>常用API：</p>
<ul>
<li><code>void setDelay(Integer delay)</code>：给消息头中设置<code>x-delay</code>属性（单位ms），用于配合延迟队列插件使用</li>
</ul>
<h1 id="第03章_交换机">第03章_交换机</h1>
<h2 id="1-交换机简介">1. 交换机简介</h2>
<p>RabbitMQ消息传递模型的核心思想是: <strong>生产者生产的消息不会直接发送到队列，而是只能将消息发送到交换机(Exchange)</strong>。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。</p>
<p>交换机工作的内容非常简单：一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息，是应该把这些消息放到特定队列、还是把它们放到许多队列中、还是应该丢弃它们，这就由交换机的类型来决定。</p>
<p><strong>Exchange有四种类型</strong>：</p>
<ul>
<li>扇出(fanout)</li>
<li>直接(direct)</li>
<li>主题(topic)</li>
<li>头部(headers)</li>
</ul>
<blockquote>
<p>说明：binding指的是exchange和queue之间的绑定关系。<strong>在绑定时</strong>，direct和topic类型的交换机都需要设置队列的routingKey；而headers类型的交换机需要设置匹配的消息头属性；fanout类型的交换机什么都不需要设置。</p>
</blockquote>
<h2 id="2-fanout-exchange">2. Fanout Exchange</h2>
<h3 id="21-fanout介绍">2.1 Fanout介绍</h3>
<p>Fanout类型的交换机，会将消息<strong>广播</strong>发送到它绑定的所有队列中，所以其routingKey无需设置。这种交换机表示的就是<strong>发布订阅模式</strong>。</p>
<h3 id="22-fanout实战">2.2 Fanout实战</h3>
<h4 id="1-配置类">1、配置类</h4>
<pre><code class="language-java">@Configuration
public class RabbitConfig {
    @Bean // 定义交换机
    public FanoutExchange fanoutExchange() {
        return ExchangeBuilder.fanoutExchange(&quot;exchange.fanout&quot;).build();
    }

    @Bean // 定义队列A
    public Queue queueA() {
        return QueueBuilder.durable(&quot;queue.a&quot;).build();
    }
    @Bean // 定义队列B
    public Queue queueB() {
        return QueueBuilder.durable(&quot;queue.b&quot;).build();
    }

    @Bean // 绑定交换机和队列A
    public Binding bindingA(FanoutExchange fanoutExchange, Queue queueA) {
        return BindingBuilder.bind(queueA).to(fanoutExchange);
    }
    @Bean // 绑定交换机和队列B
    public Binding bindingB(FanoutExchange fanoutExchange, Queue queueB) {
        return BindingBuilder.bind(queueB).to(fanoutExchange);
    }
}
</code></pre>
<h4 id="2-消息生产者">2、消息生产者</h4>
<p>使用RabbitTemplate来发送消息：</p>
<ul>
<li><code>void convertAndSend(String exchange, String routingKey, Object object)</code></li>
</ul>
<pre><code class="language-java">@RestController
public class MessageProducer {
    @Autowired
    private RabbitTemplate template;

    @GetMapping(&quot;/send&quot;)
    public void sendMsg() {
        Message msg = new Message(&quot;hello world&quot;.getBytes());
        template.convertAndSend(&quot;exchange.fanout&quot;, &quot;&quot;, msg);
    }
}
</code></pre>
<h4 id="3-消息消费者">3、消息消费者</h4>
<p>使用@RabbitListener注解来监听队列中的消息</p>
<pre><code class="language-java">@Component
public class MessageConsumer {
    @RabbitListener(queues = {&quot;queue.a&quot;, &quot;queue.b&quot;})
    public void receiveMsg(Message msg) {
        byte[] body = msg.getBody();
        String str = new String(body);
        System.out.println(&quot;收到消息：&quot; + str);
    }
}
</code></pre>
<h2 id="3-direct-exchange">3. Direct Exchange</h2>
<h3 id="31-direct介绍">3.1 Direct介绍</h3>
<p>Direct类型的交换机，会将收到的消息只发送给它绑定的相应<strong>精确routingKey的队列中</strong>去。</p>
<ul>
<li>交换机与同一个队列绑定时，也可以设置多个routingKey</li>
<li>交换机与不同的队列绑定时，也可以设置相同的routingKey</li>
</ul>
<blockquote>
<p>注意：如果根据某个消息的routingKey路由不到对应的queue，那么该消息就会被直接丢弃。</p>
</blockquote>
<h3 id="32-direct实战">3.2 Direct实战</h3>
<blockquote>
<p>需求：我们创建一个direct类型的交换机，将warning信息发给a队列，将error信息发送给a和b队列。</p>
</blockquote>
<h4 id="1-配置类-2">1、配置类</h4>
<pre><code class="language-java">@Configuration
public class RabbitConfig {
    @Bean
    public DirectExchange directExchange() {
        return ExchangeBuilder.directExchange(&quot;exchange.direct&quot;).build();
    }

    @Bean
    public Queue queueA() {
        return QueueBuilder.durable(&quot;queue.a&quot;).build();
    }
    @Bean
    public Queue queueB() {
        return QueueBuilder.durable(&quot;queue.b&quot;).build();
    }

    @Bean
    public Binding bindingA1(DirectExchange directExchange, Queue queueA) {
        return BindingBuilder.bind(queueA).to(directExchange)
                .with(&quot;warning&quot;);
    }
    @Bean
    public Binding bindingA2(DirectExchange directExchange, Queue queueA) {
        return BindingBuilder.bind(queueA).to(directExchange)
                .with(&quot;error&quot;);
    }
    @Bean
    public Binding bindingB(DirectExchange directExchange, Queue queueB) {
        return BindingBuilder.bind(queueB).to(directExchange)
                .with(&quot;error&quot;);
    }
}
</code></pre>
<h4 id="2-消息生产者-2">2、消息生产者</h4>
<pre><code class="language-java">@RestController
public class MessageProducer {
    @Autowired
    private RabbitTemplate template;

    @GetMapping(&quot;/warn&quot;)
    public void sendWarning() {
        Message msg = MessageBuilder.withBody(&quot;hello warning&quot;.getBytes()).build();
        template.convertAndSend(&quot;exchange.direct&quot;, &quot;warning&quot;, msg);
    }
    @GetMapping(&quot;/err&quot;)
    public void sendError() {
        Message msg = MessageBuilder.withBody(&quot;hello error&quot;.getBytes()).build();
        template.convertAndSend(&quot;exchange.direct&quot;, &quot;error&quot;, msg);
    }
}
</code></pre>
<h4 id="3-消息消费者-2">3、消息消费者</h4>
<pre><code class="language-java">@Component
public class MessageConsumer {
    @RabbitListener(queues = &quot;queue.a&quot;)
    public void receiveA(Message msg) {
        byte[] body = msg.getBody();
        String str = new String(body);
        System.out.println(&quot;收到A中的消息：&quot; + str);
    }

    @RabbitListener(queues = &quot;queue.b&quot;)
    public void receiveB(Message msg) {
        byte[] body = msg.getBody();
        String str = new String(body);
        System.out.println(&quot;收到B中的消息：&quot; + str);
    }
}
</code></pre>
<h2 id="4-topic-exchange">4. Topic Exchange</h2>
<h3 id="41-topic介绍">4.1 Topic介绍</h3>
<p>Topic类型的交换机是Direct类型的增强，同样会将收到的消息只发送给它绑定的相应routingKey的队列中去，但其routingKey可以使用通配符匹配。</p>
<p>Topic交换机的routingKey必须满足一定的要求，它必须是<strong>一个单词列表，以点号分隔开</strong>。且这个单词列表最多不能超过255个字节。注意，可以使用两个特殊的替换符：</p>
<ul>
<li><code>*</code>可以匹配任意一个单词</li>
<li><code>#</code>可以匹配任意0个或多个单词</li>
</ul>
<p>例如，topic交换机与队列a通过<code>routingKey=&quot;*.orange.*&quot;</code>绑定，与队列b通过<code>routingKey=&quot;*.*.rabbit&quot;</code>和<code>routingKey=&quot;lazy.#&quot;</code>绑定，那么</p>
<ul>
<li>a.orange.rabbit则会路由到a和b</li>
<li>lazy.abc会路由到b</li>
<li>lazy.abc.rabbit会路由到b</li>
</ul>
<blockquote>
<p>注意：如果根据某个消息的routingKey路由不到对应的queue，那么该消息就会被直接丢弃。</p>
</blockquote>
<h3 id="42-topic实战">4.2 Topic实战</h3>
<h4 id="1-配置类-3">1、配置类</h4>
<pre><code class="language-java">@Configuration
public class RabbitConfig {
    @Bean
    public TopicExchange topicExchange() {
        return ExchangeBuilder.topicExchange(&quot;exchange.topic&quot;).build();
    }

    @Bean
    public Queue queueA() {
        return QueueBuilder.durable(&quot;queue.a&quot;).build();
    }
    @Bean
    public Queue queueB() {
        return QueueBuilder.durable(&quot;queue.b&quot;).build();
    }

    @Bean
    public Binding bindingA(TopicExchange topicExchange, Queue queueA) {
        return BindingBuilder.bind(queueA).to(topicExchange)
                .with(&quot;*.orange.*&quot;);
    }
    @Bean
    public Binding bindingB1(TopicExchange topicExchange, Queue queueB) {
        return BindingBuilder.bind(queueB).to(topicExchange)
                .with(&quot;*.*.rabbit&quot;);
    }
    @Bean
    public Binding bindingB2(TopicExchange topicExchange, Queue queueB) {
        return BindingBuilder.bind(queueB).to(topicExchange)
                .with(&quot;lazy.#&quot;);
    }
}
</code></pre>
<h4 id="2-消息生产者-3">2、消息生产者</h4>
<pre><code class="language-java">@RestController
public class MessageProducer {
    @Autowired
    private RabbitTemplate template;

    @GetMapping(&quot;/test1&quot;)
    public void test1() {
        Message msg = new Message(&quot;test1 haha&quot;.getBytes());
        template.convertAndSend(&quot;exchange.topic&quot;, &quot;a.orange.rabbit&quot;, msg);
    }
    @GetMapping(&quot;/test2&quot;)
    public void test2() {
        Message msg = new Message(&quot;test2 haha&quot;.getBytes());
        template.convertAndSend(&quot;exchange.topic&quot;, &quot;lazy.abc&quot;, msg);
    }
    @GetMapping(&quot;/test3&quot;)
    public void test3() {
        Message msg = new Message(&quot;test3 haha&quot;.getBytes());
        template.convertAndSend(&quot;exchange.topic&quot;, &quot;lazy.abc.rabbit&quot;, msg);
    }
}
</code></pre>
<h4 id="3-消息消费者-3">3、消息消费者</h4>
<pre><code class="language-java">@Component
public class MessageConsumer {
    @RabbitListener(queues = &quot;queue.a&quot;)
    public void receiveA(Message msg) {
        byte[] body = msg.getBody();
        String str = new String(body);
        System.out.println(&quot;收到A中的消息：&quot; + str);
    }

    @RabbitListener(queues = &quot;queue.b&quot;)
    public void receiveB(Message msg) {
        byte[] body = msg.getBody();
        String str = new String(body);
        System.out.println(&quot;收到B中的消息：&quot; + str);
    }
}
</code></pre>
<h2 id="5-headers-exchange">5. Headers Exchange</h2>
<h3 id="51-headers介绍">5.1 Headers介绍</h3>
<p>Headers类型的交换机，基于消息属性中的headers进行匹配，所以其routingKey并没有作用。</p>
<blockquote>
<p>说明：Headers类型的交换机性能很差，而且很不实用，实际生产中不推荐使用。</p>
</blockquote>
<h3 id="52-headers实战">5.2 Headers实战</h3>
<h4 id="1-配置类-4">1、配置类</h4>
<pre><code class="language-java">@Configuration
public class RabbitConfig {
    @Bean
    public HeadersExchange headersExchange() {
        return ExchangeBuilder.headersExchange(&quot;exchange.headers&quot;).build();
    }

    @Bean
    public Queue queueA() {
        return QueueBuilder.durable(&quot;queue.a&quot;).build();
    }
    @Bean
    public Queue queueB() {
        return QueueBuilder.durable(&quot;queue.b&quot;).build();
    }

    @Bean // 绑定时指定需要匹配的消息头属性，而不是设置routingKey
    public Binding bindingA(HeadersExchange headersExchange, Queue queueA) {
        Map&lt;String, Object&gt; headerValues = new HashMap&lt;&gt;();
        headerValues.put(&quot;type&quot;, &quot;m&quot;);
        headerValues.put(&quot;status&quot;, 1);
        return BindingBuilder.bind(queueA).to(headersExchange)
                .whereAll(headerValues).match();
    }
    @Bean // 绑定时指定需要匹配的消息头属性，而不是设置routingKey
    public Binding bindingB(HeadersExchange headersExchange, Queue queueB) {
        Map&lt;String, Object&gt; headerValues = new HashMap&lt;&gt;();
        headerValues.put(&quot;type&quot;, &quot;s&quot;);
        headerValues.put(&quot;status&quot;, 0);
        return BindingBuilder.bind(queueB).to(headersExchange)
                .whereAll(headerValues).match();
    }
}
</code></pre>
<h4 id="2-消息生产者-4">2、消息生产者</h4>
<pre><code class="language-java">@RestController
public class MessageProducer {
    @Autowired
    private RabbitTemplate template;

    @GetMapping(&quot;/test1&quot;)
    public void test1() {
        // 定义消息属性
        MessageProperties messageProperties = new MessageProperties();
        Map&lt;String, Object&gt; headers = new HashMap&lt;&gt;();
        headers.put(&quot;type&quot;, &quot;m&quot;);
        headers.put(&quot;status&quot;, 1);
        // 设置消息头
        messageProperties.setHeaders(headers);
        // 添加消息属性
        Message msg = MessageBuilder.withBody(&quot;test1 haha666&quot;.getBytes())
                .andProperties(messageProperties).build();
        // 发送消息（头部交换机无需路由键）
        template.convertAndSend(&quot;exchange.headers&quot;, &quot;&quot;, msg);
    }
    @GetMapping(&quot;/test2&quot;)
    public void test2() {
        // 定义消息属性
        MessageProperties messageProperties = new MessageProperties();
        Map&lt;String, Object&gt; headers = new HashMap&lt;&gt;();
        headers.put(&quot;type&quot;, &quot;s&quot;);
        headers.put(&quot;status&quot;, 0);
        // 设置消息头
        messageProperties.setHeaders(headers);
        // 添加消息属性
        Message msg = MessageBuilder.withBody(&quot;test2 haha888&quot;.getBytes())
                .andProperties(messageProperties).build();
        // 发送消息（头部交换机无需路由键）
        template.convertAndSend(&quot;exchange.headers&quot;, &quot;&quot;, msg);
    }
}
</code></pre>
<h4 id="3-消息消费者-4">3、消息消费者</h4>
<pre><code class="language-java">@Component
public class MessageConsumer {
    @RabbitListener(queues = &quot;queue.a&quot;)
    public void receiveA(Message msg) {
        byte[] body = msg.getBody();
        String str = new String(body);
        System.out.println(&quot;收到A中的消息：&quot; + str);
    }

    @RabbitListener(queues = &quot;queue.b&quot;)
    public void receiveB(Message msg) {
        byte[] body = msg.getBody();
        String str = new String(body);
        System.out.println(&quot;收到B中的消息：&quot; + str);
    }
}
</code></pre>
<h1 id="第04章_消息的可靠性投递">第04章_消息的可靠性投递</h1>
<h2 id="1-简介">1. 简介</h2>
<p>消息的可靠性投递，指的就是要保证消息投递过程中每一个环节都要成功。所以要保证可靠性，必然会牺牲一点性能。保证消息的完全可靠投递，有以下四个环节：</p>
<ol>
<li>保证消息从生产者正确投递到交换机。一般使用消息的Confirm模式来保证该环节的可靠性。</li>
<li>保证消息从交换机正确路由到队列。一般使用消息的Returns模式，或者使用备用交换机，来保证该环节的可靠性。</li>
<li>保证消息的持久存储。一般让交换机、队列、消息都进行持久化，就能保证该环节的可靠性。</li>
<li>保证消息从队列中正确被消费者消费。一般使用消息的手动确认，就能保证该环节的可靠性。</li>
</ol>
<h2 id="2-环节一confirm模式">2. 环节一：Confirm模式</h2>
<h3 id="21-简介">2.1 简介</h3>
<p>在环节一中，我们要保证消息从生产者成功投递到交换机。所以可以使用消息的Confirm模式，<strong>当消息成功或失败投递到交换机，都会给生产者一个响应，告知其投递结果</strong>。其底层实现，实际上是在生产者和交换机中设有一个缓存，每次消息都先发送到缓存中，然后再由缓存发送给交换机，并通知生产者投递到交换机的成功与否。</p>
<p>使用消息的Confirm模式，首先<strong>需要在配置文件中添加</strong>：</p>
<pre><code class="language-properties">spring.rabbitmq.publisher-confirm-type=correlated
</code></pre>
<ul>
<li><code>none</code>表示禁用Confirm模式，是默认值</li>
<li><code>correlated</code>表示开启Confirm模式</li>
</ul>
<p>其次，需要写一个类来实现<code>RabbitTemplate.ConfirmCallback</code>接口，重写其<code>confirm()</code>方法，该方法就是当消息成功/失败投递到交换机时生产者的回调方法。</p>
<h3 id="22-配置类">2.2 配置类</h3>
<pre><code class="language-java">@Configuration
public class RabbitConfig {
    public static final String EXCHANGE_NAME = &quot;confirm.exchange&quot;; // 交换机
    public static final String QUEUE_NAME = &quot;confirm.queue&quot;; // 队列
    public static final String ROUTING_KEY = &quot;key1&quot;; // 路由key

    @Bean // 声明交换机
    public DirectExchange confirmExchange() {
        return ExchangeBuilder.directExchange(EXCHANGE_NAME).build();
    }

    @Bean // 声明队列
    public Queue confirmQueue() {
        return QueueBuilder.durable(QUEUE_NAME).build();
    }

    @Bean // 绑定
    public Binding binding(Queue confirmQueue, DirectExchange confirmExchange) {
        return BindingBuilder.bind(confirmQueue).to(confirmExchange)
                .with(ROUTING_KEY);
    }
}
</code></pre>
<h3 id="23-生产者的回调接口核心">2.3 生产者的回调接口(核心)</h3>
<p>RabbitTemplate类中有一个内部的ConfirmCallback接口，为我们提供了confirm回调方法，当交换机成功或失败收到消息时，都会触发其回调方法：</p>
<pre><code class="language-java">@Slf4j
@Component
public class MyCallBack implements RabbitTemplate.ConfirmCallback {
    @Autowired
    private RabbitTemplate rabbitTemplate;

    @PostConstruct // 该注解标注的方法会在构造器执行之后执行
    public void init() {
        // 由于该类实现的是RabbitTemplate类内部的接口，所以需要将该类注入进去
        rabbitTemplate.setConfirmCallback(this);
    }

    /**
     * 当交换机成功或失败收到消息，都会触发该回调方法
     * @param correlationData 保存消息的id及相关信息
     * @param b 交换机成功收到消息，则为true，否则为false
     * @param s 交换机未收到消息的原因(若成功收到消息，则为null)
     */
    @Override
    public void confirm(CorrelationData correlationData, boolean b, String s) {
        String id = correlationData != null ? correlationData.getId() : &quot;&quot;;
        if (b) {
            log.info(&quot;交换机成功收到id={}的消息&quot;, id);
        } else {
            log.info(&quot;交换机未能收到id={}的消息，错误原因:{}&quot;, id, s);
        }
    }
}
</code></pre>
<h3 id="24-生产者">2.4 生产者</h3>
<p>在生产者中，我们模拟三种情况：成功发送消息、交换机名称错误、队列路由key错误。</p>
<pre><code class="language-java">@Slf4j
@RestController
public class SendMsgController {
    @Autowired
    private RabbitTemplate rabbitTemplate;

    // 成功发送消息
    @GetMapping(&quot;/sendMessage1/{message}&quot;)
    public void sendMessage1(@PathVariable(&quot;message&quot;) String message) {
        // 保存消息的相关数据，有参构构造器可以传入自定义的消息id
        CorrelationData correlationData = new CorrelationData(&quot;1&quot;);
        rabbitTemplate.convertAndSend(RabbitConfig.EXCHANGE_NAME,
                RabbitConfig.ROUTING_KEY, message, correlationData);
        log.info(&quot;发送消息：{}&quot;, message);
    }

    // 失败发送消息(交换机名称错误)
    @GetMapping(&quot;/sendMessage2/{message}&quot;)
    public void sendMessage2(@PathVariable(&quot;message&quot;) String message) {
        CorrelationData correlationData = new CorrelationData(&quot;2&quot;);
        rabbitTemplate.convertAndSend(&quot;error&quot;,
                RabbitConfig.ROUTING_KEY, message, correlationData);
        log.info(&quot;发送消息：{}&quot;, message);
    }

    // 失败发送消息(队列路由key错误)
    @GetMapping(&quot;/sendMessage3/{message}&quot;)
    public void sendMessage3(@PathVariable(&quot;message&quot;) String message) {
        CorrelationData correlationData = new CorrelationData(&quot;3&quot;);
        rabbitTemplate.convertAndSend(RabbitConfig.EXCHANGE_NAME,
                &quot;error&quot;, message, correlationData);
        log.info(&quot;发送消息：{}&quot;, message);
    }
}
</code></pre>
<h3 id="25-消费者">2.5 消费者</h3>
<pre><code class="language-java">@Slf4j
@Component
public class Consumer {
    @RabbitListener(queues = RabbitConfig.QUEUE_NAME)
    public void receiveMessage(Message message) {
        String msg = new String(message.getBody());
        log.info(&quot;接收消息：{}&quot;, msg);
    }
}
</code></pre>
<h3 id="26-测试">2.6 测试</h3>
<p>（1）访问<code>http://localhost:8080/sendMessage1/wsy111</code>，控制台打印如下：</p>
<pre><code>... 发送消息：wsy111
... 交换机成功收到id=1的消息
... 接收消息：wsy111
</code></pre>
<p>交换机成功收到消息，触发回调，符合预期！</p>
<p>（2）访问<code>http://localhost:8080/sendMessage2/wsy222</code>，控制台打印如下：</p>
<pre><code>... 发送消息：wsy222
... Shutdown Signal: channel error; protocol method: #method&lt;channel.close&gt;(reply-code=404, reply-text=NOT_FOUND - no exchange 'error' in vhost '/', class-id=60, method-id=40)
... 交换机未能收到id=2的消息，错误原因:channel error; protocol method: #method&lt;channel.close&gt;(reply-code=404, reply-text=NOT_FOUND - no exchange 'error' in vhost '/', class-id=60, method-id=40)
</code></pre>
<p>交换机未能收到消息，触发回调，符合预期！</p>
<p>（3）访问<code>http://localhost:8080/sendMessage3/wsy333</code>，控制台打印如下：</p>
<pre><code>... 发送消息：wsy333
... 交换机成功收到id=3的消息
</code></pre>
<p>交换机成功收到消息，触发回调，同样符合预期。但是，由于routingKey错误，导致没有队列能接收这个消息，所以这条消息直接被丢弃了，但事实上这种消息传送失败的情况也应该回馈给生产者。所以我们需要在环节二也保证可靠性。</p>
<h2 id="3-环节二returns模式">3. 环节二：Returns模式</h2>
<h3 id="31-简介">3.1 简介</h3>
<p>在环节二中，我们需要保证消息从交换机成功路由到队列。为了保证该环节的可靠性，一种方式是采用消息的Returns模式，即<strong>当消息无法路由到队列时会触发生产者的回调</strong>。</p>
<p>使用消息的Returns模式，<strong>首先需要在配置文件中添加</strong>：</p>
<pre><code class="language-properties">spring.rabbitmq.publisher-returns=true
</code></pre>
<p>其次，需要写一个类来实现<code>RabbitTemplate.ReturnsCallback</code>接口，重写其<code>returnedMessage()</code>方法，该方法就是当消息无法路由到队列时生产者的回调方法。</p>
<blockquote>
<p>注意：Confirm模式中，消息无论成功或失败投递到Exchange，都会触发回调；而Returns模式中，只有消息无法路由到队列时，才会触发回调（成功路由到队列则不会触发回调）。</p>
</blockquote>
<h3 id="32-生产者的回调接口核心">3.2 生产者的回调接口(核心)</h3>
<p>配置类、生产者、消费者的代码和环节一中的代码一样。我们只需修改生产者的回调接口，额外实现RabbitTemplate内部的ReturnsCallback接口即可：</p>
<pre><code class="language-java">@Slf4j
@Component
public class MyCallBack implements RabbitTemplate.ConfirmCallback, RabbitTemplate.ReturnsCallback {
    @Autowired
    private RabbitTemplate rabbitTemplate;

    @PostConstruct // 该注解标注的方法会在构造器执行之后执行
    public void init() {
        // 由于该类实现的是RabbitTemplate类内部的接口，所以需要将该类注入进去
        rabbitTemplate.setConfirmCallback(this);
        rabbitTemplate.setReturnsCallback(this);
    }

    @Override // 交换机成功或失败收到消息的回调方法
    public void confirm(CorrelationData correlationData, boolean b, String s) {
        String id = correlationData != null ? correlationData.getId() : &quot;&quot;;
        if (b) {
            log.info(&quot;交换机成功收到id={}的消息&quot;, id);
        } else {
            log.info(&quot;交换机未能收到id={}的消息，错误原因:{}&quot;, id, s);
        }
    }

    @Override // 当消息无法路由到队列时的回调方法
    public void returnedMessage(ReturnedMessage message) {
        log.error(&quot;消息：{}，被交换机{}退回，退回原因：{}，路由key：{}&quot;,
                new String(message.getMessage().getBody()),
                message.getExchange(),
                message.getReplyText(),
                message.getRoutingKey());
    }
}
</code></pre>
<h3 id="33-测试">3.3 测试</h3>
<p>访问<code>http://localhost:8080/sendMessage3/wsy333</code>，控制台打印如下：</p>
<pre><code>... 发送消息：wsy333
... 消息：wsy333，被交换机confirm.exchange退回，退回原因：NO_ROUTE，路由key：error
... 交换机成功收到id=3的消息
</code></pre>
<p>交换机成功收到消息，触发<code>confirm()</code>回调，同时由于routingKey错误、消息无法路由，触发<code>returnedMessage()</code>回调，符合预期！</p>
<h2 id="4-环节二备用交换机">4. 环节二：备用交换机</h2>
<h3 id="41-简介">4.1 简介</h3>
<p>对于无法路由的消息，固然可以采用Returns模式来交给生产者处理，但这样会增加生产者的复杂性。更好的方案是使用<strong>备用交换机</strong>，即把所有无法路由的消息，都转发给一个备用交换机，由备用交换机来做相应的处理。通常<strong>备用交换机的类型是Fanout</strong>，这样就能把消息投递到所有与其绑定的队列中(这样就解决了routingKey错误导致的无法路由)，通常会建立一个备用队列专门处理这些消息，以及一个警告队列专门进行监测和警告。</p>
<blockquote>
<p>注意：同时使用消息Returns模式和备用交换机时，<strong>备用交换机优先级高</strong>。</p>
</blockquote>
<p>代码架构图如下：</p>
<figure data-type="image" tabindex="2"><img src="images/20231005141801.png" alt="" loading="lazy"></figure>
<blockquote>
<p>为了简便，我们省略交换机处的Confirm模式，只演示无法路由的消息该如何处理。</p>
</blockquote>
<h3 id="42-配置类">4.2 配置类</h3>
<pre><code class="language-java">@Configuration
public class RabbitConfig {
    public static final String CONFIRM_EXCHANGE = &quot;confirm.exchange&quot;; // 确认交换机
    public static final String CONFIRM_QUEUE = &quot;confirm.queue&quot;; // 确认队列
    public static final String ROUTING_KEY = &quot;key1&quot;; // 路由key
    public static final String BACKUP_EXCHANGE = &quot;backup.exchange&quot;; // 备用交换机
    public static final String BACKUP_QUEUE = &quot;backup.queue&quot;; // 备用队列
    public static final String WARNING_QUEUE = &quot;warning.queue&quot;; // 警告队列

    @Bean // 确认交换机
    public DirectExchange confirmExchange() {
        // 无法路由的消息，将转发给备用交换机
        return ExchangeBuilder.directExchange(CONFIRM_EXCHANGE)
                .alternate(BACKUP_EXCHANGE).build();
    }

    @Bean // 确认队列
    public Queue confirmQueue() {
        return QueueBuilder.durable(CONFIRM_QUEUE).build();
    }

    @Bean // 绑定确认交换机和确认队列
    public Binding bindingConfirm(Queue confirmQueue, DirectExchange confirmExchange) {
        return BindingBuilder.bind(confirmQueue).to(confirmExchange)
                .with(ROUTING_KEY);
    }

    @Bean // 备用交换机
    public FanoutExchange backupExchange() {
        return ExchangeBuilder.fanoutExchange(BACKUP_EXCHANGE).build();
    }

    @Bean // 备用队列
    public Queue backupQueue() {
        return QueueBuilder.durable(BACKUP_QUEUE).build();
    }

    @Bean // 警告队列
    public Queue warningQueue() {
        return QueueBuilder.durable(WARNING_QUEUE).build();
    }

    @Bean // 绑定备用队列和备用交换机
    public Binding bindingBackup(Queue backupQueue, FanoutExchange backupExchange) {
        return BindingBuilder.bind(backupQueue).to(backupExchange);
    }

    @Bean // 绑定警告队列和备用交换机
    public Binding bindingWarning(Queue warningQueue, FanoutExchange backupExchange) {
        return BindingBuilder.bind(warningQueue).to(backupExchange);
    }
}
</code></pre>
<h3 id="43-消费者">4.3 消费者</h3>
<p>ConfirmConsumer：</p>
<pre><code class="language-java">@Slf4j
@Component
public class ConfirmConsumer {
    @RabbitListener(queues = RabbitConfig.CONFIRM_QUEUE)
    public void receiveConfirmMessage(Message message) {
        String msg = new String(message.getBody());
        log.info(&quot;接收confirm消息：{}&quot;, msg);
    }
}
</code></pre>
<p>WarningConsumer：</p>
<pre><code class="language-java">@Slf4j
@Component
public class WarningConsumer {
    @RabbitListener(queues = RabbitConfig.WARNING_QUEUE)
    public void receiveWarningMessage(Message message) {
        String msg = new String(message.getBody());
        log.warn(&quot;发现不可路由的消息：{}&quot;, msg);
    }
}
</code></pre>
<h3 id="44-生产者">4.4 生产者</h3>
<pre><code class="language-java">@Slf4j
@RestController
public class SendMsgController {
    @Autowired
    private RabbitTemplate rabbitTemplate;

    // 正确路由的消息
    @GetMapping(&quot;/sendConfirm/{message}&quot;)
    public void sendConfirm(@PathVariable(&quot;message&quot;) String message) {
        rabbitTemplate.convertAndSend(RabbitConfig.CONFIRM_EXCHANGE,
                RabbitConfig.ROUTING_KEY, message);
        log.info(&quot;发送消息：{}&quot;, message);
    }

    // 错误路由的消息
    @GetMapping(&quot;/sendWarning/{message}&quot;)
    public void sendWarning(@PathVariable(&quot;message&quot;) String message) {
        rabbitTemplate.convertAndSend(RabbitConfig.CONFIRM_EXCHANGE,
                &quot;error&quot;, message);
        log.info(&quot;发送消息：{}&quot;, message);
    }
}
</code></pre>
<h3 id="45-测试">4.5 测试</h3>
<p>（1）访问<code>http://localhost:8080/sendConfirm/wsy111</code>，控制台打印如下</p>
<pre><code>... 发送消息：wsy111
... 接收confirm消息：wsy111
</code></pre>
<p>（2）访问<code>http://localhost:8080/sendWarning/wsy222</code>，控制台打印如下</p>
<pre><code>... 发送消息：wsy222
... 发现不可路由的消息：wsy222
</code></pre>
<h2 id="5-环节三持久化">5. 环节三：持久化</h2>
<p>要保证消息的持久存储，一般让交换机、队列、消息都进行持久化，就能保证该环节的可靠性。</p>
<ul>
<li>交换机的持久化：使用ExchangeBuilder创建出的交换机，默认都是持久化的。</li>
<li>队列的持久化：使用QueueBuilder的<code>durable(String name)</code>方法创建出的队列是持久化的。</li>
<li>消息的持久化：使用RabbitTemplate的<code>convertAndSend()</code>方法发送消息时，消息默认就是持久化的。因为该方法会将消息转换为一个Message对象，为其设置MessageProperties，注意到MessageProperties类中有一个属性deliveryMode进行了显式默认赋值，这个默认值就表示该消息是持久化的。</li>
</ul>
<h2 id="6-环节四消息手动确认">6. 环节四：消息手动确认</h2>
<h3 id="61-简介">6.1 简介</h3>
<p>RabbitMQ使用了<strong>消息确认机制</strong>，即消费者在接收到消息后，会给MQ发送确认消息，而MQ一旦收到确认就会把该消息从队列中删除。</p>
<p>RabbitMQ默认采用<strong>消息自动确认</strong>，即消费者收到消息后，就会自动给MQ发送确认消息。</p>
<p>但我们建议开启<strong>消息手动确认</strong>，即当消费者处理完毕消息后，在合适的时机手动返回ACK通知MQ删除消息，这样就能<strong>保证消息从队列中正确被消费者消费后才会删除</strong>。使用消息手动确认模式，需要在配置文件中配置：</p>
<pre><code class="language-properties">spring.rabbitmq.listener.simple.acknowledge-mode=manual
</code></pre>
<h3 id="62-消息手动确认的api">6.2 消息手动确认的API</h3>
<p>使用com.rabbitmq.client.Channel接口的以下API可以进行手动的消息确认：</p>
<ul>
<li><code>void basicAck(long deliveryTag, boolean multiple)</code>：肯定确认，第一个参数是消息的投递序号，第二个参数表示是否使用累计确认机制</li>
<li><code>void basicNack(long deliveryTag, boolean multiple, boolean requeue)</code>：否定确认，第三个参数表示消息是否重新入队</li>
<li><code>void basicReject(long deliveryTag, boolean requeue)</code>：否定确认，与<code>basicNack()</code>的唯一区别是它无法累积确认</li>
</ul>
<h3 id="63-累积确认机制">6.3 累积确认机制</h3>
<p>对于参数multiple：</p>
<ul>
<li>设置为true，表示使用累积确认机制，即批量确认当前投递序号及之前的所有消息。这种方式效率更高，但可能会丢失之前的消息。</li>
<li>设置为false，表示不使用累积确认机制，即只确认当前投递序号的消息。这种方式更加安全，不容易丢失消息，<strong>推荐使用这种方式</strong>。</li>
</ul>
<h3 id="64-消息的重新入队机制">6.4 消息的重新入队机制</h3>
<p>对于参数requeue：</p>
<ul>
<li>设置为true，表示当收到消息的否定确认时，会将该消息重新加入队列的队尾</li>
<li>设置为false，表示当收到消息的否定确认时，该消息就直接变为死信</li>
</ul>
<blockquote>
<p>注意：在RabbitMQ默认的消息自动确认模式中，被拒绝的消息就采用自动重新入队的机制。</p>
</blockquote>
<h3 id="65-代码示例">6.5 代码示例</h3>
<pre><code class="language-java">@Component
@Slf4j
public class RabbitConsumer {
    @RabbitListener(queues = &quot;normal.queue&quot;)
    public void receive(Message msg, Channel channel) throws IOException {
        // 1. 获取消息的投递序号（消息的唯一标识）
        long deliveryTag = msg.getMessageProperties().getDeliveryTag();
        try {
            // 2. 核心业务操作
            log.info(&quot;消息内容：{}&quot;, new String(msg.getBody()));
            // 3. 核心业务操作成功，返回ACK
            channel.basicAck(deliveryTag, false);
        } catch (Exception e) {
            // 4. 核心业务操作异常，返回NACK
            channel.basicNack(deliveryTag, false, true);
        }
    }
}
</code></pre>
<h1 id="第05章_死信队列">第05章_死信队列</h1>
<h2 id="1-死信的概念">1. 死信的概念</h2>
<p>死信，指的就是无法被消费的消息。当producer将消息投递到broker中，consumer可能由于特定的原因<strong>导致某些消息无法被消费</strong>，这样的消息就称为死信，我们需要将死信放入<strong>死信队列</strong>中进行统一处理。</p>
<p><strong>应用场景</strong>：例如为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。</p>
<p><strong>产生死信的情况</strong>：</p>
<ul>
<li>消息TTL过期(TTL即Time To Live，生存时间)</li>
<li>队列达到最大长度（即队列已满）</li>
<li>消息被拒绝(否定确认)，即<code>channel.basicReject()</code>或<code>channel.basicNack()</code>，并且没有重新入队(<code>requeue=false</code>)</li>
</ul>
<h2 id="2-消息ttl过期-案例演示">2. 消息TTL过期-案例演示</h2>
<p>案例架构图如下：</p>
<figure data-type="image" tabindex="3"><img src="images/20231002210502.png" alt="" loading="lazy"></figure>
<h4 id="1-配置类-5">1、配置类</h4>
<pre><code class="language-java">@Configuration
public class RabbitConfig {
    @Bean // 普通交换机
    public DirectExchange normalExchange() {
        return ExchangeBuilder.directExchange(&quot;normal.exchange&quot;).build();
    }
    @Bean // 普通队列
    public Queue normalQueue() {
        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();
        // 1. 设置对应的死信交换机
        arguments.put(&quot;x-dead-letter-exchange&quot;, &quot;dead.exchange&quot;);
        // 2. 设置死信的routingKey
        arguments.put(&quot;x-dead-letter-routing-key&quot;, &quot;lisi&quot;);
        return QueueBuilder.durable(&quot;normal.queue&quot;)
                .withArguments(arguments).build();
    }
    @Bean // 绑定普通交换机和普通队列
    public Binding normalBinding(DirectExchange normalExchange, Queue normalQueue) {
        return BindingBuilder.bind(normalQueue).to(normalExchange).with(&quot;zhangsan&quot;);
    }

    @Bean // 死信交换机
    public DirectExchange deadExchange() {
        return ExchangeBuilder.directExchange(&quot;dead.exchange&quot;).build();
    }
    @Bean // 死信队列
    public Queue deadQueue() {
        return QueueBuilder.durable(&quot;dead.queue&quot;).build();
    }
    @Bean // 绑定死信交换机和死信队列
    public Binding deadBinding(DirectExchange deadExchange, Queue deadQueue) {
        return BindingBuilder.bind(deadQueue).to(deadExchange).with(&quot;lisi&quot;);
    }
}
</code></pre>
<h4 id="2-生产者">2、生产者</h4>
<pre><code class="language-java">@RestController
public class Producer {
    @Autowired
    private RabbitTemplate template;

    @GetMapping(&quot;/send&quot;)
    public void send() {
        MessageProperties messageProperties = new MessageProperties();
        messageProperties.setExpiration(&quot;15000&quot;); // 设置TTL，单位ms
        Message msg = MessageBuilder.withBody(&quot;hello&quot;.getBytes())
                .andProperties(messageProperties).build();
        template.convertAndSend(&quot;normal.exchange&quot;, &quot;zhangsan&quot;, msg);
    }
}
</code></pre>
<h4 id="3-消费者c2">3、消费者C2</h4>
<p>由于没有消费者C1来消费普通队列，所以普通队列中的消息最终会变为死信，最终被消费者C2消费</p>
<pre><code class="language-java">@Component
public class Consumer2 {
    @RabbitListener(queues = &quot;dead.queue&quot;)
    public void receive(Message msg) {
        System.out.println(&quot;收到死信消息：&quot; + new String(msg.getBody()));
    }
}
</code></pre>
<h2 id="3-队列达到最大长度-案例演示">3. 队列达到最大长度-案例演示</h2>
<h4 id="1-配置类-6">1、配置类</h4>
<p>基本与上一个案例相同，只需在设置普通队列时多添加一个参数来限制最大长度：</p>
<pre><code class="language-java">arguments.put(&quot;x-max-length&quot;, 6); // 设置普通队列的最大长度为6
</code></pre>
<blockquote>
<p>注意：当队列满时再收到消息，会<strong>将队首的消息弹出、变为死信</strong>，然后新消息再入队。</p>
</blockquote>
<h4 id="2-生产者-2">2、生产者</h4>
<pre><code class="language-java">@RestController
public class Producer {
    @Autowired
    private RabbitTemplate template;

    @GetMapping(&quot;/send&quot;)
    public void send() {
        for (int i = 0; i &lt; 10; i++) {
            String str = &quot;hello&quot; + i;
            Message msg = MessageBuilder.withBody(str.getBytes()).build();
            template.convertAndSend(&quot;normal.exchange&quot;, &quot;zhangsan&quot;, msg);
        }
    }
}
</code></pre>
<h4 id="3-消费者c2-2">3、消费者C2</h4>
<p>与上一个案例相同。注意，在测试时，要先进入Web管理界面将上一个案例创建的交换机、队列删除。</p>
<h2 id="4-消息被拒-案例演示">4. 消息被拒-案例演示</h2>
<h4 id="1-配置类-7">1、配置类</h4>
<p>基本与上一个案例相同，只需删除普通队列的最大长度设置。</p>
<h4 id="2-生产者-3">2、生产者</h4>
<p>与上一个案例相同</p>
<h4 id="3-消费者c2-3">3、消费者C2</h4>
<p>与上一个案例相同</p>
<h4 id="4-消费者c1">4、消费者C1</h4>
<p>首先需要在配置文件中添加如下配置，开启消息手动确认模式：</p>
<pre><code class="language-properties">spring.rabbitmq.listener.simple.acknowledge-mode=manual
</code></pre>
<pre><code class="language-java">@Component
public class Consumer1 {
    @RabbitListener(queues = &quot;normal.queue&quot;)
    public void receive(Message msg, Channel channel) throws IOException {
        String str = new String(msg.getBody());
        // 获取消息的投递序号
        long deliveryTag = msg.getMessageProperties().getDeliveryTag();
        // 拒收内容为hello4的消息
        if (&quot;hello4&quot;.equals(str)) {
            // 第2个参数表示是否重新入队
            channel.basicReject(deliveryTag, false);
        } else {
            System.out.println(&quot;收到普通消息：&quot; + str);
            // 第2个参数表示是否累积确认
            channel.basicAck(deliveryTag, false);
        }
    }
}
</code></pre>
<p>注意，在测试时，要先进入Web管理界面将上一个案例创建的交换机、队列删除。</p>
<h1 id="第06章_延迟队列">第06章_延迟队列</h1>
<h2 id="1-延迟队列简介">1. 延迟队列简介</h2>
<h3 id="11-延迟队列概念">1.1 延迟队列概念</h3>
<p>延迟队列用于存放需要在指定时间被处理的消息（延迟消息）。例如，让订单在十分钟之内未支付则自动取消，就可以使用延迟队列来实现。</p>
<p>AMQP协议以及RabbitMQ本身没有直接支持延迟队列的功能，但是我们可以通过基于TTL的死信机制来实现延迟队列。也就是给消息设置TTL、或给队列设置TTL，这样该队列就是一个延迟队列，当队列中的消息达到超时时间后，就变成死信，转发给死信交换机处理。</p>
<h3 id="12-ttl">1.2 TTL</h3>
<p>TTL是一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的<strong>最大存活时间</strong>，单位是<strong>毫秒</strong>。</p>
<p>如果一条消息设置了 TTL 属性或者进入了设置 TTL 属性的队列，那么这条消息如果在 TTL 设置的时间内没有被消费，则会成为死信。如果同时配置了队列的TTL和消息的TTL，那么<strong>较小的那个值将会被使用</strong>。</p>
<p><strong>队列设置TTL的方式</strong>：</p>
<pre><code class="language-java">@Bean 
public Queue normalQueue() {
    // 用于设置队列的相关参数
    Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();
    // 设置TTL，单位ms
    arguments.put(&quot;x-message-ttl&quot;, 15000);
    return QueueBuilder.durable(&quot;队列名称&quot;).withArguments(arguments).build();
}
</code></pre>
<p><strong>消息设置TTL的方式</strong>：</p>
<pre><code class="language-java">MessageProperties messageProperties = new MessageProperties();
messageProperties.setExpiration(&quot;15000&quot;); // 设置TTL，单位ms
Message msg = MessageBuilder.withBody(&quot;hello&quot;.getBytes())
        .andProperties(messageProperties).build();
</code></pre>
<blockquote>
<p>注意：如果不设置TTL，则表示消息永远不会过期。如果将TTL设置为0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会过期。</p>
</blockquote>
<h2 id="2-基于死信实现延迟队列">2. 基于死信实现延迟队列</h2>
<h3 id="21-代码架构图">2.1 代码架构图</h3>
<figure data-type="image" tabindex="4"><img src="images/20231004172834.png" alt="" loading="lazy"></figure>
<p>如上，三个普通队列QA、QB、QC，其中QA和QB的TTL分别设置为10秒和40秒，而QC不设置TTL、用于存放自定义TTL的消息。当消息变为死信后，转发到死信队列QD进行统一处理。</p>
<h3 id="22-配置类-2">2.2 配置类</h3>
<pre><code class="language-java">@Configuration
public class RabbitConfig {
    public static final String NORMAL_EXCHANGE = &quot;X&quot;; // 普通交换机
    public static final String DEAD_EXCHANGE = &quot;Y&quot;; // 死信交换机
    public static final String NORMAL_QUEUE_A = &quot;QA&quot;; // 普通队列A
    public static final String NORMAL_QUEUE_B = &quot;QB&quot;; // 普通队列B
    public static final String NORMAL_QUEUE_C = &quot;QC&quot;; // 普通队列C
    public static final String DEAD_QUEUE_D = &quot;QD&quot;; // 死信队列D

    @Bean // 声明普通交换机
    public DirectExchange normalExchange() {
        return ExchangeBuilder.directExchange(NORMAL_EXCHANGE).build();
    }

    @Bean // 声明死信交换机
    public DirectExchange deadExchange() {
        return ExchangeBuilder.directExchange(DEAD_EXCHANGE).build();
    }

    @Bean // 声明普通队列A
    public Queue normalQueueA() {
        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();
        // 1. 设置对应的死信交换机
        arguments.put(&quot;x-dead-letter-exchange&quot;, DEAD_EXCHANGE);
        // 2. 设置死信的routingKey
        arguments.put(&quot;x-dead-letter-routing-key&quot;, &quot;YD&quot;);
        // 3. 设置TTL
        arguments.put(&quot;x-message-ttl&quot;, 10 * 1000);
        return QueueBuilder.durable(NORMAL_QUEUE_A).withArguments(arguments).build();
    }

    @Bean // 声明普通队列B
    public Queue normalQueueB() {
        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();
        arguments.put(&quot;x-dead-letter-exchange&quot;, DEAD_EXCHANGE);
        arguments.put(&quot;x-dead-letter-routing-key&quot;, &quot;YD&quot;);
        arguments.put(&quot;x-message-ttl&quot;, 40 * 1000);
        return QueueBuilder.durable(NORMAL_QUEUE_B).withArguments(arguments).build();
    }

    @Bean // 声明普通队列C
    public Queue normalQueueC() {
        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();
        arguments.put(&quot;x-dead-letter-exchange&quot;, DEAD_EXCHANGE);
        arguments.put(&quot;x-dead-letter-routing-key&quot;, &quot;YD&quot;);
        return QueueBuilder.durable(NORMAL_QUEUE_C).withArguments(arguments).build();
    }

    @Bean // 声明死信队列D
    public Queue deadQueueD() {
        return QueueBuilder.durable(DEAD_QUEUE_D).build();
    }

    @Bean // 绑定X和QA
    public Binding bindingXA(Queue normalQueueA, DirectExchange normalExchange) {
        return BindingBuilder.bind(normalQueueA).to(normalExchange)
                .with(&quot;XA&quot;);
    }

    @Bean // 绑定X和QB
    public Binding bindingXB(Queue normalQueueB, DirectExchange normalExchange) {
        return BindingBuilder.bind(normalQueueB).to(normalExchange)
                .with(&quot;XB&quot;);
    }

    @Bean // 绑定X和QC
    public Binding bindingXC(Queue normalQueueC, DirectExchange normalExchange) {
        return BindingBuilder.bind(normalQueueC).to(normalExchange)
                .with(&quot;XC&quot;);
    }

    @Bean // 绑定Y和QD
    public Binding bindingYD(Queue deadQueueD, DirectExchange deadExchange) {
        return BindingBuilder.bind(deadQueueD).to(deadExchange)
                .with(&quot;YD&quot;);
    }
}
</code></pre>
<h3 id="23-生产者">2.3 生产者</h3>
<pre><code class="language-java">@Slf4j
@RestController
@RequestMapping(&quot;/ttl&quot;)
public class SendMsgController {
    @Autowired
    private RabbitTemplate rabbitTemplate;

    // 不带TTL的消息，发送到设置了TTL的队列中
    @GetMapping(&quot;/sendMsg/{message}&quot;)
    public void sendMsg(@PathVariable(&quot;message&quot;) String message) {
        log.info(&quot;当前时间：{}, 发送消息：{}&quot;, new Date(), message);
        // 发消息
        rabbitTemplate.convertAndSend(&quot;X&quot;, &quot;XA&quot;,
                &quot;TTL:10s, Message:&quot; + message);
        rabbitTemplate.convertAndSend(&quot;X&quot;, &quot;XB&quot;,
                &quot;TTL:40s, Message:&quot; + message);
    }

    // 带有TTL的消息，发送到QC队列中
    @GetMapping(&quot;/sendMsgTTL/{message}/{ttl}&quot;)
    public void sendMsgTTL(@PathVariable(&quot;message&quot;) String message,
                           @PathVariable(&quot;ttl&quot;) String ttl) {
        log.info(&quot;当前时间：{}, 发送消息：{}, TTL：{}ms&quot;, new Date(), message, ttl);
        
        String str = &quot;TTL:&quot; + ttl + &quot;ms, Message:&quot; + message;
        MessageProperties properties = new MessageProperties();
        properties.setExpiration(ttl); // 设置消息的TTL
        Message msg = MessageBuilder.withBody(str.getBytes())
                .andProperties(properties).build();

        rabbitTemplate.convertAndSend(&quot;X&quot;, &quot;XC&quot;, msg);
    }
}
</code></pre>
<h3 id="24-消费者">2.4 消费者</h3>
<pre><code class="language-java">@Slf4j
@Component
public class Consumer {
    @RabbitListener(queues = &quot;QD&quot;)
    public void receiveQD(Message message) {
        String msg = new String(message.getBody());
        log.info(&quot;当前时间：{}, 收到消息：{}&quot;, new Date(), msg);
    }
}
</code></pre>
<h3 id="25-测试">2.5 测试</h3>
<p><strong>（1）测试QA和QB</strong></p>
<p><code>http://localhost:8080/ttl/sendMsg/wsy666</code>发送消息，控制台打印如下</p>
<pre><code>... 当前时间：Wed Oct 04 17:41:16 CST 2023, 发送消息：wsy666
... 当前时间：Wed Oct 04 17:41:27 CST 2023, 收到消息：TTL:10s, Message:wsy666
... 当前时间：Wed Oct 04 17:41:57 CST 2023, 收到消息：TTL:40s, Message:wsy666
</code></pre>
<p>结果符合预期！第一条消息在 10s 后变成了死信，然后被消费掉，第二条消息在 40s 之后变成了死信，然后被消费掉。</p>
<p><strong>（2）测试QC</strong></p>
<p><code>http://localhost:8080/ttl/sendMsgTTL/wsy777/20000</code></p>
<p><code>http://localhost:8080/ttl/sendMsgTTL/wsy888/2000</code></p>
<p>发送两条消息，控制台打印如下</p>
<pre><code>... 当前时间：Wed Oct 04 17:47:18 CST 2023, 发送消息：wsy777, TTL：20000ms
... 当前时间：Wed Oct 04 17:47:26 CST 2023, 发送消息：wsy888, TTL：2000ms
... 当前时间：Wed Oct 04 17:47:38 CST 2023, 收到消息：TTL:20000ms, Message:wsy777
... 当前时间：Wed Oct 04 17:47:38 CST 2023, 收到消息：TTL:2000ms, Message:wsy888
</code></pre>
<p>我们注意到，第二条消息TTL为2秒，却没有按时变成死信。这是<strong>因为RabbitMQ只会检查队首消息是否过期</strong>，如果过期则变为死信丢弃，然后检查新的队首消息。因此，如果第一个消息的TTL很长，而第二个消息的TTL很短，如上所示，第二个消息并不会优先被丢弃，而是等到第一个消息被丢弃后，才会立即丢弃。</p>
<p>这就是基于死信实现的延迟队列的缺点（当然，如果是基于队列的TTL，而不是基于消息的TTL，就不会有这一问题），以下我们也可以使用延迟队列插件来解决这一问题！</p>
<h2 id="3-基于插件实现延迟队列">3. 基于插件实现延迟队列</h2>
<h3 id="31-rabbitmq延迟队列插件的安装">3.1 RabbitMQ延迟队列插件的安装</h3>
<p>基于死信实现的延迟队列，本质上就是在一个队列中根据其中消息的TTL，来实现延迟。而基于插件实现的延迟队列，直接在交换机处就实现延迟，然后再发送给队列，让消费者进行消费即可，流程上简单得多。</p>
<p>我们用Docker方式安装RabbitMQ延迟队列插件：</p>
<p><strong>（1）下载插件</strong></p>
<ul>
<li>登录官网 https://www.rabbitmq.com/community-plugins.html</li>
<li>下载插件rabbitmq_delayed_message_exchange-3.9.0.ez</li>
<li>然后上传到服务器的/opt目录下</li>
</ul>
<p><strong>（2）将插件上传到Docker容器实例内部</strong></p>
<p>首先<code>docker ps</code>查看运行中的rabbitmq实例的容器id，然后执行以下命令将插件拷贝到容器内的/plugins目录下：</p>
<pre><code class="language-shell">docker cp /opt/rabbitmq_delayed_message_exchange-3.9.0.ez 5b9a3d9726ef:/plugins
</code></pre>
<p><strong>（3）启用插件</strong></p>
<p>进入rabbitmq实例容器内部的/plugins目录下，启用插件：</p>
<pre><code class="language-shell">docker exec -it 5b9a3d9726ef /bin/bash
cd /plugins
rabbitmq-plugins enable rabbitmq_delayed_message_exchange
</code></pre>
<p>此时插件已启用，退出容器并重启容器实例即可：</p>
<pre><code class="language-shell">exit
docker restart 5b9a3d9726ef
</code></pre>
<p><strong>（4）Web端管理界面查看</strong></p>
<p>登录RabbitMQ的Web端管理界面，在Exchanges中Add a new exchange，发现Type里多了一个类型x-delayed-message，说明插件启用成功。</p>
<h3 id="32-代码架构图">3.2 代码架构图</h3>
<figure data-type="image" tabindex="5"><img src="images/20231004190410.png" alt="" loading="lazy"></figure>
<h3 id="33-配置类">3.3 配置类</h3>
<p>在我们自定义的交换机中，这是一种新的交换机类型，它支持延迟投递机制：消息不会立即投递到目标队列中，而是存储在mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中。</p>
<pre><code class="language-java">@Configuration
public class RabbitConfig {
    public static final String DELAYED_EXCHANGE = &quot;delayed.exchange&quot;; // 延迟交换机
    public static final String DELAYED_QUEUE = &quot;delayed.queue&quot;; // 队列
    public static final String DELAYED_ROUTINGKEY = &quot;delayed.routingkey&quot;; // 路由key

    @Bean // 声明延迟交换机
    public CustomExchange delayedExchange() {
        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();
        arguments.put(&quot;x-delayed-type&quot;, &quot;direct&quot;);
        /**
         * 1. 交换机的名称
         * 2. 交换机的类型
         * 3. 该交换机是否需要持久化
         * 4. 该交换机是否需要自动删除
         * 5. 其他参数
         */
        return new CustomExchange(DELAYED_EXCHANGE, &quot;x-delayed-message&quot;,
                true, false, arguments);
    }

    @Bean // 声明队列
    public Queue delayedQueue() {
        return new Queue(DELAYED_QUEUE);
    }

    @Bean // 绑定
    public Binding bindingDelayed(Queue delayedQueue, CustomExchange delayedExchange) {
        return BindingBuilder.bind(delayedQueue).to(delayedExchange)
                .with(DELAYED_ROUTINGKEY).noargs();
    }
}
</code></pre>
<h3 id="34-生产者">3.4 生产者</h3>
<p><strong>注意：要给消息属性中设置延迟时间属性，而不是设置TTL</strong></p>
<pre><code class="language-java">@Slf4j
@RestController
public class SendMsgController {
    @Autowired
    private RabbitTemplate rabbitTemplate;

    // 发送带有延迟时间的消息
    @GetMapping(&quot;/sendDelayMsg/{message}/{delayTime}&quot;)
    public void sendDelayMsg(@PathVariable(&quot;message&quot;) String message,
                             @PathVariable(&quot;delayTime&quot;) Integer delayTime) {
        log.info(&quot;当前时间：{}, 发送消息：{}, 延迟时间：{}ms&quot;, new Date(), message, delayTime);
        
        String str = &quot;延迟时间:&quot; + delayTime + &quot;ms, Message:&quot; + message;
        MessageProperties properties = new MessageProperties();
        properties.setDelay(delayTime); // 设置消息的延迟时间，单位ms
        Message msg = MessageBuilder.withBody(str.getBytes())
                .andProperties(properties).build();
        
        rabbitTemplate.convertAndSend(RabbitConfig.DELAYED_EXCHANGE,
                RabbitConfig.DELAYED_ROUTINGKEY, msg);
    }
}
</code></pre>
<h3 id="35-消费者">3.5 消费者</h3>
<pre><code class="language-java">@Slf4j
@Component
public class Consumer {
    @RabbitListener(queues = RabbitConfig.DELAYED_QUEUE)
    public void receiveDelayMessage(Message message) {
        String msg = new String(message.getBody());
        log.info(&quot;当前时间：{}, 收到消息：{}&quot;, new Date(), msg);
    }
}
</code></pre>
<h3 id="36-测试">3.6 测试</h3>
<p><code>http://localhost:8080/sendDelayMsg/wsy111/20000</code></p>
<p><code>http://localhost:8080/sendDelayMsg/wsy222/2000</code></p>
<p>发送两条消息，控制台打印如下</p>
<pre><code>... 当前时间：Wed Oct 04 19:07:31 CST 2023, 发送消息：wsy111, 延迟时间：20000ms
... 当前时间：Wed Oct 04 19:07:42 CST 2023, 发送消息：wsy222, 延迟时间：2000ms
... 当前时间：Wed Oct 04 19:07:44 CST 2023, 收到消息：延迟时间:2000ms, Message:wsy222
... 当前时间：Wed Oct 04 19:07:51 CST 2023, 收到消息：延迟时间:20000ms, Message:wsy111
</code></pre>
<p>第二个消息被先消费掉了，符合预期！</p>
<h1 id="第07章_其他知识">第07章_其他知识</h1>
<h2 id="1-分发消息">1. 分发消息</h2>
<h3 id="11-轮询分发消息">1.1 轮询分发消息</h3>
<p>默认情况下，RabbitMQ采用<strong>轮询分发消息</strong>，即如果有多个消费者订阅（连接）同一个队列，则该队列中的消息会轮流分发给每个消费者，而并不是广播地分发给每个消费者。</p>
<blockquote>
<p>说明：RabbitMQ支持交换机层面的广播，但不支持队列层面的广播，也就是一个队列中的消息无法广播分发给所有订阅它的消费者。</p>
</blockquote>
<p>测试如下：</p>
<h4 id="1-配置类-8">1、配置类</h4>
<pre><code class="language-java">@Configuration
public class RabbitConfig {
    @Bean
    public DirectExchange exchange() {
        return ExchangeBuilder.directExchange(&quot;exchange.each&quot;).build();
    }
    @Bean
    public Queue queue() {
        return QueueBuilder.durable(&quot;queue.each&quot;).build();
    }
    @Bean
    public Binding binding(Queue queue, DirectExchange exchange) {
        return BindingBuilder.bind(queue).to(exchange).with(&quot;each&quot;);
    }
}
</code></pre>
<h4 id="2-生产者-4">2、生产者</h4>
<pre><code class="language-java">@RestController
public class Producer {
    @Autowired
    private RabbitTemplate template;
    
    @GetMapping(&quot;/send&quot;)
    public void send() {
        for (int i = 0; i &lt; 10; i++) {
            String str = &quot;消息&quot; + i;
            template.convertAndSend(&quot;exchange.each&quot;, &quot;each&quot;, str);
        }
    }
}
</code></pre>
<h4 id="3-消费者">3、消费者</h4>
<pre><code class="language-java">@Component
public class Consumer { // 三个消费者监听同一队列
    @RabbitListener(queues = &quot;queue.each&quot;)
    public void consumer1(Message message) {
        String msg = new String(message.getBody());
        System.out.println(&quot;消费者1收到&quot; + msg);
    }
    @RabbitListener(queues = &quot;queue.each&quot;)
    public void consumer2(Message message) {
        String msg = new String(message.getBody());
        System.out.println(&quot;消费者2收到&quot; + msg);
    }
    @RabbitListener(queues = &quot;queue.each&quot;)
    public void consumer3(Message message) {
        String msg = new String(message.getBody());
        System.out.println(&quot;消费者3收到&quot; + msg);
    }
}
</code></pre>
<h4 id="4-测试">4、测试</h4>
<p>访问<code>http://localhost:8080/send</code>，控制台打印如下</p>
<pre><code>消费者3收到消息0
消费者2收到消息1
消费者1收到消息2
消费者3收到消息3
消费者2收到消息4
消费者1收到消息5
消费者3收到消息6
消费者2收到消息7
消费者1收到消息8
消费者3收到消息9
</code></pre>
<h3 id="12-不公平分发消息">1.2 不公平分发消息</h3>
<p>如果多个消费者处理任务的速度差别很大，采用轮询分发消息的方式并不合适，因为会让消费速度快的消费者大部分时间处于空闲状态。为了解决这一问题，可以采用不公平的方式来分发消息，只需在配置文件中设置<strong>预取值</strong>即可：</p>
<pre><code class="language-properties"># 要设置预取值，必须采用消息手动确认模式
spring.rabbitmq.listener.simple.acknowledge-mode=manual
# 设置预取值
spring.rabbitmq.listener.simple.prefetch=1
</code></pre>
<p>prefetch称为预取值，指的就是该信道上未确认消息的最大数量。如上将预取值设置为1，那么效率慢的消费者收到一个消息后，就会迟迟未确认导致该信道缓冲区已占满；而效率快的消费者，就能被分发更多的消息。</p>
<p>我们可以根据消费者服务器的性能，来设置不同的预取值，例如一个消费者设置为2，另一个消费者设置为5。这就表示前者的信道上的未确认消息缓冲区大小为2，后者大小为5。<strong>采用这种方式，消费者的消费模式就是pull模式，这样就可以实现消费者端限流，达到流量削峰的效果</strong>。</p>
<blockquote>
<p>预取值为1是最保守的，当然这将使吞吐量变得很低，特别是在消费者连接等待时间较长的环境中。对于大多数应用来说，稍微高一点的值将是最佳的。</p>
</blockquote>
<h2 id="2-幂等性">2. 幂等性</h2>
<p><strong>幂等性</strong>指的是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。例如网络卡顿，用户对同一笔订单支付了两次，造成了重复扣款，这就说明这个订单支付模块是不具备幂等性的。</p>
<p>而在MQ中，消费者的业务消费接口通常都需要保证<strong>幂等性</strong>，因为MQ可能会存在消息重复的问题。例如消费者在消费完消息后，却在手动返回ACK时宕机，于是这条消息就没有从队列中删除，这样消费者在重启后就会再次消费这条消息。</p>
<h2 id="3-优先级队列">3. 优先级队列</h2>
<h3 id="31-使用场景">3.1 使用场景</h3>
<p>在订单催付中，我们可以采用 RabbitMQ 的优先级队列，如果发现是大客户的订单催付就给一个相对比较高的优先级，否则就是默认优先级。</p>
<h3 id="32-使用方式">3.2 使用方式</h3>
<p>要让队列实现优先级，首先要<strong>将队列设置为优先级队列</strong>，其次消息也需要<strong>设置消息的优先级</strong>。除此之外，只有批量发送消息积压到队列之后，消费者再去消费才会有优先级的效果；如果不批量发消息，那么发一个消息、消费者就消费一个消息，就体现不出优先级。</p>
<blockquote>
<p>注意：优先级范围0-255，数值越大，优先级越高</p>
</blockquote>
<p><strong>定义优先级队列</strong>：</p>
<pre><code class="language-java">@Bean // 定义优先级队列
public Queue priorityQueue() {
    // 使用maxPriority()方法给队列设置最大优先级，范围是0-255
    return QueueBuilder.durable(&quot;queueName&quot;)
            .maxPriority(10) // 表示队列中允许的消息优先级范围是0-10
            .build();
}
</code></pre>
<p><strong>给消息设置优先级</strong>：</p>
<pre><code class="language-java">MessageProperties properties = new MessageProperties();
properties.setPriority(8); // 设置消息的优先级为8
Message message = MessageBuilder.withBody(&quot;hello&quot;.getBytes())
        .andProperties(properties).build();
</code></pre>
<h3 id="33-案例演示">3.3 案例演示</h3>
<p>需求：批量发送10条消息，让第5条消息被优先消费。</p>
<h4 id="1-配置类-9">1、配置类</h4>
<pre><code class="language-java">@Configuration
public class RabbitConfig {
    public static final String EXCHANGE_NAME = &quot;priority.exchange&quot;;
    public static final String QUEUE_NAME = &quot;priority.queue&quot;;
    public static final String ROUTING_KEY = &quot;priority&quot;;

    @Bean // 定义交换机
    public DirectExchange priorityExchange() {
        return ExchangeBuilder.directExchange(EXCHANGE_NAME).build();
    }

    @Bean // 定义优先级队列
    public Queue priorityQueue() {
        // 使用maxPriority()方法给队列设置最大优先级，范围是0-255
        return QueueBuilder.durable(QUEUE_NAME)
                .maxPriority(10) // 表示队列中允许的消息优先级范围是0-10
                .build();
    }

    @Bean // 绑定
    public Binding binding(Queue priorityQueue, DirectExchange priorityExchange) {
        return BindingBuilder.bind(priorityQueue).to(priorityExchange)
                .with(ROUTING_KEY);
    }
}
</code></pre>
<h4 id="2-生产者-5">2、生产者</h4>
<pre><code class="language-java">@Slf4j
@RestController
public class SendMsgController {
    @Autowired
    private RabbitTemplate rabbitTemplate;

    @GetMapping(&quot;/sendPriorityMessage&quot;)
    public void sendPriorityMessage(){
        for (int i = 0; i &lt; 10;i++){
            String str = &quot;info&quot; + i;
            // 给第5条消息优先级设置为10(高优先级)
            if (i == 5){
                MessageProperties properties = new MessageProperties();
                properties.setPriority(10);
                Message message = MessageBuilder.withBody(str.getBytes())
                        .andProperties(properties).build();
                rabbitTemplate.convertAndSend(RabbitConfig.EXCHANGE_NAME,
                        RabbitConfig.ROUTING_KEY, message);
            } else {
                rabbitTemplate.convertAndSend(RabbitConfig.EXCHANGE_NAME,
                        RabbitConfig.ROUTING_KEY, str);
            }
        }
        log.info(&quot;消息发送成功&quot;);
    }
}
</code></pre>
<h4 id="3-消费者-2">3、消费者</h4>
<p>注意，消费者建议写在另一个微服务项目中，这样先启动优先级队列的项目发送消息，消息会被积压在优先级队列中，然后再启动消费者项目，就可以查看到正确的效果，即info5首先被消费。</p>
<pre><code class="language-java">@Slf4j
@Component
public class Consumer {
    @RabbitListener(queues = &quot;priority.queue&quot;)
    public void receiveMessage(Message message) {
        String msg = new String(message.getBody());
        log.info(&quot;接收消息：{}&quot;, msg);
    }
}
</code></pre>
<h2 id="4-惰性队列">4. 惰性队列</h2>
<h3 id="41-队列的两种模式">4.1 队列的两种模式</h3>
<p>队列具备两种模式：default和lazy。</p>
<p>在默认模式default下，当生产者将消息发送到 RabbitMQ 的时候，队列中的消息会<strong>尽可能地存储在内存之中</strong>，这样可以更加快速地将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份。当 RabbitMQ 需要释放内存的时候，才会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。</p>
<p>而lazy模式就表示惰性队列，它<strong>会尽可能地将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中</strong>，它的一个重要的设计目标是能够支持更多的消息存储。当消费者由于各种各样的原因(比如消费者宕机)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。</p>
<h3 id="42-设置惰性队列的方式">4.2 设置惰性队列的方式</h3>
<pre><code class="language-java">@Bean // 定义惰性队列
public Queue lazyQueue() {
    return QueueBuilder.durable(&quot;queueName&quot;)
            .lazy().build();
}
</code></pre>
<blockquote>
<p>注：内存开销对比大致如下，在发送一百万条1KB消息的情况下，default队列占用内存约1.2GB，而惰性队列仅占用内存约1.5MB。</p>
</blockquote>
<h2 id="5-rabbitmq集群">5. RabbitMQ集群</h2>
<p>RabbitMQ集群有两种模式：普通集群模式、镜像集群模式。</p>
<h3 id="51-普通集群模式">5.1 普通集群模式</h3>
<p>普通集群模式，也是默认的集群模式，它只会把交换机、队列、虚拟主机等<strong>元数据信息</strong>在各个节点同步，而具体队列中的消息内容不会在各个节点中同步、只会存储在一个节点中。</p>
<p>当消费者消费消息时，如果连接的节点并不存储queue中的消息内容，那么这个节点会根据queue的元数据信息，找到真正存储消息内容的queue所在的节点，然后将消息数据拉取过来并交给消费者消费。</p>
<p>因此，普通集群模式主要是<strong>提高吞吐量</strong>的，也就是让集群中多个节点来服务某个queue的读写操作。而普通集群模式<strong>无法保证高可用性</strong>，一旦真正存储消息内容的节点宕机了，就无法继续提供服务。</p>
<h3 id="52-镜像集群模式">5.2 镜像集群模式</h3>
<p>镜像集群模式，才是RabbitMQ的<strong>高可用模式</strong>，它会把所有数据完全同步，包括元数据信息和消息数据信息，所以每一个RabbitMQ节点都是一个完整镜像。</p>
<p>我们在创建队列时，只需在管理控制台指定一个策略，就能让该队列成为<strong>镜像队列</strong>。每当我们写消息到这个queue时，它就会自动把消息同步到所有其他节点中（同步的过程中会阻塞，无法对外提供服务，直到同步完毕）。所以，即使一个节点宕机了，也能切换到另一个节点去消费数据，保证了服务的高可用性。</p>
<p>这种模式虽然保证了高可用性，但是占用了更多的空间，而且降低了性能，消息同步到所有节点上会导致很高的网络带宽压力。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Saas多租户数据权限设计]]></title>
        <id>https://yuzhupeng.top/myblogs/post/saas-duo-zu-hu-shu-ju-quan-xian-she-ji/</id>
        <link href="https://yuzhupeng.top/myblogs/post/saas-duo-zu-hu-shu-ju-quan-xian-she-ji/">
        </link>
        <updated>2025-08-04T05:49:23.000Z</updated>
        <content type="html"><![CDATA[<p>Saas多租户数据权限设计（参考RuoYi）</p>
<p>最近公司打算把内部的系统打造成商业化的Saas产品，我们组承担了产品的研发任务。</p>
<p>理论上，这套系统在我们公司内部的业务中已经打磨了5年+，对于我们这个细分行业来说已经是非常成熟了，只需要稍加改造，适配多租户模式即可。</p>
<p>但是，真正落实到项目架构设计中，才发现有很多需要重新梳理和考虑的地方。</p>
<h3 id=""><a href="#%E5%AF%BC%E8%88%AA"></a>导航</h3>
<ul>
<li>引子</li>
<li>场景梳理</li>
<li>基于角色的访问控制（RBAC）</li>
<li>多租户系统的权限设计</li>
<li>RuoYi系统的数据权限设计</li>
<li>最终设计方案</li>
<li>参考</li>
</ul>
<h3 id="-2"><a href="#%E5%BC%95%E5%AD%90"></a>引子</h3>
<p>最近公司打算把内部的系统打造成商业化的Saas产品，我们组承担了产品的研发任务。</p>
<p>理论上，这套系统在我们公司内部的业务中已经打磨了5年+，对于我们这个细分行业来说已经是非常成熟了，只需要稍加改造，适配多租户模式即可。</p>
<p>但是，真正落实到项目架构设计中，才发现有很多需要重新梳理和考虑的地方。</p>
<p>今天，主要是针对<strong>数据权限</strong>这块的设计和大家分享一下。</p>
<h3 id="-3"><a href="#%E5%9C%BA%E6%99%AF%E6%A2%B3%E7%90%86"></a>场景梳理</h3>
<blockquote>
<p>脱离场景的设计总是显得空洞。</p>
</blockquote>
<p>在IM聊天场景中，有个很重要功能是，每个用户都要查看自己的会话（聊天记录）。</p>
<p>比如，</p>
<ul>
<li>普通咨询师可能就只能查看自己的聊天</li>
<li>主管可以查看组员咨询师的聊天</li>
<li>CEO可以查看所有咨询师的聊天</li>
<li>...</li>
</ul>
<p>这样的需求在我们的系统中应该如何实现呢？</p>
<h3 id="-4"><a href="#%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6rbac"></a>基于角色的访问控制（RBAC）</h3>
<p>基于角色的访问控制（Role-based access control，简称 RBAC），指的是通过用户的角色（Role）授权其相关权限，这实现了更灵活的访问控制，相比直接授予用户权限，要更加简单、高效、可扩展。</p>
<figure data-type="image" tabindex="1"><a href="https://cdn.authing.co/authing-docs-v2/1.4.20/assets/img/rbac.60e79b81.png"><img src="https://cdn.authing.co/authing-docs-v2/1.4.20/assets/img/rbac.60e79b81.png" alt="" loading="lazy"></a></figure>
<p>当使用 RBAC 时，通过分析系统用户的实际情况，基于共同的职责和需求，授予他们不同角色。你可以授予给用户一个或多个角色，每个角色具有一个或多个权限，这种 用户-角色、角色-权限 间的关系，让我们可以不用再单独管理单个用户，用户从授予的角色里面继承所需的权限。</p>
<h3 id="-5"><a href="#%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1"></a>多租户系统的权限设计</h3>
<p>一般来说，我们会将用户的权限分为菜单权限和数据权限。</p>
<p>菜单权限：控制用户能看到那些菜单或者按钮。</p>
<p>数据权限：控制用户能看到的数据范围。</p>
<p>在开始设计之前，我们可以看看用户登录+授权的过程，在用户返回的信息中就会包含角色（roleCodes）、菜单（permCodes）和数据权限（dataCodes）信息。</p>
<figure data-type="image" tabindex="2"><a href="https://img.zhikestreet.com/17294890486213.png"><img src="https://img.zhikestreet.com/17294890486213.png" alt="" loading="lazy"></a></figure>
<p>所以，角色（roleCodes）、菜单（permCodes）和数据权限（dataCodes）就是需要我们提前设计好的。</p>
<p>根据IM自身的业务，我们对角色的设计如下：</p>
<ul>
<li>咨询师（counselor_role）</li>
<li>主管（manager_role）</li>
<li>管理员（admin_role）</li>
</ul>
<p>菜单权限：</p>
<ul>
<li>账号管理（zhanghaoguanli）</li>
<li>公共设置（gonggongshezhi）</li>
<li>...（根据实际情况定义）</li>
</ul>
<p>令人头疼的其实是数据权限的设计，我们期望定义一种通用的数据权限。</p>
<p>所以，这里就不得不提到<a href="https://ruoyi.vip/">RuoYi系统</a>。</p>
<h4 id="-6"><a href="#ruoyi%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1"></a>RuoYi系统的数据权限设计</h4>
<p>在无意间，看到了一篇介绍RuoYi系统数据权限设计分析的文章- <a href="https://blog.csdn.net/m0_52134610/article/details/124122393">《深入分析若依数据权限@datascope （注解+AOP+动态sql拼接） 【循序渐进，附分析过程】》</a>。</p>
<p>于是，笔者对这个开源系统进行了体验。(点此处直达)[<a href="https://demo.ruoyi.vip/index">https://demo.ruoyi.vip/index</a>]</p>
<p>登录RuoYi系统后台，映入眼帘的是一堆的大家再熟悉不过的系统菜单。</p>
<ul>
<li>系统管理<p></p><p></p><ul><li>用户管理</li><li>角色管理</li><li>菜单管理</li><li>部门管理</li><li>岗位管理</li><li>字典管理</li><li>...</li></ul></li>
</ul>
<p>这里重点查看<code>角色管理</code>菜单，在列表的<strong>操作</strong>一栏，可以看到有个<strong>更多</strong>按钮，展开<strong>更多</strong>按钮，<strong>数据权限</strong>按钮暴露出来。</p>
<figure data-type="image" tabindex="3"><a href="https://img.zhikestreet.com/20241022213343.png"><img src="https://img.zhikestreet.com/20241022213343.png" alt="" loading="lazy"></a></figure>
<p>点击<strong>数据权限</strong>按钮，就可以看到数据权限配置窗口。</p>
<figure data-type="image" tabindex="4"><a href="https://img.zhikestreet.com/20241022214945.png"><img src="https://img.zhikestreet.com/20241022214945.png" alt="" loading="lazy"></a></figure>
<p>在这里可以看到数据权限分类如下：</p>
<ul>
<li>全部数据权限</li>
<li>自定义数据权限</li>
<li>本部门数据权限</li>
<li>本部门及以下数据权限</li>
<li>仅本人数据权限</li>
</ul>
<p>可以看到这里的数据权限都是基于组织架构设计的。</p>
<p>需要指出的是，这里的<strong>自定义数据权限</strong>其实也是基于组织架构的选择，只是可以自由选择（比如适配跨部门场景）。</p>
<p>总体来讲，RuoYi系统数据权限的设计是<strong>中规中矩</strong>的，应该属于比较通用的设计。</p>
<p>这也是我们目前的商业化项目设计中值得借鉴的。</p>
<h3 id="-7"><a href="#%E6%9C%80%E7%BB%88%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"></a>最终设计方案</h3>
<figure data-type="image" tabindex="5"><a href="https://img.zhikestreet.com/20241022221103.png"><img src="https://img.zhikestreet.com/20241022221103.png" alt="" loading="lazy"></a></figure>
<h3 id="-8"><a href="#%E5%8F%82%E8%80%83"></a>参考</h3>
<ul>
<li><a href="https://docs.authing.co/v2/guides/access-control/choose-the-right-access-control-model.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6-rbac" target="_blank">《什么是基于角色的访问控制（RBAC）》</a></li>
<li><a href="https://ruoyi.vip/" target="_blank">ruoyi官网</a></li>
<li><a href="https://gitcode.com/yangzongzhuan/RuoYi-Vue/overview" target="_blank">《RuoYi-Vue 源码》</a></li>
<li><a href="https://blog.csdn.net/m0_52134610/article/details/124122393" target="_blank">《深入分析若依数据权限@datascope （注解+AOP+动态sql拼接） 【循序渐进，附分析过程】》</a></li>
</ul>
<figure data-type="image" tabindex="6"><a href="https://img.zhikestreet.com/paycode.png"><img src="https://img.zhikestreet.com/paycode.png" alt="" loading="lazy"></a></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue核心 笔记]]></title>
        <id>https://yuzhupeng.top/myblogs/post/vue-he-xin-bi-ji/</id>
        <link href="https://yuzhupeng.top/myblogs/post/vue-he-xin-bi-ji/">
        </link>
        <updated>2025-07-30T03:39:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-vue核心">一、Vue核心</h1>
<h2 id="vue是什么">Vue是什么</h2>
<p>Vue是前端优秀框架，是一套用于构建用户界面的<strong>渐进式框架</strong>。</p>
<h2 id="vue-api风格">Vue API风格</h2>
<p>Vue的组件可以按两种不同的风格书写：<em><strong>选项式API</strong></em>和<strong>组合式API</strong></p>
<h2 id="vue开发前端的准备">Vue开发前端的准备</h2>
<blockquote>
<p>前提条件：</p>
<p>命令行</p>
<p>nodejs 15.0或更高版本</p>
</blockquote>
<p>vuejs的使用官方提供了2中方式：</p>
<p>1、基于脚本导入使用，下载vue.js文件，通过script标签引入到html网页。</p>
<p>2、基于项目构建工具来使用，需要安装项目构建工具，自动构建程一个独立的项目。</p>
<p>目前官方推荐的项目构建项目：vue-CLI,vite</p>
<h2 id="el唯一根标签">el唯一根标签</h2>
<pre><code class="language-vue"> &lt;!-- 定义唯一根元素div --&gt;
    &lt;div id=&quot;app&quot;&gt;{{name}}&lt;/div&gt;
    &lt;script&gt;
        var vm = new Vue({
            el: &quot;#app&quot;, //通过el与div元素绑定
            data: {
                name: &quot;Vue 实例创建成功!&quot;
            }
        })
    &lt;/script&gt;
</code></pre>
<pre><code class="language-vue">    &lt;!-- 定义唯一根元素div --&gt;
    &lt;div id=&quot;app&quot;&gt;{{name}}&lt;/div&gt;
    &lt;script&gt;
        var vm = new Vue({
            // el: &quot;#app&quot;, //通过el与div元素绑定
            data: {
                name: &quot;Vue 实例创建成功!&quot;
            }
        })
        vm.$mount(&quot;#app&quot;)
    &lt;/script&gt;
</code></pre>
<h2 id="data与el的2种写法">data与el的2种写法</h2>
<p>1、el有2种写法：</p>
<ul>
<li>new Vue时候配置el属性</li>
<li>先创建Vue实例，随后再通过vm.$mount('#app')指定el的值。</li>
</ul>
<p>2、data有2种写法</p>
<ul>
<li>对象式</li>
<li>函数式</li>
</ul>
<p>以后学习组件时，data必须使用<strong>函数式</strong></p>
<p>3、一个重要的原则：</p>
<p>由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再式Vue实例了。</p>
<p>Vue中数据代理：通过vm对象来代理data对象中属性的操作（读/写）</p>
<p>Vue中数据代理的好处：更加方便的操作data中的数据</p>
<p>基本原理：通过Object.defineProperty()把data对象中所有属性添加到vm上。</p>
<p>为每一个添加到vm上的属性，都指定一个getter/setter。</p>
<p>在getter/setter内部去操作（读/写）data中对应的属性。</p>
<h3 id="事件的基本使用">事件的基本使用：</h3>
<ul>
<li>使用v-on:xxx 或@xxx绑定事件，其中xxx是事件名</li>
<li>事件的回调需要配置在methods对象中，最终会在vm上</li>
<li>methods中配置的函数，不要用箭头函数！否则this就不是vm了。</li>
<li>methods中配置的函数，都是被Vue所管理的函数，this的指向是vm或组件实例对象；</li>
<li>@click=&quot;demo&quot; 和 @click=“demo($event)&quot;效果一致，单后者可以传参数。</li>
</ul>
<h3 id="vue中的事件修饰符">Vue中的事件修饰符：</h3>
<ul>
<li>prevent：阻止默认事件</li>
<li>stop：阻止事件冒泡</li>
<li>once：事件只触发一次</li>
<li>capture：使用是哪的捕获模式</li>
<li>self：只有event.target是当前操作的元素时才触发事件</li>
<li>passive：事件的默认行为立即执行，无需等待事件回调执行完毕</li>
</ul>
<h2 id="vue中常用的按键别名">Vue中常用的按键别名：</h2>
<ul>
<li>回车=&gt;enter</li>
<li>删除-》delete</li>
<li>退出-》esc</li>
<li>空格-》space</li>
<li>换行-》tab（特殊，必须配合keydown去使用）</li>
<li>上-》up</li>
<li>下-》down</li>
<li>左-》left</li>
<li>右-》right</li>
</ul>
<p>Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）</p>
<p>3、系统修饰键：ctrl、alt、shift、meta</p>
<ul>
<li>配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。</li>
<li>配合keydown使用：正常触发事件。</li>
</ul>
<p>4、也可以使用keyCode去指定具体的按键（不推荐）</p>
<p>5、Vue.config.keyCodes.自定义键名 = 键码 可以去定制按键别名。</p>
<h3 id="创建项目">创建项目</h3>
<h4 id="第一种使用-vue-cli-vue脚手架">第一种：使用 vue cli Vue脚手架</h4>
<p>第一步（仅第一次执行）：全局安装@vue/cli</p>
<pre><code>npm install -g @vue/cli
</code></pre>
<p>The recommended way to start a Vite-powered Vue project</p>
<p>第二步：切换到你要创建项目的目录，然后使用命令创建项目。</p>
<pre><code>npm create vue@latest
</code></pre>
<p>第三步：启动项目</p>
<pre><code>  cd vue-demo12
  npm install
  npm run serve
</code></pre>
<p>备注：</p>
<ul>
<li>
<p>如果出现下载缓慢配置npm淘宝镜像：</p>
<pre><code>npm config set registry https://registry.npm.taobao.org
</code></pre>
</li>
</ul>
<h4 id="第二种">第二种：</h4>
<pre><code>npm init vue@latest
</code></pre>
<p>这一条指令将会安装并执行create-vue,它是Vue官方的项目脚手架工具。你将会看到一些诸如TypeScript和测试支持之类的可选项功能提示。</p>
<pre><code>Vue.js - The Progressive JavaScript Framework

√ Project name: ... vue-demo
√ Add TypeScript? ... No / Yes
√ Add JSX Support? ... No / Yes
√ Add Vue Router for Single Page Application development? ... No / Yes
√ Add Pinia for state management? ... No / Yes
√ Add Vitest for Unit Testing? ... No / Yes
√ Add an End-to-End Testing Solution? » No
√ Add ESLint for code quality? ... No / Yes

Scaffolding project in C:\Users\sunliguo\vue-test\vue-demo...

Done. Now run:

  cd vue-demo
  npm install
  npm run dev
</code></pre>
<h4 id="开发环境">开发环境</h4>
<p>vscode + volar</p>
<h3 id="vuejs的m-v-vm思想">Vue.js的M-V-VM思想</h3>
<p>MVVM是Model-View-ViewModel的缩写，它是一种基于前端开发的架构模式，是一种代码分工思想来的 。</p>
<p>Model指代的是vue对象的data属性里面的数据。这里的数据要显示到页面中。</p>
<p>View指代的是vue中数据要显示的HTML页面，在vue中，也称之为“视图模板”。</p>
<p>ViewModel指代的是我们编写代码的vm对象了，他是vue.js的核心，负责连接View和Model，保证视图和数据的一致性，所以前面代码中，data里面的数据被显示中p标签中就是vm对象自动完成的。vm对象会时刻的监控View和Model的变化，并保持双方数据一致性！！！</p>
<h2 id="5-vue项目目录结构">5 Vue项目目录结构</h2>
<pre><code>.vscode			--vscode工具的配置文件
node_modules 	---Vue项目的运行依赖文件夹
public 			--- 资源文件夹（浏览器图标）
src				---	源码文件夹
.gitignore		---git忽略文件
index.html		--- html文件
package.json	---	信息描述文件
README.md		---	注释文件
vite.config.js	---	Vue配置文件
</code></pre>
<h2 id="6-模板语法">6 模板语法</h2>
<p>“插值”是指，使用{{变量}}的方法讲数据插入到HTML文档中。</p>
<p>插值分为文本插值、HTML插值等。</p>
<ul>
<li>文本插值 {{变量}} v-text</li>
<li>HTML插值 v-html</li>
</ul>
<p>双花括号仅拥用输出文本内容，如果要输出html代码，则要使用v-html来输出。</p>
<p>v-html必须在html标签里面作为属性写出来，而且只能写在普通双标签中，单标签元素或者表单都不行。</p>
<pre><code class="language-vue">&lt;script &gt;
export default {
  data() {
    return {
      msg: &quot;神奇的语法&quot;,
      number:10,
      message:&quot;大家好&quot;,
      rawHtml :&quot;&lt;a href='http://blog.sunliguo.com'&gt;sunliguo&lt;/a&gt;&quot;
    };
  },
};
&lt;/script&gt;

&lt;template&gt;
  &lt;h3&gt;模板语法&lt;/h3&gt;
  &lt;p&gt;{{ msg }}&lt;/p&gt;
  &lt;p&gt;{{number+1}}&lt;/p&gt;
  &lt;p&gt;{{message.split(&quot;&quot;).reverse().join(&quot;&quot;)}}&lt;/p&gt;
  &lt;p v-html=&quot;rawHtml&quot;&gt;&lt;/p&gt;
&lt;/template&gt;

</code></pre>
<pre><code class="language-html"> &lt;div id=&quot;app&quot;&gt;
        &lt;p&gt;{{title}}&lt;/p&gt;
        &lt;p v-text=&quot;title&quot;&gt;&lt;/p&gt;
        &lt;p&gt;{{content}}&lt;/p&gt;
        &lt;p&gt;{{ htmlContent}}&lt;/p&gt;
        &lt;p v-text=&quot;htmlContent&quot;&gt;&lt;/p&gt;
        &lt;p v-html=&quot;htmlContent&quot;&gt;&lt;/p&gt;
 
    &lt;/div&gt;
    &lt;script&gt;
        const vm = new Vue({
            el: '#app',
            data() {
                return {
                    title: '这是标题内容',
                    content: &quot;这是内容文本&quot;,
                    htmlContent:'这是一个&lt;span&gt;span&lt;/span&gt;标签'
                }
            },
        }
        )
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="使用javascript表达式">使用JavaScript表达式</h3>
<h1 id="二-vue组件化编程">二、Vue组件化编程</h1>
<h2 id="22-常用指令">2.2、常用指令</h2>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th>简写</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>v-bind</td>
<td>单向绑定解析表达式</td>
<td>v-bind:id=&quot;data&quot;</td>
<td>:id=&quot;data&quot;</td>
<td>绑定id属性，值为data</td>
</tr>
<tr>
<td>v-model</td>
<td>双向数据绑定</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>v-on</td>
<td>绑定事件监听</td>
<td>v-on:click=&quot;showInfo&quot;</td>
<td>@click=&quot;showInfo&quot;</td>
<td>事件监听</td>
</tr>
<tr>
<td>v-for</td>
<td>遍历数组/对象/字符串</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>v-if</td>
<td>条件渲染</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>v-else</td>
<td>条件渲染</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>v-show</td>
<td>动态控制节点是否展示</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>v-text</td>
<td>向其所在节点渲染文本内容</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>v-html</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>v-cloak</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>v-once</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="v-text-更新元素的文本内容">v-text 更新元素的文本内容</h4>
<ul>
<li>
<p>期望的绑定值的类型：string</p>
</li>
<li>
<p>实例</p>
<ul>
<li>
<pre><code>&lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt;
&lt;!--等同于--&gt;
&lt;span&gt;{{msg}}&lt;/span&gt;
</code></pre>
</li>
<li></li>
</ul>
</li>
</ul>
<h2 id="7-属性绑定-v-bind">7 属性绑定 v-bind</h2>
<p>v-bind 动态绑定一个或多个attribute，也可以是组件的prop。</p>
<p>双大括号不能在 HTML attributes 中使用。想要响应式地绑定一个 attribute，应该使用 <a href="https://cn.vuejs.org/api/built-in-directives.html#v-bind"><code>v-bind</code> 指令</a>：</p>
<pre><code class="language-html">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-vue">&lt;script &gt;
export default {
  data() {
    return {
      msg: &quot;active&quot;,
      dynamicID: &quot;appid&quot;,      
    };
  },
};
&lt;/script&gt;

&lt;template&gt;
  &lt;div v-bind:id=&quot;dynamicID&quot;&gt;测试&lt;/div&gt;
&lt;/template&gt;

</code></pre>
<ul>
<li>
<p>示例：</p>
</li>
<li>
<pre><code class="language-vue">&lt;!-- 绑定 attribute --&gt;
&lt;img v-bind:src=&quot;imageSrc&quot; /&gt;

&lt;!-- 动态 attribute 名 --&gt;
&lt;button v-bind:[key]=&quot;value&quot;&gt;&lt;/button&gt;

&lt;!-- 缩写 --&gt;
&lt;img :src=&quot;imageSrc&quot; /&gt;

&lt;!-- 缩写形式的动态 attribute 名 (3.4+)，扩展为 :src=&quot;src&quot; --&gt;
&lt;img :src /&gt;

&lt;!-- 动态 attribute 名的缩写 --&gt;
&lt;button :[key]=&quot;value&quot;&gt;&lt;/button&gt;

&lt;!-- 内联字符串拼接 --&gt;
&lt;img :src=&quot;'/path/to/images/' + fileName&quot; /&gt;

&lt;!-- class 绑定 --&gt;
&lt;div :class=&quot;{ red: isRed }&quot;&gt;&lt;/div&gt;
&lt;div :class=&quot;[classA, classB]&quot;&gt;&lt;/div&gt;
&lt;div :class=&quot;[classA, { classB: isB, classC: isC }]&quot;&gt;&lt;/div&gt;

&lt;!-- style 绑定 --&gt;
&lt;div :style=&quot;{ fontSize: size + 'px' }&quot;&gt;&lt;/div&gt;
&lt;div :style=&quot;[styleObjectA, styleObjectB]&quot;&gt;&lt;/div&gt;

&lt;!-- 绑定对象形式的 attribute --&gt;
&lt;div v-bind=&quot;{ id: someProp, 'other-attr': otherProp }&quot;&gt;&lt;/div&gt;

&lt;!-- prop 绑定。“prop” 必须在子组件中已声明。 --&gt;
&lt;MyComponent :prop=&quot;someThing&quot; /&gt;

&lt;!-- 传递子父组件共有的 prop --&gt;
&lt;MyComponent v-bind=&quot;$props&quot; /&gt;

&lt;!-- XLink --&gt;
&lt;svg&gt;&lt;a :xlink:special=&quot;foo&quot;&gt;&lt;/a&gt;&lt;/svg&gt;
</code></pre>
</li>
</ul>
<p>v-bind指令只是将元素的id attribute与组件的dynamicld属性保持一致。如果绑定的值是null或者undefined，那么该attribute将会从渲染的元素上移除。</p>
<blockquote>
<p>温馨提示：</p>
<p>v-bind: 可以简写为：</p>
</blockquote>
<h2 id="8-条件渲染-v-if">8 条件渲染 v-if</h2>
<pre><code class="language-vue">&lt;template&gt;
    &lt;h3&gt;条件渲染&lt;/h3&gt;
    &lt;div v-if=&quot;flag&quot;&gt;你能看见我吗？&lt;/div&gt;
    &lt;div v-else&gt;那你还是看看我吧&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default{
    data(){
        return {
            flag:false,
        }
    }
}
&lt;/script&gt;
</code></pre>
<p>v-show</p>
<h2 id="9-列表渲染v-for">9 列表渲染	v-for</h2>
<p>利用v-for 指令，可以基于一个数组渲染一个列表。</p>
<p>v-for = &quot;item in items&quot;</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;h3&gt;列表渲染&lt;/h3&gt;
  &lt;p v-for=&quot;(item,index) in names&quot; :key=&quot;index&quot;&gt;{{ item }}&lt;/p&gt;
  &lt;div v-for=&quot;item in result&quot;&gt;
    &lt;p&gt;{{ item.title }}&lt;/p&gt;
    &lt;img :src=&quot;item.avator&quot; /&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  data() {
    return {
      names: [&quot;百战程序员&quot;, &quot;尚学堂&quot;, &quot;IT&quot;],
      result: [
        {
          id: 2261677,
          title: &quot;鄂尔多斯|&quot;,
          avator: &quot;http://www&quot;,
        },
        {
          id: 2261566,
          title: &quot;成都|&quot;,
          avator: &quot;http://www&quot;,
        },
        {
          id: 2261662,
          title: &quot;川西|&quot;,
          avator: &quot;http://www&quot;,
        },
      ],
    };
  },
};
&lt;/script&gt;
</code></pre>
<h2 id="10-通过key管理状态">10 通过key管理状态</h2>
<h3 id="维护状态">维护状态</h3>
<p>当Vue正在更新使用v-for渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的<strong>顺序</strong>改变，Vue就不会移动DOM元素来匹配数据项的顺序，而是就地更新每个元素，并确保他们在原本指定的索引位置上渲染。</p>
<p>为了给Vue一个提示，以便它能耿总每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一的key attribute：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;h3&gt;key属性添加到v-for中&lt;/h3&gt;
  &lt;p v-for=&quot;(name, index) of names&quot; v-bind:key=&quot;index&quot;&gt;{{ name }}&lt;/p&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  data() {
    return { names: [&quot;百战程序员&quot;, &quot;尚学堂&quot;, &quot;IT&quot;] };
  },
};
&lt;/script&gt;
</code></pre>
<h2 id="11-事件处理">11 事件处理</h2>
<p>Vue.js的事件绑定格式是&quot;v-on:&quot;或者”@“。事件处理方法需要在methods中定义。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div ref=&quot;container&quot; class=&quot;container&quot;&gt;{{ content }}&lt;/div&gt;
  &lt;input type=&quot;text&quot; ref=&quot;username&quot;&gt;
  &lt;button @click=&quot;getElementHandle&quot;&gt;获取元素&lt;/button&gt;

&lt;/template&gt;
&lt;script&gt;
/**
 *内容改变：{{模板语法}}
属性改变：v-bind: 指令
事件： v-on:click
如果没有特别的需求，不要操作DOM
 */
export default {
  data() {
    return {
      content: &quot;内容&quot;,
    };
  },
  methods:{
    getElementHandle(){
        //innerHTML:原生js的属性
        //console.log(this.$refs.container.innerHTML='哈哈哈')
        console.log(this.$refs.username.value)
    }
  }
};
&lt;/script&gt;
</code></pre>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div ref=&quot;container&quot; class=&quot;container&quot;&gt;{{ content }}&lt;/div&gt;
  &lt;input type=&quot;text&quot; ref=&quot;username&quot;&gt;
  &lt;br&gt;
  &lt;button v-on:click=&quot;counter += 1&quot;&gt;点击：counter={{ counter }}&lt;/button&gt;
  &lt;button @click=&quot;getElementHandle&quot;&gt;获取元素&lt;/button&gt;
  &lt;button @click=&quot;clickHandle&quot;&gt;按钮&lt;/button&gt;
  &lt;p&gt;{{ message }}&lt;/p&gt;
&lt;/template&gt;
&lt;script&gt;
/**
 *内容改变：{{模板语法}}
属性改变：v-bind: 指令
事件： v-on:click
如果没有特别的需求，不要操作DOM
 */
export default {
  data() {
    return {
      content: &quot;内容&quot;,
      counter: 1,
      message: '消息通知'
    };
  },
  methods: {
    getElementHandle() {
      //innerHTML:原生js的属性
      //console.log(this.$refs.container.innerHTML='哈哈哈')
      console.log(this.$refs.username.value)
    },
    clickHandle(event) {
      // 在事件中，读取data中的属性，是需要通过this.属性
      this.message = '消息撤回了';
      //event 是原生的DOM event
      console.log(event);
      event.target.innerHTML = '点击之后';
    }
  }
};
&lt;/script&gt;
</code></pre>
<h2 id="12-事件传参">12 事件传参</h2>
<p>内联处理器中的参数</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;button @click=&quot;say('hi')&quot;&gt;say&lt;/button&gt;
  &lt;button @click=&quot;say('what')&quot;&gt;say what&lt;/button&gt;
  &lt;ul&gt;
    &lt;li @click=&quot;clickHandle2(item)&quot; v-for=&quot;(item,idnex) in names&quot; :key=&quot;index&quot;&gt;{{item}}&lt;/li&gt;
  &lt;/ul&gt;
&lt;/template&gt;
&lt;script&gt;
/**
 *内容改变：{{模板语法}}
属性改变：v-bind: 指令
事件： v-on:click
如果没有特别的需求，不要操作DOM
 */
export default {
  data() {
    return {
      content: &quot;内容&quot;,
      counter: 1,
      message: '消息通知',
      names:['iwen','ime','frank']
    };
  },
  methods: {

    say(data){
      console.log(data)
    },
    clickHandle2(data){
      console.log(data)
    }
  }
};
&lt;/script&gt;
</code></pre>
<h4 id="在内联事件处理器中访问事件参数">在内联事件处理器中访问事件参数</h4>
<p>有时我们需要在内联事件处理器中访问原生 DOM 事件。你可以向该处理器方法传入一个特殊的 <code>$event</code> 变量，或者使用内联箭头函数</p>
<pre><code class="language-vue">&lt;template&gt;
&lt;switch @change=&quot;onChange(124,$event)&quot;&gt;开关&lt;/switch&gt;
&lt;/template&gt;
&lt;script&gt;
	function onChange(a,e) {
		console.log(e);
		console.log(a)
		isLoading.value = e.detail.value
	}
&lt;/script&gt;

</code></pre>
<h2 id="13事件修饰符">13事件修饰符</h2>
<p>Vue为v-on提供了事件修饰符，常用的有以下几个：</p>
<ul>
<li>
<p>.stop</p>
</li>
<li>
<p>.prevent</p>
</li>
<li>
<p>.once       # 限制事件绑定次数为1次</p>
</li>
<li>
<p>.enter</p>
</li>
<li>
<p>.number    #限制表单输入为数字</p>
</li>
<li>
<p>.trim</p>
</li>
</ul>
<h4 id="阻止默认事件-prevent">阻止默认事件 .prevent</h4>
<pre><code class="language-vue">&lt;template&gt;
&lt;h3&gt;事件修饰符&lt;/h3&gt;
&lt;a @click.prevent=&quot;clcikHandle&quot; href=&quot;https://itbaizhan.com&quot;&gt;百战程序员&lt;/a&gt;
&lt;/template&gt;
&lt;script&gt;

export default{
    data(){
        return {
        }
    },
    methods:{
        clcikHandle(e){
            //阻止默认事件
            // e.preventDefault();
            console.log('点击了');
        }
    }
}
&lt;/script&gt;
</code></pre>
<h4 id="阻止冒泡事件">阻止冒泡事件</h4>
<pre><code class="language-vue">&lt;template&gt;
&lt;h3&gt;事件修饰符&lt;/h3&gt;

&lt;div @click=&quot;clickDiv&quot;&gt;
    &lt;p @click.stop=&quot;clickP&quot;&gt;测试冒泡&lt;/p&gt;
&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;

export default{
    data(){
        return {
        }
    },
    methods:{
        clickDiv(){
            console.log('点击了div')
        },
        clickP(e){
            //阻止冒泡
            // e.stopPropagation();
            console.log('点击了p')
        }
    }
}
&lt;/script&gt;
</code></pre>
<h2 id="14-数组变化侦测">14 数组变化侦测</h2>
<h4 id="变更方法">变更方法</h4>
<p>变更方法，顾名思义，就是会对调用他们的原数组进行变更。</p>
<p>Vue能够侦听响应式数组的变更方法，并在它们被调用时触发相关的更新。这些变更方法包括：</p>
<ul>
<li>push()</li>
<li>pop()</li>
<li>shift()</li>
<li>unshift()</li>
<li>splice()</li>
<li>sort()</li>
<li>reverse()</li>
</ul>
<pre><code class="language-vue">&lt;template&gt;
&lt;h3&gt;数组侦听&lt;/h3&gt;
&lt;button @click=&quot;addListHandle&quot;&gt;添加数据&lt;/button&gt;
&lt;ul&gt;
    &lt;li v-for=&quot;(name,index) in names&quot; :key=&quot;index&quot;&gt;{{ name }}&lt;/li&gt;
&lt;/ul&gt;
&lt;/template&gt;
&lt;script&gt;
export default{
    data(){
        return {
            names:['iwen','ime','frank']
        }
    },
    methods:{
        //引起UI自动更新
        addListHandle(){
            this.names.push(&quot;sakura&quot;)
        }
    }

}
&lt;/script&gt;
</code></pre>
<h4 id="替换一个数组">替换一个数组</h4>
<p>filter(),concat()和slice()，不会更改原数组，而总是返回一个新数组。当遇到的是非变更方法时，我门需要将就的数组替换为新的。</p>
<pre><code class="language-vue">&lt;template&gt;
&lt;h3&gt;数组侦听&lt;/h3&gt;
&lt;button @click=&quot;addListHandle&quot;&gt;添加数据&lt;/button&gt;
&lt;ul&gt;
    &lt;li v-for=&quot;(name,index) in names&quot; :key=&quot;index&quot;&gt;{{ name }}&lt;/li&gt;
&lt;/ul&gt;
&lt;/template&gt;
&lt;script&gt;
export default{
    data(){
        return {
            names:['iwen','ime','frank']
        }
    },
    methods:{
        
        addListHandle(){
            //引起UI自动更新
            // this.names.push(&quot;sakura&quot;)
            //不会引起UI自动更新
            this.names.concat(['sakura'])

            console.log(this.names)
            this.names = this.names.concat(['sakura'])
        }
    }

}
&lt;/script&gt;
</code></pre>
<h2 id="15-计算属性">15 计算属性</h2>
<p>当有些数据需要随着其他数据变动而变动时，就需要使用computed计算属性。在事件处理方法中，this指向的Vue实例的计算属性结果被缓存起来，只有依赖的响应式属性变化时，才会重新计算，返回最终结果。</p>
<pre><code class="language-vue">&lt;template&gt;
    &lt;h3&gt;{{itbaizhan.name}}&lt;/h3&gt;
    &lt;p&gt;{{itbaizhan.content.length &gt; 0 ?&quot;Yes&quot;:&quot;No&quot;}}&lt;/p&gt;
    &lt;p&gt;{{itbaizhanContent}}&lt;/p&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
    data(){
        return {
            itbaizhan:{
                name:&quot;百战程序员&quot;,
                content:['前端',&quot;Java&quot;,'Python']
            }
        }
    },
    //计算属性
    computed:{
        itbaizhanContent(){
            return this.itbaizhan.content.length &gt; 0 ?&quot;Yes&quot;:&quot;No&quot;
        }
    }
}
&lt;/script&gt;
</code></pre>
<h4 id="计算属性传参">计算属性传参</h4>
<pre><code class="language-vue">
&lt;div id=&quot;app&quot;&gt;
        &lt;h1&gt;{{titDes(&quot;web前端&quot;)}}&lt;/h1&gt;
    &lt;/div&gt;
    &lt;script&gt;
        new Vue({
            el:&quot;#app&quot;,
            data:{
                title:'新视觉培训',
                desc :'手动阀手动阀'
            },
            computed:{
                titDes(){
                    return function(e){
                        return '新视觉培训'+e;
                    }
                }
            }
        })
        &lt;/script&gt;
</code></pre>
<h2 id="16-class-绑定">16 Class 绑定</h2>
<p>数据绑定的一个常见需求场景是操纵元素的CSS class列表。</p>
<p>Vue专门为class的v-bind用法提供了特殊的功能增强。处理字符串外，表达式的值也可以是对象或数组。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;p :class=&quot;myClass&quot;&gt;Class样式&lt;/p&gt;
  &lt;p v-bind:class=&quot;myClass&quot;&gt;Class样式&lt;/p&gt;
  &lt;p :class=&quot;{ active: isActive, 'text-danger': hasError }&quot;&gt;Class样式&lt;/p&gt;
  &lt;p :class=&quot;classObject&quot;&gt;Class样式绑定2&lt;/p&gt;
  &lt;p :class=&quot;[arrActive, arrHasError]&quot;&gt;Class样式绑定3&lt;/p&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  data() {
    return {
      myClass: &quot;demo&quot;,
      isActive: false,
      hasError: true,
      classObject: {
        active: true,
        &quot;text-danger&quot;: true,
      },
      arrActive: &quot;active&quot;,
      arrHasError: &quot;text-danger&quot;,
    };
  },
};
&lt;/script&gt;
&lt;style &gt;
.active {
  font-size: 30px;
}
.text-danger {
  color: red;
}
&lt;/style&gt;
</code></pre>
<h2 id="17-style绑定">17 style绑定</h2>
<pre><code class="language-vue">&lt;template&gt;
    &lt;p :style=&quot;{class:'red'}&quot;&gt;style绑定1&lt;/p&gt;
    &lt;p :style=&quot;{class:activeColor}&quot;&gt;style绑定2&lt;/p&gt;
    &lt;p :style=&quot;styleObject&quot;&gt;style绑定3&lt;/p&gt;

    
&lt;/template&gt;
&lt;script&gt;
export default {
    data(){
        return {
            activeColor:'green',
            fontSize:30,
            styleObject:{
                color:'red',
                fontSize:'30px'
            }

        }
    }
}
&lt;/script&gt;
</code></pre>
<h2 id="18-侦听器-watch">18 侦听器 watch</h2>
<p>监视属性watch:</p>
<p>1、当被监视的属性变化时，回调函数自动调用，进行相关操作</p>
<p>2、监视的属性必须存在，才能进行监视</p>
<p>3、监视的两种写法：</p>
<ul>
<li>new Vue时传入watch配置</li>
<li>通过vm.$watch监视</li>
</ul>
<p>我们使用wach选项在每次响应式属性发生变化时触发一个函数。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;h3&gt;侦听器&lt;/h3&gt;
  &lt;p&gt;{{ message }}&lt;/p&gt;
  &lt;button @click=&quot;updateHandle&quot;&gt;修改数据&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  data() {
    return {
      message: &quot;Hello&quot;,
    };
  },
  methods: {
    updateHandle() {
      this.message = &quot;world&quot;;
    },
  },
  watch: {
    //newValue 改变之后的数据
    //oldValue 改变之前的数据
    //函数名必须与侦听的数据对象保持一致
    message(newValue, oldValue) {
      console.log(newValue);
      console.log(oldValue);
    },
  },
};
&lt;/script&gt;
</code></pre>
<h3 id="computed和watch之间的区别">computed和watch之间的区别</h3>
<p>1、computed能完成的功能，watch都可以完成。</p>
<p>2、watch能完成的功能，computed不一定能完成。例如：watch可以进行异步操作。</p>
<p>两个重要的小原则：</p>
<p>1、所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm或组件实例对象。</p>
<p>2、所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等），最好写成箭头函数，这样this的指向才是vm或组件实例对象。</p>
<h2 id="19表单输入绑定v-model">19表单输入绑定v-model</h2>
<pre><code class="language-vue">&lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;
</code></pre>
<pre><code class="language-vue">&lt;template&gt;
  &lt;h3&gt;表单数据绑定&lt;/h3&gt;
  &lt;form&gt;
    &lt;input type=&quot;text &quot; v-model=&quot;message&quot; /&gt;
    &lt;p&gt;{{ message }}&lt;/p&gt;
    &lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot; /&gt;
    &lt;label for=&quot;checkbox&quot;&gt;{{ checked }}&lt;/label&gt;
  &lt;/form&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  data() {
    return {
      message: &quot;&quot;,
      checked: true,
    };
  },
};
&lt;/script&gt;

</code></pre>
<h2 id="20-模板引用-ref">20 模板引用 $ref</h2>
<p>虽然Vue的声明性渲染模型为你抽象了大部分对DOM的直接操作，但在某些情况下，我们仍然需要直接访问的底层DOM元素。要实现这一点，我们可以使用特殊的ref attribute。</p>
<p>模板引用也就是指向模板中一个 DOM 元素的 ref。 我们需要通过这个特殊的 ref attribute来实现模板引用：</p>
<pre><code class="language-vue">&lt;p ref=&quot;pElementRef&quot; &gt;
    hello
&lt;/p&gt;
</code></pre>
<p>此元素将作为this.<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>f</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>p</mi><mi>E</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>R</mi><mi>e</mi><mi>f</mi><mi mathvariant="normal">暴</mi><mi mathvariant="normal">露</mi><mi mathvariant="normal">在</mi><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">refs.pElementRef暴露在 this.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mord">.</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord cjk_fallback">暴</span><span class="mord cjk_fallback">露</span><span class="mord cjk_fallback">在</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord">.</span></span></span></span>refs上。然而，你只能在组件挂载之后访问它。</p>
<p>要在挂载之后执行代码，我们可以使用mouted选项：</p>
<pre><code class="language-vue">export default{
	mounted(){
	//此时组件已经挂载
	}
}
</code></pre>
<p>挂载结束后引用都会被暴露在<font color=red>this.$refs</font>之上。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div ref=&quot;container&quot; class=&quot;container&quot;&gt;{{ content }}&lt;/div&gt;
  &lt;input type=&quot;text&quot; ref=&quot;username&quot;&gt;
  &lt;button @click=&quot;getElementHandle&quot;&gt;获取元素&lt;/button&gt;

&lt;/template&gt;
&lt;script&gt;
/**
 *内容改变：{{模板语法}}
属性改变：v-bind: 指令
事件： v-on:click
如果没有特别的需求，不要操作DOM
 */
export default {
  data() {
    return {
      content: &quot;内容&quot;,
    };
  },
  methods:{
    getElementHandle(){
        //innerHTML:原生js的属性
        //console.log(this.$refs.container.innerHTML='哈哈哈')
        console.log(this.$refs.username.value)
    }
  }
};
&lt;/script&gt;
</code></pre>
<h3 id="ref属性">ref属性</h3>
<ul>
<li>被用来给元素或子组件注册引用信息（id的替代者）</li>
<li>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li>
<li>使用方式：
<ul>
<li>打标识<h1 ref="xxx">....</h1> 或<school ref="xxx"></school></li>
<li>获取：this.$refs.xxx</li>
</ul>
</li>
</ul>
<h2 id="21-组件组成">21、组件组成</h2>
<p>关于组件名：</p>
<ul>
<li>
<p>一个单词组成：</p>
<ul>
<li>首字母小写：school</li>
<li>首字母大写：School</li>
</ul>
</li>
<li>
<p>多个单词组成：</p>
<ul>
<li>kebab-case命名：my-school</li>
<li>CamelCase命名：MySchool（需要Vue脚手架支持）</li>
</ul>
<p>备注：</p>
<p>1、组件名尽可能回避HTML中已有的元素名称。</p>
<p>2、可以使用name配置项值指定组件在开发者工具中呈现的名字。</p>
<p>一个简写方式：</p>
<p>const shcool = Vue.extend(options) 可简写为：const school = options</p>
</li>
</ul>
<p>组件最大的优势就是可复用性。</p>
<p>当使用构建步骤时，我们一般会将Vue组件定义在一个.vue文件中，这被叫做单文件组件（简称SFC）</p>
<h4 id="组件组成结构">组件组成结构</h4>
<pre><code class="language-vue">&lt;template&gt;
	&lt;div&gt;承载标签&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {

}
&lt;/script&gt;
&lt;style scoped&gt;
&lt;/style&gt;
</code></pre>
<h4 id="子组件mycomponent">子组件：mycomponent</h4>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;container&quot;&gt;组件基础组成&lt;/div&gt;
&lt;/template&gt;
&lt;script &gt;
export default {
  data() {
    return &quot;&quot;;
  },
};
&lt;/script&gt;

&lt;!--scoped 让当前样式只在当前组件生效--&gt;
&lt;style scoped&gt;
.container {
  font-size: 20px;
}
&lt;/style&gt;

</code></pre>
<p>App.vue</p>
<pre><code class="language-vue">&lt;template&gt;
    &lt;!-- 第三步：显示组件 --&gt;
    &lt;MyComponent/&gt;
&lt;/template&gt;
&lt;script&gt;
//第一步：引入组件
import MyComponent from &quot;./components/mycomponent&quot;

export default{
    //第二步：注入组件
    components:{
        MyComponent,
    }
}
&lt;/script&gt;

</code></pre>
<p>使用组件3个步骤：</p>
<p>1、在父组件中引入子组件</p>
<pre><code class="language-vue">import MyComponent from &quot;./components/mycomponent&quot;
</code></pre>
<p>2、注入组件</p>
<pre><code class="language-vue">components:{
        MyComponent,
    }
</code></pre>
<p>3、显示组件</p>
<pre><code class="language-vue">&lt;template&gt;
    &lt;!-- 第三步：显示组件 --&gt;
    &lt;MyComponent/&gt;
&lt;/template&gt;
</code></pre>
<h4 id="组件声明">组件声明</h4>
<pre><code class="language-vue">    &lt;script&gt;
        //组件声明
        Vue.component(&quot;组件名&quot;,{
            data(){ //组件内部的数据

            },
            methods:{  //组件内部的操作方法

            },
            temlate:&quot;&quot;, //组件的HTML代码
        });
    &lt;/script&gt;
</code></pre>
<h2 id="222-组件嵌套关系">2.22 组件嵌套关系</h2>
<p>通常一个应用会以一棵嵌套的组件树的形式来组织。</p>
<p>真正的Vue应用往往是有嵌套组件创建的。</p>
<p>父组件可以在模板中渲染另一个组件作为子组件。要使用子组件间，我们需要先导入它：</p>
<pre><code class="language-javascript">import ChildComp from './ChildComp.vue'

export default {
  components: {
    ChildComp
  }
}
</code></pre>
<p>我们还需要使用components选项注册组件。这里我们使用对象属性的简写形式在ChildComp键下中注册ChildComp组件。</p>
<p>然后我们就可以在模板中使用组件。</p>
<pre><code>&lt;ChildComp/&gt;
</code></pre>
<h2 id="223-组件传递数据_props">2.23 组件传递数据_Props</h2>
<p>组件与组件之间不是完全独立的。</p>
<p>传递数据的解决方案是Props。 一个组件需要显式声明它所接受的 props，这样 Vue 才能知道外部传入的哪些是 props 。</p>
<p>子组件可以通过props从父组件接收动态数据。</p>
<p>在使用 <code>&lt;script setup&gt;</code> 的单文件组件中，props 可以使用 <code>defineProps()</code> 宏来声明：</p>
<pre><code class="language-vue">&lt;script setup&gt;
const props = defineProps(['foo'])
console.log(props.foo)
&lt;/script&gt;
</code></pre>
<p>在没有使用 <code>&lt;script setup&gt;</code> 的组件中，prop 可以使用 <a href="https://cn.vuejs.org/api/options-state.html#props"><code>props</code></a> 选项来声明：</p>
<pre><code class="language-javascript">export default {
  props: ['foo'],
  setup(props) {
    // setup() 接收 props 作为第一个参数
    console.log(props.foo)
  }
}
</code></pre>
<p>注意传递给 <code>defineProps()</code> 的参数和提供给 <code>props</code> 选项的值是相同的，两种声明方式背后其实使用的都是 prop 选项。</p>
<p>除了使用字符串数组来声明 prop 外，还可以使用对象的形式：</p>
<pre><code>// 使用 &lt;script setup&gt;
defineProps({
  title: String,
  likes: Number
})
</code></pre>
<pre><code>// 非 &lt;script setup&gt;
export default {
  props: {
    title: String,
    likes: Number
  }
}
</code></pre>
<p>首先，子组件中需要声明它所接收的props：</p>
<pre><code class="language-vue">&lt;script&gt;
//在子组件中
export default{
//简单声明接收
	props:['name','age','sex'],
	//接收的同时对数据进行类型限制
	props:{
			name:String,
			age:Number,
			sex:String,
	},
	props:{
		name:{
				type:String,
				required:true,
		},
		age:{
				type:Number,
				default:99,
		},
		sex:{
			type:String,
			require:true,
		}
		}
	}
&lt;/script&gt;
</code></pre>
<p>一旦声明，msg prop 就会暴露在this上，并可以在子组件的模板中使用。</p>
<p>父组件可以像声明HTML attributes一样传递props。若要传递动态值，也可以使用v-bind 语法：</p>
<pre><code class="language-vue">&lt;ChildComp :msg=&quot;greeting&quot;/&gt;
</code></pre>
<p>父组件：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;p&gt;
    {{ title }}
  &lt;/p&gt;
  &lt;myComponent :title=&quot;title&quot; :age=&quot;age&quot;/&gt;
&lt;/template&gt;

&lt;script&gt;
 //引入子组件
import myComponent from &quot;./components/myComponents.vue&quot;

export default {
  name: 'App',
  data() {
    return {
      title: '我是一个标题',
      age:20,
    }
  },
  components: {
    myComponent,
  }
}
&lt;/script&gt;
</code></pre>
<p>子组件：</p>
<pre><code class="language-vue">&lt;template&gt;
    &lt;h3&gt;prop传递数据&lt;/h3&gt;
    &lt;p&gt;{{ title }}&lt;/p&gt;
    &lt;p&gt;{{ age }}&lt;/p&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
    name: &quot;myComponent&quot;,
    props: {
        title: {
            type: String,
            default: ''
        },
        age: {
            type: Number,
            default: 2
        }

    }
}
&lt;/script&gt;
&lt;style scoped&gt;&lt;/style&gt;
</code></pre>
<p>例二：</p>
<p>父组件</p>
<pre><code class="language-vue">&lt;template&gt;
    &lt;h1&gt;Home页面&lt;/h1&gt;
    &lt;!--父组件要发送数据给子组件，通过组件的属性传递。属性名就是将来的变量名，
    传递数据如果时一个变量，则需要在左边加上冒号
    --&gt;
    &lt;Menu :htotal=&quot;total&quot; title=&quot;来自父组件的数据&quot;&gt; &lt;/Menu&gt;
    &lt;button @click=&quot;total++&quot;&gt;{{total}}&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
import Menu from '../components/Menu.vue'

export default {
    name: &quot;home&quot;,
    data(){
        return {
            total:0
        }
    },
    components: {
        Menu,
    }
}
&lt;/script&gt;
&lt;style scoped&gt;
list-style-type:none;
&lt;/style&gt;
</code></pre>
<p>子组件：</p>
<pre><code class="language-vue">&lt;template&gt;
    &lt;div&gt;
        &lt;p&gt;来自父组件的数据：total= {{ htotal }}&lt;/p&gt;
        &lt;p&gt;来自父组件的数据：title= {{ title }}&lt;/p&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;a href=&quot;&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;&quot;&gt;商品&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;&quot;&gt;论坛&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;&quot;&gt;注册&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
    name: &quot;Menu&quot;,
    //来自父组件的数据，全部通过props来接收，2种写法：json写法，数组写法
    // props:['htotal','title']
    props: {
        htotal: Number,   //来自父组件的数据
        title: String,
    }
}

&lt;/script&gt;
&lt;style scoped&gt;
div {
    border: 1px solid red;
}

ul {
    list-style-type: none;
}

li {
    display: inline;
    margin-right: 10px;
}

li a {
    text-decoration: none;
}
&lt;/style&gt;

</code></pre>
<h3 id="vue3-中的例子组合式api">Vue3 中的例子组合式api：</h3>
<p>子组件中：</p>
<pre><code class="language-vue">&lt;script setup&gt;
	// 子组件声明
	// const props = defineProps(['username', 'avatar'])
	// console.log(props)
	const props = defineProps({
		username:{
			type:String,
			default:'匿名'
		},
		avatar:{
			type:String,
			default:'../../static/logo.png'
		}
	})
	
&lt;/script&gt;
</code></pre>
<p>在子组件中使用computed属性</p>
<pre><code class="language-vue">&lt;script setup&gt;
    import {computed} from &quot;vue&quot;
    const porps = defineProps(['username','avatar'])
    const myname = computed(()=&gt;props.username+&quot;@&quot;)
&lt;/script&gt;

</code></pre>
<blockquote>
<h2 id="注意事项">注意事项</h2>
<p><code>props</code>传递数据，只能从父级传递到子级，不能反其道而行。</p>
</blockquote>
<blockquote>
<p>功能：让组件接收外部传过来的数据。</p>
<ul>
<li>传递数据：<Demo name="xxx"/></li>
<li>接收数据：</li>
<li>props:['name']</li>
<li>props:{ name:Number}</li>
<li>props:{name:{type:String,required:true}}</li>
</ul>
<p>备注：props是只读的，Vue底层会检测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</p>
<p>温馨提示：</p>
<p>​				数据类型为数组或对象的时候，默认值需要返回工厂模式</p>
</blockquote>
<h2 id="224-自定义事件组件交互-emit">2.24、自定义事件组件交互 $emit</h2>
<figure data-type="image" tabindex="1"><img src="Vue%E7%AC%94%E8%AE%B0.assets/7c3f59a18f8c477bb72e87661916fc04_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="1.png" loading="lazy"></figure>
<p>子组件还可以向父组件触发事件：</p>
<pre><code class="language-vue">export default{
        // 声明触发的事件
        emits:['response'],
        created(){
            //带参数触发
            this.$emit(&quot;resonse&quot;,&quot;hello from child&quot;)
        }
}
</code></pre>
<p>this.$emit()的第一个参数是事件的名称。其他所有参数都将传递给事件监听器。</p>
<p>父组件：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;

  &lt;myComponent :title=&quot;title&quot; :age=&quot;age&quot; /&gt;
  &lt;p&gt;{{ message }}&lt;/p&gt;
  &lt;myComponent2 @onEvent=&quot;getDataHandle&quot; /&gt;
&lt;/template&gt;

&lt;script&gt;
import myComponent from &quot;./components/myComponents.vue&quot;
import myComponent2 from &quot;./components/myComponents2.vue&quot;

export default {
  name: 'App',
  data() {
    return {
      title: '我是一个标题',
      age: 20,
      message:&quot;&quot;
    }
  },

  methods:
  {
    getDataHandle(data) {
      console.log(data);
      this.message = data;
    }
  },
  components: {
    // myComponent,
    myComponent2,
  }
}
&lt;/script&gt;
</code></pre>
<p>子组件：</p>
<pre><code class="language-vue">&lt;template&gt;
    &lt;h3&gt;自定义事件传递数据&lt;/h3&gt;
    &lt;button @click=&quot;sendClickHandle&quot;&gt;点击传递&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
    name: &quot;myComponent2&quot;,
    props: {

    },
    data(){
        return {
            message:'我是MyComponent数据',
        }
    },
    methods:{
        sendClickHandle(){
            //参数1：字符串
            //参数2：传递的数据
            this.$emit(&quot;onEvent&quot;,this.message)
        }
    }
}
&lt;/script&gt;
</code></pre>
<h3 id="封装子组件父组件向子组件传值">封装子组件（父组件向子组件传值）</h3>
<p>1、父组件想要向子组件传值时，那么需要在子组件引入的地方绑定一个属性，属性值就是要传的数据，并且要在父组件中引入子组件。</p>
<p>2、子组件使用props属性接收父组件传递过来的值。</p>
<h3 id="vue3中子组件向父组件传递事件和值">Vue3中子组件向父组件传递事件和值</h3>
<p>在组件的模板表达式中，可以直接使用 $emit 方法触发自定义事件 (例如：在 v-on 的处理函数中)：</p>
<pre><code class="language-vue">&lt;!-- MyComponent --&gt;
&lt;button @click=&quot;$emit('someEvent')&quot;&gt;click me&lt;/button&gt;
</code></pre>
<p>父组件可以通过 <code>v-on</code> (缩写为 <code>@</code>) 来监听事件：</p>
<pre><code class="language-vue">&lt;MyComponent @some-event=&quot;callback&quot; /&gt;
</code></pre>
<p>例二、</p>
<p>父组件：</p>
<pre><code class="language-vue">&lt;template&gt;
	&lt;view&gt;
        父组件
    	&lt;xxm-child @add=&quot;onAdd&quot;&gt;&lt;/xxm-child&gt;
    &lt;/view&gt;
&lt;/template&gt;
&lt;script setup&gt;
    const onAdd = function(e){
        console.log(e)
    }
&lt;/script&gt;
</code></pre>
<p>子组件：</p>
<pre><code class="language-vue">&lt;template&gt;
&lt;view&gt;
    子组件
    &lt;button @click=&quot;$emit('add',Math.random())&quot;&gt;按钮&lt;/button&gt;
    &lt;/button&gt;
    &lt;/view&gt;
&lt;/template&gt;
</code></pre>
<p>子组件第二种写法：</p>
<pre><code class="language-vue">
&lt;template&gt;
&lt;view&gt;
    子组件
    &lt;button @click=&quot;onClick&quot;&gt;按钮&lt;/button&gt;
    &lt;/button&gt;
    &lt;/view&gt;
&lt;/template&gt;
&lt;script setup&gt;
	const emit = defineEmits(['add']);
    function onClick(){
        emit(&quot;add&quot;,Math.random());
    }
&lt;/script&gt;
</code></pre>
<h1 id="三-使用vue脚手架">三、使用Vue脚手架</h1>
<h2 id="全局事件总线globaleventbus">全局事件总线(GlobalEventBus)</h2>
<p>1、一种组件间通信的方式，适用于任意组件间通信</p>
<p>2、安装全局事件总线：</p>
<pre><code class="language-vue">new Vue({
  render: h =&gt; h(App),
  beforeCreate(){
    //安装全局事件总线 $bus就是当前应用的vm
    Vue.prototype.$bus = this
  },
  mounted(){
    console.log(Vue.prototype)
  }
}).$mount('#app')
</code></pre>
<p>3、使用事件总线：</p>
<ul>
<li>
<p>接收数据</p>
<ul>
<li>
<p>A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身。</p>
<ul>
<li>
<pre><code class="language-vue">methods:{

},
mounted(){
this.$bus.$on('xxx',demo)
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>提供数据：this.<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>u</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">bus.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord">.</span></span></span></span>emit('xxxx'，数据)</p>
</li>
</ul>
<p>4、最好在beforeDestory钩子中，用$off去解绑当前组件中用到的事件。</p>
<h1 id="局部注册组件">局部注册组件</h1>
<pre><code class="language-vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;script src=&quot;js/vue-2.7.14.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        父组件
{{name}}
        &lt;Demo&gt;&lt;/Demo&gt;
    &lt;/div&gt;
    &lt;script&gt;
        //创建子组件
        const Demo = {
            template: `
            &lt;div&gt;
                &lt;h1&gt;{{msg}}&lt;/h1&gt;
                &lt;input type=&quot;text&quot; v-model=&quot;msg&quot;/&gt;
                &lt;input type=&quot;button&quot; @click=&quot;showMsg&quot; value=&quot;点我呀&quot;&gt;
            &lt;/div&gt;
                `,
            methods: {
                showMsg() {
                    alert(this.msg)
                }
            },
            data: function () {
                return {
                    msg: &quot;哈哈哈哈&quot;
                }
            }
        }
        var vm = new Vue({
            el: &quot;#app&quot;,
            data: {
                name:'武沛齐'
            },
            components: {
                Demo,
            }
        })
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<h1 id="全局注册组件">全局注册组件</h1>
<pre><code class="language-vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;script src=&quot;js/vue-2.7.14.js&quot;&gt;&lt;/script&gt;

&lt;/head&gt;

&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        父组件{{name}}
        &lt;Demo&gt;&lt;/Demo&gt;
    &lt;/div&gt;
    &lt;script&gt;
        //创建子组件
        Vue.component('Demo',
            {
                template: `
&lt;div&gt;
    &lt;h1&gt;{{msg}}&lt;/h1&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;msg&quot;/&gt;
    &lt;input type=&quot;button&quot; @click=&quot;showMsg&quot; value=&quot;点我呀&quot;&gt;
&lt;/div&gt;
    `,
                methods: {
                    showMsg() {
                        alert(this.msg)
                    }
                },
                data: function () {
                    return {
                        msg: &quot;哈哈哈哈&quot;
                    }
                }
            })

        var vm = new Vue({
            el: &quot;#app&quot;,
            data: {
                name: '武沛齐'
            },
            components:{
            }
        })
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<h2 id="组件生命周期">组件生命周期</h2>
<p>创建时：beforeCreate,created</p>
<p>渲染时：beforeMount,mounted</p>
<p>更新时：beforeUpdate，updated</p>
<p>卸载时：beforeUnmount，unmounted</p>
<figure data-type="image" tabindex="2"><img src="F:%5Cgithub%5Clearning-vue%5C%E7%AC%94%E8%AE%B0%5CVue%E7%AC%94%E8%AE%B0.assets%5Cfac3eb0428254a8fa204489c58ea5764.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="四-vue中的ajax">四、Vue中的ajax</h1>
<h2 id="41-解决开发环境ajax跨域问题">4.1 解决开发环境Ajax跨域问题</h2>
<h3 id="axios网络请求">Axios网络请求</h3>
<h4 id="安装">安装</h4>
<pre><code>npm install --save axios
</code></pre>
<h4 id="引入">引入</h4>
<p>组件中引入：import axios from &quot;axios&quot;</p>
<p>post请求</p>
<blockquote>
<p>post请求的参数需要额外的处理</p>
<p>安装依赖：npm install --save querystring</p>
<p>转换格式：qs.stringify({})</p>
</blockquote>
<h2 id="42-github用户搜索案例">4.2 github用户搜索案例</h2>
<h2 id="43-vue项目中常用的2个ajax库">4.3 vue项目中常用的2个Ajax库</h2>
<h2 id="44-slot插槽">4.4 slot插槽</h2>
<p>在某些场景中，我们可能想要为组件传递一些模板片段，让自组件在它们的组件中渲染这些片段。</p>
<blockquote>
<p>插槽</p>
</blockquote>
<ul>
<li>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于父组件====&gt;子组件</li>
<li>分类：默认插槽、具名插槽、作用域插槽</li>
</ul>
<h4 id="举例">举例</h4>
<p>父组件中使用子组件<FancyButton>组件：</p>
<pre><code>&lt;FancyButton&gt;
  Click me! &lt;!-- 插槽内容 --&gt;
&lt;/FancyButton&gt;
</code></pre>
<p>而 <code>&lt;FancyButton&gt;</code> 的模板是这样的：</p>
<pre><code class="language-vue">&lt;button class=&quot;fancy-btn&quot;&gt;
  &lt;slot&gt;&lt;/slot&gt; &lt;!-- 插槽出口 --&gt;
&lt;/button&gt;
</code></pre>
<p><code>&lt;slot&gt;</code> 元素是一个<strong>插槽出口</strong> (slot outlet)，标示了父元素提供的<strong>插槽内容</strong> (slot content) 将在哪里被渲染。</p>
<figure data-type="image" tabindex="3"><img src="F:%5Cgithub%5Clearning-vue%5C%E7%AC%94%E8%AE%B0%5CVue%E7%AC%94%E8%AE%B0.assets%5Cslots.inBPF2Hb.png" alt="插槽图示" loading="lazy"></figure>
<p>最终渲染出的 DOM 是这样：</p>
<pre><code>&lt;button class=&quot;fancy-btn&quot;&gt;Click me!&lt;/button&gt;
</code></pre>
<h4 id="默认内容">默认内容</h4>
<pre><code>&lt;button type=&quot;submit&quot;&gt;
  &lt;slot&gt;
    Submit &lt;!-- 默认内容 --&gt;
  &lt;/slot&gt;
&lt;/button&gt;
</code></pre>
<h4 id="具名插槽">具名插槽</h4>
<pre><code class="language-vue">&lt;div class=&quot;container&quot;&gt;
  &lt;header&gt;
    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;
  &lt;/header&gt;
  &lt;main&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/main&gt;
  &lt;footer&gt;
    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;
  &lt;/footer&gt;
&lt;/div&gt;
</code></pre>
<p>在父组件中使用 <code>&lt;BaseLayout&gt;</code> 时，我们需要一种方式将多个插槽内容传入到各自目标插槽的出口。此时就需要用到<strong>具名插槽</strong>了：</p>
<p>要为具名插槽传入内容，我们需要使用一个含 <code>v-slot</code> 指令的 <code>&lt;template&gt;</code> 元素，并将目标插槽的名字传给该指令：</p>
<p>template</p>
<pre><code>&lt;BaseLayout&gt;
  &lt;template v-slot:header&gt;
    &lt;!-- header 插槽的内容放这里 --&gt;
  &lt;/template&gt;
&lt;/BaseLayout&gt;
</code></pre>
<p><code>v-slot</code> 有对应的简写 <code>#</code>，因此 <code>&lt;template v-slot:header&gt;</code> 可以简写为 <code>&lt;template #header&gt;</code>。其意思就是“将这部分模板片段传入子组件的 header 插槽中”。</p>
<figure data-type="image" tabindex="4"><img src="F:%5Cgithub%5Clearning-vue%5C%E7%AC%94%E8%AE%B0%5CVue%E7%AC%94%E8%AE%B0.assets%5Cnamed-slots.giG_TKP2.png" alt="具名插槽图示" loading="lazy"></figure>
<p>下面我们给出完整的、向 <code>&lt;BaseLayout&gt;</code> 传递插槽内容的代码，指令均使用的是缩写形式：</p>
<pre><code>&lt;BaseLayout&gt;
  &lt;template #header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
  &lt;/template&gt;

  &lt;template #default&gt;
    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
    &lt;p&gt;And another one.&lt;/p&gt;
  &lt;/template&gt;

  &lt;template #footer&gt;
    &lt;p&gt;Here's some contact info&lt;/p&gt;
  &lt;/template&gt;
&lt;/BaseLayout&gt;
</code></pre>
<h3 id="uni-app中对request的封装">uni-app中对request的封装</h3>
<p>在untils目录中创建文件request.js</p>
<pre><code class="language-javascript">const BASE_URL = &quot;https://tea.qingnian8.com/api/bizhi&quot;

//使用Promise()方法封装了uni-app的uni.request方法
export function request(config = {}) {
	//resolve 成功  reject 失败
	return new Promise((resolve, reject) =&gt; {
		let {
			url,
			method = &quot;GET&quot;,
			header = {},
			data = {}
		} = config;

		url = BASE_URL + url;
		uni.request({
			url,
			data,
			method,
			header,
			//成功后的回调
			success: res =&gt; {
				if (res.data.errCode == 0) {
					resolve(res.data);
				} else if (res.data.errCode === 400) {
					uni.showModal({
						title: &quot;错误提示&quot;,
						content: res.data.errMsg,
						showCancel: false
					})
					reject(res.data.data)
				} else {
					uni.showModal({
						title: res.data.errMsg,
						icon: &quot;none&quot;,
					});
					rejct(res.data.data);
				}
			},
			//失败后的回调
			fail: err =&gt; {
				reject(err);
			}
		})
	})
}
</code></pre>
<p>再在apis.js中封装一层</p>
<pre><code class="language-javascript">import {
	request
} from &quot;@/utils/request.js&quot;
export function apiGetBanner() {
	return request({
		url: &quot;/homeBanner&quot;,
		method: 'GET'
	});
};
</code></pre>
<p>使用</p>
<pre><code class="language-javascript">import {apiGetSetupScore} from '@/api/apis.js'
//确认评分
const submitScore = async () =&gt; {
    console.log(userScore.value);
    console.log(userScore);

    let {classid,_id:wallId} = currentInfo.value;

    let res = await apiGetSetupScore({
        classid,
        wallId,
        userScore:userScore.value
    });
    if (res.errCode === 0){
        uni.showToast({
            title:&quot;评分成功&quot;,
            icon:'none'
        });
        picList.value[currentIndex.value].userScore = userScore.value;
        uni.setStorageSync(&quot;storageClissList&quot;,picList.value);
        clickScoreClose();
    }
    console.log(res);
};
</code></pre>
<h1 id="五-vuex">五、vuex</h1>
<h2 id="51-理解vuex">5.1 理解vuex</h2>
<h3 id="511-vuex是什么">5.1.1 vuex是什么</h3>
<p>1、概念：专门在Vue中实现集中式状态（数据）管理的一个Vue插件，对Vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。</p>
<h3 id="512-什么时候使用vuex">5.1.2 什么时候使用Vuex</h3>
<ul>
<li>多个组件依赖于同一状态</li>
<li>来自不同组件的行为需要变更同一状态</li>
</ul>
<h3 id="513-搭建vuex环境">5.1.3 搭建vuex环境</h3>
<ul>
<li>
<p>创建文件 src/store/index.js</p>
<ul>
<li>
<pre><code class="language-vue">//该文件用于创建Vuex中最为核心的store

//引入Vuex
import Vuex from 'vuex'
//引入Vue
import Vue from 'vue'

//应用Vuex插件
Vue.use(Vuex)

//响应组件中的动作
const actions = {

}
//操作数据
const mutations = {

}
//用于存储数据
const sate = {

}

//创建store
const store = new Vuex.Store({
    actions,
    mutations,
    sate
})

//暴露store
export default store
</code></pre>
</li>
<li>
<p>在main.js中创建vm时传入store配置项</p>
<ul>
<li>
<pre><code>//引入sotre
import store from './store'

//创建vm
new Vue({
el:&quot;#app&quot;,
render:h=&gt;h(App),
store
})
</code></pre>
</li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="六-vue-router">六、vue-router</h1>
<h2 id="61基本使用">6.1基本使用</h2>
<ul>
<li>
<p>安装vue-router，命令：npm i vue-router</p>
</li>
<li>
<p>应用插件 Vue.use(VueRouter)</p>
</li>
<li>
<p>编写router配置项</p>
<ul>
<li>
<pre><code>//该文件专门用来创建整个应用的路由器
import VueRouter from 'vue-router'

//引入组件
import About from '../components/About'
import  Home from '../components/Home'

//创建一个路由器
const router = new VueRouter({
    routes:[
        {
            path:'/about',
            component:About,
        },
        {
            path:'/home',
            component:Home,
        },
    ]
})

//暴露router
export default router
</code></pre>
</li>
</ul>
</li>
<li>
<p>实现切换（active-class可配置高亮样式）</p>
<ul>
<li><router-link active-class="active" to='/about'>About</router-link></li>
<li>指定展示位置 <router-view></router-view></li>
</ul>
</li>
</ul>
<h2 id="62-几个注意点">6.2 几个注意点</h2>
<ul>
<li>路由组件通常存放在pages文件夹，一般组件存放在components文件夹</li>
<li>通过切换，’隐藏‘了路由组件，默认是被销毁掉的，需要的时候再去挂载。</li>
<li>每个组件都有自己的$route属性，里面存储着自己的路由信息</li>
<li>整个应用只有一个router，可以通过组件的$router属性获取到。</li>
</ul>
<h3 id="63-多级路由">6.3 多级路由</h3>
<p>1、配置路由规则，使用children配置项：</p>
<pre><code>routes:[
        {
            path:'/about',
            component:About,
        },
        {
            path:'/home',
            component:Home,
            children:[   //通过children配置子级路由
                {
                    path:'news', //此处一定不要写 /news
                    component:News
                },
                {
                    path:'message',
                    component:Message
                },

            ]
        },

</code></pre>
<p>2、跳转（要写完整路径）</p>
<pre><code>
&lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;
</code></pre>
<h3 id="64-路由传参-query参数">6.4 路由传参  query参数</h3>
<p>1、传递参数</p>
<pre><code>  &lt;!-- 跳转路由并携带query参数 to字符串写法 --&gt;
        &lt;!-- &lt;router-link :to=&quot;`/home/message/detail?id=${m.id}&amp;title=${m.title}`&quot;&gt;{{ m.title }}&lt;/router-link&gt; --&gt;
        
        &lt;!-- 跳转路由并携带query参数 to对象写法 --&gt;
        &lt;router-link :to=&quot;{
            path:'/home/message/detail',
            query:{
                id:m.id,
                title:m.title
            }
        }&quot;&gt;
            {{ m.title }}
        &lt;/router-link&gt;
</code></pre>
<p>2、接收参数：</p>
<pre><code>$route.query.id
$route.query.title
</code></pre>
<h3 id="vue中ref和reative区别">Vue中ref和reative区别？</h3>
<p>在 Vue 中，<code>ref</code> 和 <code>reactive</code> 都是用于创建响应式数据的工具，但它们之间存在一些关键的区别。</p>
<ol>
<li><strong>数据类型和应用场景</strong>：
<ul>
<li><code>ref</code> 主要用于包装 JavaScript 的基本类型数据（如字符串、数字、布尔值等），以及对象。当 <code>ref</code> 用于包装对象时，其内部实际上会通过 <code>reactive</code> 将其转换为代理对象。</li>
<li><code>reactive</code> 则主要用于包装 JavaScript 的对象和数组等复杂类型的数据。如果你尝试使用 <code>reactive</code> 来包装一个基本类型的数据，Vue 会提示你错误，除非你将其包裹在一个对象中。</li>
</ul>
</li>
<li><strong>使用方式和访问方式</strong>：
<ul>
<li>使用 <code>ref</code> 创建的响应式数据在模板中可以通过直接引用变量名访问，但在 JavaScript 代码中需要通过 <code>.value</code> 属性来访问其实际值。例如，<code>const count = ref(0);</code> 在模板中可以直接使用 <code>{{ count }}</code>，但在方法中需要使用 <code>count.value</code>。</li>
<li>使用 <code>reactive</code> 创建的响应式对象则可以直接访问其属性或调用其方法，无需额外的 <code>.value</code> 属性。</li>
</ul>
</li>
<li><strong>响应式实现机制</strong>：
<ul>
<li><code>ref</code> 是通过 <code>Object.defineProperty()</code> 的 <code>get</code> 和 <code>set</code> 方法来实现响应式的。</li>
<li><code>reactive</code> 则是通过 ES6 的 <code>Proxy</code> 对象来实现响应式的，并通过 <code>Reflect</code> 操作源对象内部的数据。</li>
</ul>
</li>
<li><strong>设计理念</strong>：
<ul>
<li><code>ref</code> 的设计主要是为了解决单一元素/数据的响应式问题。</li>
<li><code>reactive</code> 的设计则是为了解决 JavaScript 对象和数组等复杂数据结构的响应式问题。</li>
</ul>
</li>
</ol>
<p>总的来说，<code>ref</code> 和 <code>reactive</code> 在 Vue 中各有其适用场景和优势。对于基本类型的数据，通常使用 <code>ref</code>；而对于复杂的数据结构，如对象和数组，则更倾向于使用 <code>reactive</code>。同时，它们的实现机制和设计理念也反映了 Vue 对于不同类型数据的处理方式。</p>
<h1 id=""></h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端项目框架 目录]]></title>
        <id>https://yuzhupeng.top/myblogs/post/qian-duan-xiang-mu-kuang-jia-mu-lu/</id>
        <link href="https://yuzhupeng.top/myblogs/post/qian-duan-xiang-mu-kuang-jia-mu-lu/">
        </link>
        <updated>2025-07-28T07:28:57.000Z</updated>
        <content type="html"><![CDATA[<p>前端项目框架包含了路由：svelte-spa-router 样式：less tailwind 国际化：svelte-i18n 接口请求：axios 环境变量配置:.env 组件库：melt-ui 图标库：iconfont 轮播图：swiper node:20.18.1 npm 10.8.2</p>
<blockquote>
<p><strong>框架太“重”了</strong>：通常一个小型项目只由少数几个简单页面构成，如果使用 Vue 或者 React 这些框架来研发的话，有点“大材小用”了。构建的产物中包含了不少框架运行时代码(虚拟 DOM、响应式、状态管理等)，这些代码对于小型项目而言是冗余的，它们影响了包体大小，进而影响页面的启动速度和执行性能。<br>
<strong>打包太慢了</strong>：以 Vue CLI 为例，它的底层基于 Webpack，虽然 Webpack 具备更强大的功能和灵活性，但相比于 Vite、Esbuild 这些以速度为标杆的构建工具来说，它的速度确实慢了一些，影响了研发效率。</p>
</blockquote>
<p>@</p>
<p>目录</p>
<ul>
<li>
<p><a href="#%E4%B8%80-%E5%88%9B%E5%BB%BA%E5%9F%BA%E6%9C%AC%E9%A1%B9%E7%9B%AE">一、 创建基本项目</a></p>
<ul>
<li><a href="#11-%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85-vite">1.1 全局安装 Vite</a></li>
<li><a href="#12-%E5%88%9B%E5%BB%BA-svelte-%E9%A1%B9%E7%9B%AE">1.2 创建 Svelte 项目</a></li>
</ul>
</li>
<li>
<p><a href="#%E4%BA%8C%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84">二、目录结构</a></p>
</li>
<li>
<p><a href="#%E4%B8%89svelte%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE">三、svelte路由配置</a></p>
<ul>
<li>
<p><a href="#31-npm%E5%AE%89%E8%A3%85">3.1 npm安装</a></p>
</li>
<li>
<p><a href="#32-%E5%AE%9A%E4%B9%89router">3.2 定义router</a></p>
<ul>
<li><a href="#321-%E5%8A%A8%E6%80%81%E5%AF%BC%E5%85%A5%E7%BB%84%E4%BB%B6">3.2.1 动态导入组件</a></li>
<li><a href="#322-%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E5%AF%BC%E8%88%AA">3.2.2 在页面之间导航</a></li>
</ul>
</li>
<li>
<p><a href="#33-%E4%BD%BF%E7%94%A8%E8%B7%AF%E7%94%B1">3.3 使用路由</a></p>
</li>
</ul>
</li>
<li>
<p><a href="#%E5%9B%9Bsvelte-css%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8">四、svelte CSS预处理器</a></p>
<ul>
<li><a href="#41-less%E7%9A%84%E4%BD%BF%E7%94%A8">4.1 less的使用</a>
<ul>
<li><a href="#411-npm%E5%AE%89%E8%A3%85">4.1.1 npm安装</a></li>
</ul>
</li>
<li><a href="#42-tailwind-css%E7%9A%84%E4%BD%BF%E7%94%A8">4.2 Tailwind CSS的使用</a></li>
</ul>
</li>
<li>
<p><a href="#%E4%BA%94svelte%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE">五、svelte环境变量配置</a></p>
<ul>
<li><a href="#51-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99">5.1 环境变量命名规则</a></li>
<li><a href="#52-env%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8">5.2 .env文件的使用</a></li>
<li><a href="#53-%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">5.3 在代码中使用环境变量</a></li>
<li><a href="#54-%E9%85%8D%E7%BD%AE%E8%BF%90%E8%A1%8C%E4%B8%8E%E6%89%93%E5%8C%85%E7%8E%AF%E5%A2%83">5.4 配置运行与打包环境</a></li>
</ul>
</li>
<li>
<p><a href="#%E5%85%ADsvelte%E5%9B%BD%E9%99%85%E5%8C%96">六、svelte国际化</a></p>
<ul>
<li><a href="#61-%E5%AE%89%E8%A3%85-svelte-i18n">6.1 安装 <code>svelte-i18n</code></a></li>
<li><a href="#62-%E5%88%9D%E5%A7%8B%E5%8C%96-svelte-i18n">6.2 初始化 <code>svelte-i18n</code></a></li>
<li><a href="#63-%E5%88%9B%E5%BB%BA%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6">6.3 创建语言文件</a></li>
<li><a href="#64-%E5%9C%A8-svelte-%E7%BB%84%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8-svelte-i18n">6.4 在 Svelte 组件中使用 <code>svelte-i18n</code></a></li>
<li><a href="#65-%E5%88%87%E6%8D%A2%E8%AF%AD%E8%A8%80">6.5 切换语言</a></li>
<li><a href="#66-%E5%9C%A8-appsvelte-%E4%B8%AD%E5%BC%95%E5%85%A5-i18njs">6.6 在 <code>App.svelte</code> 中引入 <code>i18n.js</code></a></li>
<li><a href="#67-%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE">6.7 运行项目</a></li>
<li><a href="#68-%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE">6.8 构建项目</a></li>
<li><a href="#69-%E9%A2%84%E8%A7%88%E9%A1%B9%E7%9B%AE">6.9 预览项目</a></li>
<li><a href="#610-%E6%A3%80%E6%9F%A5%E9%A1%B9%E7%9B%AE">6.10 检查项目</a></li>
</ul>
</li>
<li>
<p><a href="#%E4%B8%83svelte%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82">七、svelte接口请求</a></p>
<ul>
<li><a href="#71-%E5%AE%89%E8%A3%85-axios">7.1 安装 <code>axios</code></a></li>
<li><a href="#72-%E5%88%9B%E5%BB%BA-axios-%E5%AE%9E%E4%BE%8B">7.2 创建 <code>axios</code> 实例</a></li>
<li><a href="#73-%E5%9C%A8-svelte-%E7%BB%84%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8-axios">7.3 在 Svelte 组件中使用 <code>axios</code></a></li>
<li><a href="#74-%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E6%8B%A6%E6%88%AA%E5%99%A8">7.4 处理请求和响应拦截器</a></li>
<li><a href="#75-%E5%9C%A8-appsvelte-%E4%B8%AD%E4%BD%BF%E7%94%A8-axios">7.5 在 <code>App.svelte</code> 中使用 <code>axios</code></a></li>
<li><a href="#76-%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF">7.6 处理错误</a></li>
</ul>
</li>
<li>
<p><a href="#%E5%85%ABsvelte%E7%BB%84%E4%BB%B6%E5%BA%93">八、svelte组件库</a></p>
</li>
<li>
<p><a href="#%E4%B9%9Dsvelte%E9%98%BF%E9%87%8C%E5%9B%BE%E6%A0%87%E5%BA%93">九、svelte阿里图标库</a></p>
<ul>
<li><a href="#91-%E8%8E%B7%E5%8F%96%E9%98%BF%E9%87%8C%E5%9B%BE%E6%A0%87">9.1 获取阿里图标</a></li>
<li><a href="#92-%E5%B0%86%E5%9B%BE%E6%A0%87%E6%96%87%E4%BB%B6%E6%94%BE%E5%85%A5%E9%A1%B9%E7%9B%AE">9.2 将图标文件放入项目</a></li>
<li><a href="#93-%E5%BC%95%E5%85%A5%E5%9B%BE%E6%A0%87%E6%96%87%E4%BB%B6">9.3 引入图标文件</a></li>
<li><a href="#94-%E4%BD%BF%E7%94%A8%E5%9B%BE%E6%A0%87">9.4 使用图标</a></li>
<li><a href="#95-%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2%E5%9B%BE%E6%A0%87">9.5 动态切换图标</a></li>
<li><a href="#96-%E4%BD%BF%E7%94%A8-symbol-%E6%96%B9%E5%BC%8F%E5%8F%AF%E9%80%89">9.6 使用 Symbol 方式（可选）</a></li>
<li><a href="#97-%E6%A0%B7%E5%BC%8F%E8%B0%83%E6%95%B4%E5%8F%AF%E9%80%89">9.7 样式调整（可选）</a></li>
<li><a href="#98-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">9.8 示例代码</a></li>
</ul>
</li>
<li>
<p><a href="#%E5%8D%81svelte%E8%BD%AE%E6%92%AD%E5%9B%BE">十、svelte轮播图</a></p>
</li>
<li>
<p><a href="#%E5%8D%81%E4%B8%80store%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB">十一、store数据共享</a></p>
<ul>
<li><a href="#1-%E5%88%9B%E5%BB%BA-store-%E6%A8%A1%E5%9D%97">1. 创建 <code>store</code> 模块</a></li>
<li><a href="#2-%E5%88%9B%E5%BB%BA%E5%85%A8%E5%B1%80-store">2. 创建全局 <code>store</code></a></li>
<li><a href="#3-%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8-store">3. 在组件中使用 <code>store</code></a></li>
<li><a href="#4-%E5%B0%81%E8%A3%85-store-%E7%9A%84%E4%BC%98%E5%8A%BF">4. 封装 <code>store</code> 的优势</a></li>
<li><a href="#5-%E7%A4%BA%E4%BE%8Baboutsvelte-%E4%B8%AD%E4%BD%BF%E7%94%A8-store">5. 示例：<code>about.svelte</code> 中使用 <code>store</code></a></li>
</ul>
</li>
<li>
<p><a href="#%E5%8D%81%E4%BA%8C%E6%89%A9%E5%B1%95%E5%86%85%E5%AE%B9">十二、扩展内容</a></p>
</li>
<li>
<p><a href="#%E5%8D%81%E4%B8%89%E6%A1%86%E6%9E%B6git%E5%9C%B0%E5%9D%80">十三、框架git地址</a></p>
</li>
</ul>
<h2 id="一-创建基本项目">一、 创建基本项目</h2>
<h3 id="11-全局安装-vite">1.1 全局安装 Vite</h3>
<p>通过 npm 全局安装 Vite</p>
<pre><code class="language-mipsasm">npm install vite 
</code></pre>
<h3 id="12-创建-svelte-项目">1.2 创建 Svelte 项目</h3>
<p>Vite 原生支持直接通过脚手架创建 Svelte 项目，执行以下命令</p>
<pre><code class="language-sql">npm create vite@latest
</code></pre>
<p>输入命令后选择如下</p>
<pre><code class="language-vhdl">✔ Project name: vite-svelte

? Select a framework: › - Use arrow-keys. Return to submit.
    Vanilla
    Vue
    React
    Preact
    Lit
❯   Svelte
    Solid
    Qwik
    Others

? Select a variant: › - Use arrow-keys. Return to submit.
    TypeScript
❯   JavaScript
    SvelteKit
</code></pre>
<p><strong>基本项目创建完成</strong></p>
<h2 id="二-目录结构">二、目录结构</h2>
<p>根据上一步创建项目，项目的基本结构栓是完成了，但这样还是不够的，接下来介绍一下完整的项目目录<br>
<img src="https://i-blog.csdnimg.cn/direct/faa1d82a4f50487caa9e5c9baa137743.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="三-svelte路由配置">三、svelte路由配置</h2>
<h3 id="31-npm安装">3.1 npm安装</h3>
<p>项目中安装svelte-spa-router</p>
<pre><code class="language-mipsasm">npm install svelte-spa-router
</code></pre>
<h3 id="32-定义router">3.2 定义router</h3>
<ul>
<li>每条路由都是一个普通的Svelte组件，包含标记、脚本、绑定等。任何Svelte组件都可以是路由。</li>
<li>路由定义只是一个JavaScript字典（对象），其中键是一个带有路径（包括参数等）的字符串，值是路由对象。</li>
</ul>
<pre><code class="language-javascript">import Home from './routes/Home.svelte'
import Author from './routes/Author.svelte'
import Book from './routes/Book.svelte'
import NotFound from './routes/NotFound.svelte'

const routes = {
    // Exact path
    '/': Home,

    // Using named parameters, with last being optional
    '/author/:first/:last?': Author,

    // Wildcard parameter
    '/book/*': Book,

    // Catch-all
    // This is optional, but if present it must be the last
    '*': NotFound,
}
</code></pre>
<h4 id="321-动态导入组件">3.2.1 动态导入组件</h4>
<p>使用动态导入的优点是，如果您的打包器支持，您可以启用代码拆分并减小发送给用户的捆绑包的大小。这已经用包括Rollup和Webpack在内的捆绑器进行了测试</p>
<ol>
<li>要使用动态导入的组件，您需要利用包装方法（根据路线包装文档，该方法可用于各种操作）。首先，导入wrap方法：</li>
</ol>
<pre><code class="language-javascript">import {wrap} from 'svelte-spa-router/wrap'
</code></pre>
<ol start="2">
<li>然后，在路由定义中，使用wrap方法包装路由，将一个函数传递给asyncComponent属性，该函数将动态导入的组件返回给asyncComponent：</li>
</ol>
<pre><code class="language-haskell">wrap({
    asyncComponent: () =&gt; import('./Foo.svelte')
})
</code></pre>
<p>案例：</p>
<pre><code class="language-javascript">// Import the wrap method
import {wrap} from 'svelte-spa-router/wrap'

// Note that Author and Book are not imported here anymore, so they can be imported at runtime
import Home from './routes/Home.svelte'
import NotFound from './routes/NotFound.svelte'

const routes = {
    '/': Home,

    // Wrapping the Author component
    '/author/:first/:last?': wrap({
        asyncComponent: () =&gt; import('./routes/Author.svelte')
    }),

    // Wrapping the Book component
    '/book/*': wrap({
        asyncComponent: () =&gt; import('./routes/Book.svelte')
    }),

    // Catch-all route last
    '*': NotFound,
}
</code></pre>
<h4 id="322-在页面之间导航">3.2.2 在页面之间导航</h4>
<ol>
<li>锚点导航</li>
</ol>
<pre><code class="language-xml">&lt;a href=&quot;#/book/123&quot;&gt;Thus Spoke Zarathustra&lt;/a&gt;
</code></pre>
<ol start="2">
<li>use:link导航（可以使用use：link操作，而不必在每个链接前键入#）</li>
</ol>
<pre><code class="language-xml">&lt;script&gt;
import {link} from 'svelte-spa-router'
&lt;/script&gt;
&lt;a href=&quot;/book/321&quot; use:link&gt;The Little Prince&lt;/a&gt;
</code></pre>
<h3 id="33-使用路由">3.3 使用路由</h3>
<p>在app.svelte中全局调用</p>
<pre><code class="language-javascript">import Router from 'svelte-spa-router'
</code></pre>
<p>然后，通过将组件放置在标记中，将路由器显示在您想要的任何位置</p>
<pre><code class="language-xml">&lt;body&gt;
    &lt;Router {routes}/&gt;
&lt;/body&gt;
</code></pre>
<h2 id="四-svelte-css预处理器">四、svelte CSS预处理器</h2>
<h3 id="41-less的使用">4.1 less的使用</h3>
<h4 id="411-npm安装">4.1.1 npm安装</h4>
<p>安装less与svelte-preprocess-less依赖</p>
<pre><code class="language-cmake">npm install --save-dev svelte-preprocess-less less
</code></pre>
<p>在vite.config.js进行配置</p>
<pre><code class="language-javascript">import { less } from 'svelte-preprocess-less'
export default defineConfig({
    plugins: [svelte({
        preprocess: {
          style: less(),
        },
      })],
})
</code></pre>
<h3 id="42-tailwind-css的使用">4.2 Tailwind CSS的使用</h3>
<p>通过npx安装直接配置完 tailwindcss</p>
<pre><code class="language-csharp">npx sv add tailwindcss
</code></pre>
<h2 id="五-svelte环境变量配置">五、svelte环境变量配置</h2>
<p>‌Vite中使用环境变量主要通过.env文件来配置，这些文件根据不同的环境（开发、测试、生产等）有不同的命名规则和使用方式。</p>
<h3 id="51-环境变量命名规则">5.1 环境变量命名规则</h3>
<p>所有环境变量必须以VITE_为前缀</p>
<pre><code class="language-ini">VITE_API_URL=https://api.example.com
VITE_APP_TITLE=My Vite App
</code></pre>
<h3 id="52-env文件的使用">5.2 .env文件的使用</h3>
<p>1‌. <strong>通用环境变量‌</strong>：在项目的根目录下创建.env文件，用于定义所有环境通用的变量。<br>
2‌. <strong>特定环境变量‌</strong>：根据不同的环境需求，可以创建以下类型的.env文件：<br>
.env.devt：仅在开发环境中使用。<br>
.env.pro：仅在生产环境中使用。<br>
.env.local：通用的本地配置文件，通常不提交到版本控制系统中。<br>
.env.development.local：开发环境的本地配置文件。<br>
.env.production.local：生产环境的本地配置文件‌</p>
<h3 id="53-在代码中使用环境变量">5.3 在代码中使用环境变量</h3>
<pre><code class="language-cpp">console.log(import.meta.env.VITE_API_URL);
</code></pre>
<h3 id="54-配置运行与打包环境">5.4 配置运行与打包环境</h3>
<pre><code class="language-json">  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;vite --mode dev&quot;,//运行dev环境
    &quot;dev-pro&quot;: &quot;vite --mode pro&quot;,//运行pro环境
    &quot;build&quot;: &quot;vite build&quot;,
    &quot;preview&quot;: &quot;vite preview&quot;,
    &quot;check&quot;: &quot;svelte-check --tsconfig ./tsconfig.app.json &amp;&amp; tsc -p tsconfig.node.json&quot;
  },
</code></pre>
<h2 id="六-svelte国际化">六、svelte国际化</h2>
<p><code>svelte-i18n</code> 是一个用于 Svelte 应用的国际化（i18n）库，它可以帮助你轻松地管理和切换应用中的多语言内容。以下是如何在 Svelte 项目中使用 <code>svelte-i18n</code> 的基本步骤：</p>
<h3 id="61-安装-svelte-i18n">6.1 安装 <code>svelte-i18n</code></h3>
<p>首先，确保你已经安装了 <code>svelte-i18n</code>。根据你的 <code>package.json</code> 文件，它已经存在于 <code>dependencies</code> 中。</p>
<pre><code class="language-bash">npm install svelte-i18n
</code></pre>
<h3 id="62-初始化-svelte-i18n">6.2 初始化 <code>svelte-i18n</code></h3>
<p>在你的 Svelte 项目中，通常会在 <code>src</code> 目录下创建一个 <code>i18n.js</code> 或 <code>i18n.ts</code> 文件来初始化 <code>svelte-i18n</code>。</p>
<pre><code class="language-javascript">// src/i18n.js
import { init, register, locale } from 'svelte-i18n';

// 注册默认语言
register('en', () =&gt; import('./locales/en.json'));
register('zh', () =&gt; import('./locales/zh.json'));

// 初始化并设置默认语言
init({
  fallbackLocale: 'en',
  initialLocale: 'en',
});
</code></pre>
<h3 id="63-创建语言文件">6.3 创建语言文件</h3>
<p>在 <code>src/locales</code> 目录下创建语言文件，例如 <code>en.json</code> 和 <code>zh.json</code>。</p>
<pre><code class="language-json">// src/locales/en.json
{
  &quot;welcome&quot;: &quot;Welcome to Svelte App&quot;,
  &quot;greeting&quot;: &quot;Hello, {name}!&quot;
}
</code></pre>
<pre><code class="language-json">// src/locales/zh.json
{
  &quot;welcome&quot;: &quot;欢迎使用 Svelte 应用&quot;,
  &quot;greeting&quot;: &quot;你好, {name}!&quot;
}
</code></pre>
<h3 id="64-在-svelte-组件中使用-svelte-i18n">6.4 在 Svelte 组件中使用 <code>svelte-i18n</code></h3>
<p>你可以在 Svelte 组件中使用 <code>$t</code> 函数来获取翻译内容。</p>
<pre><code class="language-svelte">&lt;script&gt;
  import { t } from 'svelte-i18n';
&lt;/script&gt;

&lt;h1&gt;{$t('welcome')}&lt;/h1&gt;
&lt;p&gt;{$t('greeting', { name: 'John' })}&lt;/p&gt;
</code></pre>
<h3 id="65-切换语言">6.5 切换语言</h3>
<p>你可以通过 <code>locale.set</code> 方法来动态切换语言。</p>
<pre><code class="language-svelte">&lt;script&gt;
  import { locale } from 'svelte-i18n';
&lt;/script&gt;

&lt;button on:click={() =&gt; locale.set('en')}&gt;English&lt;/button&gt;
&lt;button on:click={() =&gt; locale.set('zh')}&gt;中文&lt;/button&gt;
</code></pre>
<h3 id="66-在-appsvelte-中引入-i18njs">6.6 在 <code>App.svelte</code> 中引入 <code>i18n.js</code></h3>
<ol>
<li>确保在 <code>App.svelte</code> 或你的主入口文件中引入 <code>i18n.js</code>。</li>
</ol>
<pre><code class="language-svelte">&lt;script&gt;
  import './i18n.js';
&lt;/script&gt;
</code></pre>
<ol start="2">
<li>确保加载完i18n后在加载页面</li>
</ol>
<pre><code class="language-App.svelte">&lt;script&gt;
  import { locale } from &quot;svelte-i18n&quot;;
  import Router from &quot;@/router/Router.svelte&quot;;
&lt;/script&gt;
{#if $locale}
  &lt;Layout&gt;
    &lt;Router /&gt;
  &lt;/Layout&gt;
{/if}
</code></pre>
<h3 id="67-运行项目">6.7 运行项目</h3>
<p>使用 <code>npm run dev</code> 运行你的项目，你应该能够看到国际化内容并根据按钮切换语言。</p>
<h3 id="68-构建项目">6.8 构建项目</h3>
<p>当你准备好发布项目时，使用 <code>npm run build</code> 来构建项目。</p>
<pre><code class="language-bash">npm run build
</code></pre>
<h3 id="69-预览项目">6.9 预览项目</h3>
<p>使用 <code>npm run preview</code> 来预览构建后的项目。</p>
<pre><code class="language-bash">npm run preview
</code></pre>
<h3 id="610-检查项目">6.10 检查项目</h3>
<p>使用 <code>npm run check</code> 来检查 Svelte 和 TypeScript 的类型。</p>
<pre><code class="language-bash">npm run check
</code></pre>
<p>通过以上步骤，你应该能够在 Svelte 项目中成功使用 <code>svelte-i18n</code> 来实现国际化功能。</p>
<h2 id="七-svelte接口请求">七、svelte接口请求</h2>
<p>在 Svelte 项目中使用 <code>axios</code> 进行 HTTP 请求是非常常见的操作。以下是如何在 Svelte 项目中集成和使用 <code>axios</code> 的步骤：</p>
<h3 id="71-安装-axios">7.1 安装 <code>axios</code></h3>
<p>首先，确保你已经安装了 <code>axios</code>。根据你的 <code>package.json</code> 文件，它已经存在于 <code>dependencies</code> 中。</p>
<pre><code class="language-bash">npm install axios
</code></pre>
<h3 id="72-创建-axios-实例">7.2 创建 <code>axios</code> 实例</h3>
<p>为了更好的管理和配置 <code>axios</code>，通常会在 <code>src/utils</code> 目录下创建一个 <code>api.ts</code> 或 <code>api.js</code> 文件来创建 <code>axios</code> 实例。</p>
<pre><code class="language-typescript">// src/utils/api.ts
import axios from 'axios';

const api = axios.create({
  baseURL: 'https://api.example.com', // 你的 API 基础 URL
  timeout: 10000, // 请求超时时间
  headers: {
    'Content-Type': 'application/json',
  },
});

export default api;
</code></pre>
<h3 id="73-在-svelte-组件中使用-axios">7.3 在 Svelte 组件中使用 <code>axios</code></h3>
<p>你可以在 Svelte 组件中导入并使用 <code>axios</code> 实例来发送 HTTP 请求。</p>
<pre><code class="language-svelte">&lt;script lang=&quot;ts&quot;&gt;
  import api from '@/utils/api';
  import { onMount } from 'svelte';

  let data: any;

  onMount(async () =&gt; {
    try {
      const response = await api.get('/endpoint');
      data = response.data;
    } catch (error) {
      console.error('Error fetching data:', error);
    }
  });
&lt;/script&gt;

{#if data}
  &lt;div&gt;
    &lt;h1&gt;{data.title}&lt;/h1&gt;
    &lt;p&gt;{data.description}&lt;/p&gt;
  &lt;/div&gt;
{/if}
</code></pre>
<h3 id="74-处理请求和响应拦截器">7.4 处理请求和响应拦截器</h3>
<p>你可以在 <code>axios</code> 实例中添加请求和响应拦截器，以便在请求发送前或响应到达后进行一些处理。</p>
<pre><code class="language-typescript">// src/utils/api.ts
import axios from 'axios';

const api = axios.create({
  baseURL: 'https://api.example.com',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// 请求拦截器
api.interceptors.request.use(
  (config) =&gt; {
    // 在请求发送之前做一些处理，例如添加 token
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) =&gt; {
    return Promise.reject(error);
  }
);

// 响应拦截器
api.interceptors.response.use(
  (response) =&gt; {
    // 对响应数据做一些处理
    return response;
  },
  (error) =&gt; {
    // 对响应错误做一些处理
    return Promise.reject(error);
  }
);

export default api;
</code></pre>
<h3 id="75-在-appsvelte-中使用-axios">7.5 在 <code>App.svelte</code> 中使用 <code>axios</code></h3>
<p>你可以在 <code>App.svelte</code> 中使用 <code>axios</code> 来获取数据或执行其他 HTTP 操作。</p>
<pre><code class="language-svelte">&lt;script lang=&quot;ts&quot;&gt;
  import api from '@/utils/api';
  import { onMount } from 'svelte';

  let userData: any;

  onMount(async () =&gt; {
    try {
      const response = await api.get('/user');
      userData = response.data;
    } catch (error) {
      console.error('Error fetching user data:', error);
    }
  });
&lt;/script&gt;

{#if userData}
  &lt;div&gt;
    &lt;h1&gt;Welcome, {userData.name}!&lt;/h1&gt;
    &lt;p&gt;Email: {userData.email}&lt;/p&gt;
  &lt;/div&gt;
{/if}
</code></pre>
<h3 id="76-处理错误">7.6 处理错误</h3>
<p>在使用 <code>axios</code> 时，确保你处理了可能的错误，例如网络错误或服务器错误。</p>
<pre><code class="language-svelte">&lt;script lang=&quot;ts&quot;&gt;
  import api from '@/utils/api';
  import { onMount } from 'svelte';

  let userData: any;
  let errorMessage: string | null = null;

  onMount(async () =&gt; {
    try {
      const response = await api.get('/user');
      userData = response.data;
    } catch (error) {
      errorMessage = 'Failed to fetch user data. Please try again later.';
      console.error('Error fetching user data:', error);
    }
  });
&lt;/script&gt;

{#if userData}
  &lt;div&gt;
    &lt;h1&gt;Welcome, {userData.name}!&lt;/h1&gt;
    &lt;p&gt;Email: {userData.email}&lt;/p&gt;
  &lt;/div&gt;
{:else if errorMessage}
  &lt;p style=&quot;color: red;&quot;&gt;{errorMessage}&lt;/p&gt;
{/if}
</code></pre>
<p>通过以上步骤，你应该能够在 Svelte 项目中成功使用 <code>axios</code> 来进行 HTTP 请求。</p>
<h2 id="八-svelte组件库">八、svelte组件库</h2>
<p>这里用的是melt-ui，访问地址是：<a href="https://www.melt-ui.com/docs/introduction">https://www.melt-ui.com/docs/introduction</a><br>
一键配置</p>
<pre><code class="language-kotlin">npx @melt-ui/cli@latest init
</code></pre>
<h2 id="九-svelte阿里图标库">九、svelte阿里图标库</h2>
<p>在 Svelte 项目中使用阿里图标（如 <a href="https://www.iconfont.cn/">iconfont</a>）可以通过以下步骤实现：</p>
<hr>
<h3 id="91-获取阿里图标">9.1 获取阿里图标</h3>
<ol>
<li>访问 <a href="https://www.iconfont.cn/">iconfont</a> 并登录。</li>
<li>创建一个项目，将需要的图标添加到项目中。</li>
<li>选择 <code>Font class</code> 或 <code>Symbol</code> 方式生成代码。</li>
<li>点击 <code>下载至本地</code>，解压后得到图标文件。</li>
</ol>
<hr>
<h3 id="92-将图标文件放入项目">9.2 将图标文件放入项目</h3>
<p>将下载的图标文件（如 <code>iconfont.css</code> 和字体文件）放入项目的 <code>public</code> 或 <code>src/assets</code> 目录中。</p>
<p>例如：</p>
<pre><code class="language-cpp">public/
  iconfont/
    iconfont.css
    iconfont.ttf
    iconfont.woff
    iconfont.woff2
</code></pre>
<hr>
<h3 id="93-引入图标文件">9.3 引入图标文件</h3>
<p>在 <code>App.svelte</code> 或 <code>main.ts</code> 中引入 <code>iconfont.css</code> 文件。</p>
<pre><code class="language-svelte">&lt;script lang=&quot;ts&quot;&gt;
  import &quot;./app.css&quot;;
  import Layout from &quot;@/layout/Layout.svelte&quot;;
  import Router from &quot;@/router/Router.svelte&quot;;
  import { locale } from &quot;svelte-i18n&quot;;
  import Toast from &quot;./components/Toast.svelte&quot;;
  import { toast } from &quot;@/utils/toastService&quot;;

  // 引入阿里图标
  import '../public/iconfont/iconfont.css';
&lt;/script&gt;
</code></pre>
<hr>
<h3 id="94-使用图标">9.4 使用图标</h3>
<p>在 Svelte 组件中使用阿里图标，直接通过 <code>class</code> 引用图标类名。</p>
<pre><code class="language-svelte">&lt;div&gt;
  &lt;i class=&quot;iconfont icon-home&quot;&gt;&lt;/i&gt; &lt;!-- icon-home 是图标类名 --&gt;
  &lt;i class=&quot;iconfont icon-user&quot;&gt;&lt;/i&gt; &lt;!-- icon-user 是图标类名 --&gt;
&lt;/div&gt;
</code></pre>
<hr>
<h3 id="95-动态切换图标">9.5 动态切换图标</h3>
<p>如果需要动态切换图标，可以将图标类名绑定到变量。</p>
<pre><code class="language-svelte">&lt;script lang=&quot;ts&quot;&gt;
  let iconClass = 'icon-home';
&lt;/script&gt;

&lt;div&gt;
  &lt;i class={`iconfont ${iconClass}`}&gt;&lt;/i&gt;
  &lt;button on:click={() =&gt; iconClass = 'icon-user'}&gt;切换图标&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<hr>
<h3 id="96-使用-symbol-方式可选">9.6 使用 Symbol 方式（可选）</h3>
<p>如果选择 <code>Symbol</code> 方式，需要引入 <code>iconfont.js</code> 文件，并使用 <code>&lt;svg&gt;</code> 标签。</p>
<pre><code class="language-svelte">&lt;script lang=&quot;ts&quot;&gt;
  import '../public/iconfont/iconfont.js';
&lt;/script&gt;

&lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt;
  &lt;use xlink:href=&quot;#icon-home&quot;&gt;&lt;/use&gt; &lt;!-- #icon-home 是图标 ID --&gt;
&lt;/svg&gt;
</code></pre>
<hr>
<h3 id="97-样式调整可选">9.7 样式调整（可选）</h3>
<p>如果需要调整图标大小或颜色，可以通过 CSS 设置。</p>
<pre><code class="language-svelte">&lt;style lang=&quot;less&quot;&gt;
  .iconfont {
    font-size: 24px;
    color: #333;
  }
&lt;/style&gt;
</code></pre>
<hr>
<h3 id="98-示例代码">9.8 示例代码</h3>
<p>以下是一个完整的示例：</p>
<pre><code class="language-svelte">&lt;script lang=&quot;ts&quot;&gt;
  import &quot;./app.css&quot;;
  import Layout from &quot;@/layout/Layout.svelte&quot;;
  import Router from &quot;@/router/Router.svelte&quot;;
  import { locale } from &quot;svelte-i18n&quot;;
  import Toast from &quot;./components/Toast.svelte&quot;;
  import { toast } from &quot;@/utils/toastService&quot;;

  // 引入阿里图标
  import '../public/iconfont/iconfont.css';

  let iconClass = 'icon-home';
&lt;/script&gt;

{#if $locale}
  &lt;Layout&gt;
    &lt;Router /&gt;
  &lt;/Layout&gt;
  {#if $toast.visible}
    &lt;Toast message={$toast.message} /&gt;
  {/if}
{/if}

&lt;div&gt;
  &lt;i class={`iconfont ${iconClass}`}&gt;&lt;/i&gt;
  &lt;button on:click={() =&gt; iconClass = 'icon-user'}&gt;切换图标&lt;/button&gt;
&lt;/div&gt;

&lt;style lang=&quot;less&quot;&gt;
  .iconfont {
    font-size: 24px;
    color: #333;
  }
&lt;/style&gt;
</code></pre>
<hr>
<p>通过以上步骤，你可以在 Svelte 项目中成功使用阿里图标。如果需要更多定制化功能，可以参考 <a href="https://www.iconfont.cn/help/detail?spm=a313x.7781069.1998910419.d8d11a391&amp;helptype=code">iconfont 官方文档</a>。</p>
<h2 id="十-svelte轮播图">十、svelte轮播图</h2>
<p>这里用的是https://3.swiper.com.cn/<br>
下载引入相关css与js即可<br>
demo如下</p>
<pre><code class="language-xml">&lt;script&gt;
    import { onMount } from 'svelte';
    import  '@/utils/swiper/swiper.min.js';
    import '@/utils/swiper/swiper.min.css';
    let swiperInstance;
    onMount(() =&gt; {
      // 初始化 Swiper
      swiperInstance = new Swiper('.swiper-container', {
        pagination: '.swiper-pagination',
        paginationClickable: true,
        autoplay:2500,
        loop:true
      });
    });
  &lt;/script&gt;
  
  &lt;style&gt;
   html, body {
        position: relative;
        height: 100%;
    }
    body {
        background: #eee;
        font-family: Helvetica Neue, Helvetica, Arial, sans-serif;
        font-size: 14px;
        color:#000;
        margin: 0;
        padding: 0;
    }
    .swiper-container {
        width: 100%;
        height: 350px;
    }
    .swiper-slide {
        text-align: center;
        font-size: 18px;
        background: #fff;

        /* Center slide text vertically */
        display: -webkit-box;
        display: -ms-flexbox;
        display: -webkit-flex;
        display: flex;
        -webkit-box-pack: center;
        -ms-flex-pack: center;
        -webkit-justify-content: center;
        justify-content: center;
        -webkit-box-align: center;
        -ms-flex-align: center;
        -webkit-align-items: center;
        align-items: center;
    }
  &lt;/style&gt;
  
 &lt;!-- Swiper --&gt;
 &lt;div class=&quot;swiper-container&quot;&gt;
  &lt;div class=&quot;swiper-wrapper&quot;&gt;
      &lt;div class=&quot;swiper-slide&quot;&gt;Slide 1&lt;/div&gt;
      &lt;div class=&quot;swiper-slide&quot;&gt;Slide 2&lt;/div&gt;
  &lt;/div&gt;
  &lt;!-- Add Pagination --&gt;
  &lt;div class=&quot;swiper-pagination&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h2 id="十一-store数据共享">十一、store数据共享</h2>
<p>在 Svelte 中，<code>store</code> 是一个核心概念，用于管理应用的状态。为了更好地组织代码，可以将 <code>store</code> 封装为模块，包括 <code>state</code>、<code>actions</code>、<code>getters</code> 和 <code>mutations</code>，类似于 Vuex 或 Redux 的设计模式。以下是如何封装 <code>store</code> 的示例：</p>
<hr>
<h3 id="1-创建-store-模块">1. 创建 <code>store</code> 模块</h3>
<p>在 <code>src/store</code> 目录下创建一个模块，例如 <code>centerStore.ts</code>，用于管理特定模块的状态和逻辑。</p>
<pre><code class="language-typescript">// src/store/centerStore.ts
import { writable, derived } from 'svelte/store';

// State
const state = writable({
  userData: null,
  loading: false,
  error: null,
});

// Actions
const actions = {
  async getUserData(params: { onlyMakeTheSame: boolean }) {
    try {
      state.update((s) =&gt; ({ ...s, loading: true, error: null }));
      // 模拟 API 调用
      const response = await fetch('/api/user', { method: 'GET' });
      const data = await response.json();
      state.update((s) =&gt; ({ ...s, userData: data, loading: false }));
    } catch (error) {
      state.update((s) =&gt; ({ ...s, error: error.message, loading: false }));
    }
  },
};

// Getters
const getters = {
  userData: derived(state, ($state) =&gt; $state.userData),
  isLoading: derived(state, ($state) =&gt; $state.loading),
  error: derived(state, ($state) =&gt; $state.error),
};

// Mutations (可选)
const mutations = {
  setUserData(userData: any) {
    state.update((s) =&gt; ({ ...s, userData }));
  },
};

// 导出模块
export const centerStore = {
  state,
  actions,
  getters,
  mutations,
};
</code></pre>
<hr>
<h3 id="2-创建全局-store">2. 创建全局 <code>store</code></h3>
<p>在 <code>src/store/index.ts</code> 中整合所有模块，创建一个全局 <code>store</code>。</p>
<pre><code class="language-typescript">// src/store/index.ts
import { centerStore } from './centerStore';

export const store = {
  center: centerStore,
};
</code></pre>
<hr>
<h3 id="3-在组件中使用-store">3. 在组件中使用 <code>store</code></h3>
<p>在 Svelte 组件中导入并使用 <code>store</code>。</p>
<pre><code class="language-svelte">&lt;script lang=&quot;ts&quot;&gt;
  import { store } from '@/store/index';
  import { onMount } from 'svelte';

  // 获取 state 和 getters
  const { state, getters } = store.center;

  // 调用 action
  function fetchData() {
    store.center.actions.getUserData({ onlyMakeTheSame: false });
  }

  onMount(() =&gt; {
    fetchData();
  });
&lt;/script&gt;

{#if $getters.isLoading}
  &lt;p&gt;Loading...&lt;/p&gt;
{:else if $getters.error}
  &lt;p style=&quot;color: red;&quot;&gt;Error: {$getters.error}&lt;/p&gt;
{:else if $getters.userData}
  &lt;div&gt;
    &lt;h1&gt;User Data&lt;/h1&gt;
    &lt;pre&gt;{JSON.stringify($getters.userData, null, 2)}&lt;/pre&gt;
  &lt;/div&gt;
{/if}

&lt;button on:click={fetchData}&gt;Refresh Data&lt;/button&gt;
</code></pre>
<hr>
<h3 id="4-封装-store-的优势">4. 封装 <code>store</code> 的优势</h3>
<ul>
<li><strong>模块化</strong>：将状态和逻辑按模块划分，便于维护和扩展。</li>
<li><strong>复用性</strong>：<code>actions</code> 和 <code>getters</code> 可以在多个组件中复用。</li>
<li><strong>可测试性</strong>：<code>actions</code> 和 <code>mutations</code> 可以单独测试。</li>
<li><strong>清晰性</strong>：<code>state</code>、<code>actions</code>、<code>getters</code> 和 <code>mutations</code> 分离，代码结构更清晰。</li>
</ul>
<hr>
<h3 id="5-示例aboutsvelte-中使用-store">5. 示例：<code>about.svelte</code> 中使用 <code>store</code></h3>
<p>根据你的 <code>about.svelte</code> 文件，可以这样使用 <code>store</code>：</p>
<pre><code class="language-svelte">&lt;script lang=&quot;ts&quot;&gt;
  import { t, locale } from &quot;svelte-i18n&quot;;
  import { toast } from '@/utils/toastService';
  import { store } from '@/store/index';

  function getData() {
    store.center.actions.getUserData({ onlyMakeTheSame: false });
  }
&lt;/script&gt;

&lt;h1&gt;{$t(&quot;welcome&quot;)}&lt;/h1&gt;
&lt;p&gt;{$t(&quot;about&quot;)}&lt;/p&gt;

&lt;button on:click={getData}&gt;获取接口数据&lt;/button&gt;

{#if $store.center.getters.isLoading}
  &lt;p&gt;Loading...&lt;/p&gt;
{:else if $store.center.getters.error}
  &lt;p style=&quot;color: red;&quot;&gt;Error: {$store.center.getters.error}&lt;/p&gt;
{:else if $store.center.getters.userData}
  &lt;div&gt;
    &lt;h1&gt;User Data&lt;/h1&gt;
    &lt;pre&gt;{JSON.stringify($store.center.getters.userData, null, 2)}&lt;/pre&gt;
  &lt;/div&gt;
{/if}
</code></pre>
<hr>
<p>通过以上步骤，你可以在 Svelte 项目中封装 <code>store</code>，并实现 <code>state</code>、<code>actions</code>、<code>getters</code> 和 <code>mutations</code> 的分离，使代码更易于维护和扩展。</p>
<h2 id="十二-扩展内容">十二、扩展内容</h2>
<p>这里由于使用的melt-ui没有toast提示于是做了一个全局组建toas.svelte</p>
<ol>
<li>组建创建</li>
</ol>
<pre><code class="language-xml">&lt;script&gt;
  import { fade } from &quot;svelte/transition&quot;;
  export let message = &quot;&quot;;
  export let duration = 3000; // 持续时间，单位毫秒

  let visible = false;

  const showToast = () =&gt; {
    visible = true;
    setTimeout(() =&gt; {
      visible = false;
    }, duration);
  };

  showToast(); // 显示Toast
&lt;/script&gt;

{#if visible}
  &lt;div class=&quot;toast&quot; transition:fade&gt;
    {message}
  &lt;/div&gt;
{/if}

&lt;style&gt;
  .toast {
    position: fixed;
    top: 300px;
    left: 50%;
    transform: translateX(-50%);
    padding: 10px 20px;
    background-color: #333;
    color: white;
    border-radius: 5px;
    z-index: 1000;
  }
&lt;/style&gt;
</code></pre>
<ol start="2">
<li>toastService封装</li>
</ol>
<pre><code class="language-javascript">import { writable } from 'svelte/store';
function createToast() {
  const { subscribe, set, update } = writable({ message: '', visible: false });
 
  function show(message, duration = 3000) {
    set({ message, visible: true });
    setTimeout(() =&gt; {
      update(current =&gt; ({ ...current, visible: false }));
    }, duration);
  }
 
  return {
    subscribe,
    show, // 公开show方法供外部调用
  };
}
 
export const toast = createToast(); // 创建并导出toast服务实例
</code></pre>
<ol start="3">
<li>全局调用app.svelte</li>
</ol>
<pre><code class="language-xml">&lt;script lang=&quot;ts&quot;&gt;

  import Toast from &quot;./components/Toast.svelte&quot;;
  import { toast } from &quot;@/utils/toastService&quot;;
&lt;/script&gt;
  {#if $toast.visible}
    &lt;!-- 使用$来访问store的值 --&gt;
    &lt;Toast message={$toast.message} /&gt;
    &lt;!-- 将消息传递给Toast组件 --&gt;
  {/if}
</code></pre>
<ol start="4">
<li>使用</li>
</ol>
<pre><code class="language-javascript">  import { toast } from '@/utils/toastService';
  toast.show('Hello, this is a toast!')
</code></pre>
<h2 id="十三-框架git地址">十三、框架git地址</h2>
<p><a href="https://gitee.com/cyp926/svelte-vite">https://gitee.com/cyp926/svelte-vite</a></p>
<figure data-type="image" tabindex="1"><a href="https://www.doubao.com?channel=cnblogs&amp;source=hw_db_cnblogs&amp;type=lunt&amp;theme=bianc"><img src="https://img2024.cnblogs.com/blog/35695/202506/35695-20250620221033642-784432140.webp" alt="" loading="lazy"></a></figure>
<p><strong>相关博文：</strong>\</p>
<p>·  <a href="https://www.cnblogs.com/ypSharing/p/17129546.html" title="10分钟了解MVVM，实现简易MVVM">10分钟了解MVVM，实现简易MVVM</a></p>
<p>·  <a href="https://www.cnblogs.com/ypSharing/p/15817954.html" title="微信小程序---快速上手云开发">微信小程序---快速上手云开发</a></p>
<p>·  <a href="https://www.cnblogs.com/SRIGT/p/18406806" title="Svelte">Svelte</a></p>
<p>·  <a href="https://www.cnblogs.com/Dollom/p/17048043.html" title="svelte使用总结">svelte使用总结</a></p>
<p>·  <a href="https://www.cnblogs.com/yayujs/p/18768477" title="SvelteKit 最新中文文档教程（1）—— 入门指南">SvelteKit 最新中文文档教程（1）—— 入门指南</a></p>
<p><strong>阅读排行：</strong><br>
· <a href="https://www.cnblogs.com/Can-daydayup/p/19006888">推荐 6 款基于 .NET 开源的串口调试工具，调试效率提升利器！</a><br>
· <a href="https://www.cnblogs.com/xueweihan/p/19006999">《HelloGitHub》第 112 期</a><br>
· <a href="https://www.cnblogs.com/sdcb/p/19005634/llm-json-hard">大模型的JSON之殇：从脆弱的API调用到稳健的未来</a><br>
· <a href="https://www.cnblogs.com/yuxl01/p/18092437">Abp vNext -动态 C# API 实现原理解析</a><br>
· <a href="https://www.cnblogs.com/12lisu/p/19008591">千万级的大表如何新增字段？</a></p>
<ul>
<li>
<p><a href="https://www.cnblogs.com/ypSharing/tag/react%E7%9B%B8%E5%85%B3/">react相关(11)</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/ypSharing/tag/vue3.0/">vue3.0(8)</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/ypSharing/tag/vue%E7%9B%B8%E5%85%B3/">vue相关(6)</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/ypSharing/tag/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86%E4%B8%8E%E8%A7%A3%E9%87%8A/">前端问题处理与解释(6)</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/ypSharing/tag/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化(6)</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/ypSharing/tag/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序(5)</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/ypSharing/tag/linux/">linux(4)</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/ypSharing/tag/js%E7%9B%B8%E5%85%B3/">js相关(4)</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/ypSharing/tag/%E6%A1%88%E4%BE%8B/">案例(4)</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/ypSharing/tag/%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/">插件使用(3)</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/ypSharing/tag/">更多</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/ypSharing/p/vue-webpack.html">1. vue.config.js中的webpack配置，优化及多页面应用开发(11360)</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/ypSharing/p/updataHandler.html">2. 8种Vue中数据更新了但页面没有更新的情况(10506)</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/ypSharing/p/corsHanlder.html">3. 九种实用的前端跨域处理方案(8257)</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/ypSharing/p/16082614.html">4. 前端-文件上传几种方式及其核心思想(5848)</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/ypSharing/p/viteHandler.html">5. Vite详解(4508)</a></p>
</li>
</ul>
<h3 id="推荐排行榜"><a href="https://www.cnblogs.com/ypSharing/most-liked">推荐排行榜</a></h3>
<ul>
<li><a href="https://www.cnblogs.com/ypSharing/p/corsHanlder.html">1. 九种实用的前端跨域处理方案(6)</a></li>
<li><a href="https://www.cnblogs.com/ypSharing/p/piniaShare.html">2. 23年用vuex进行状态管理out了，都开始用pinia啦！(5)</a></li>
<li><a href="https://www.cnblogs.com/ypSharing/p/16082614.html">3. 前端-文件上传几种方式及其核心思想(5)</a></li>
<li><a href="https://www.cnblogs.com/ypSharing/p/15304219.html">4. Vue3.x全家桶+vite+TS-搭建Vue3.x项目(4)</a></li>
<li><a href="https://www.cnblogs.com/ypSharing/p/vue-webpack.html">5. vue.config.js中的webpack配置，优化及多页面应用开发(4)</a></li>
</ul>
<!--end: sideBarMain -->
<!--end: sideBar 侧边栏容器 -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何快速优化几千万数据量的订单表]]></title>
        <id>https://yuzhupeng.top/myblogs/post/ru-he-kuai-su-you-hua-ji-qian-wan-shu-ju-liang-de-ding-dan-biao/</id>
        <link href="https://yuzhupeng.top/myblogs/post/ru-he-kuai-su-you-hua-ji-qian-wan-shu-ju-liang-de-ding-dan-biao/">
        </link>
        <updated>2025-07-28T07:03:29.000Z</updated>
        <content type="html"><![CDATA[<hr>
<ul>
<li><a href="#%E5%9C%BA%E6%99%AF">场景</a></li>
<li><a href="#%E6%95%B4%E4%BD%93%E6%96%B9%E6%A1%88">整体方案</a></li>
<li><a href="#tid-rAbepm">    1、数据库分区</a></li>
<li><a href="#tid-NCbzW7">    2、迂回方案</a></li>
<li><a href="#tid-f4dGtT">    3、冷热分离</a></li>
<li><a href="#tid-hGXAPA">        1）、基本概念</a></li>
<li><a href="#tid-wF33ze">        2）、存储方案</a></li>
<li><a href="#tid-xJKRfj">        3）、区分冷热数据</a></li>
<li><a href="#tid-kmbMna">        4）、如何冷热分离</a></li>
<li><a href="#tid-CM6y5s">    4、最终方案</a></li>
<li><a href="#%E4%BC%98%E7%BC%BA%E7%82%B9">优缺点</a></li>
<li><a href="#tid-eGxeij">    1、优点</a></li>
<li><a href="#tid-KsRGSN">        1）、提高性能</a></li>
<li><a href="#tid-ckXiyP">        2）、降低成本</a></li>
<li><a href="#tid-BYQwka">        3）、简化维护</a></li>
<li><a href="#tid-ERdt5P">    2、缺点</a></li>
<li><a href="#tid-bpYsAd">        1）、场景限制多</a></li>
<li><a href="#tid-jY3KMw">        2）、统计效率低</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
<h3 id="场景">场景</h3>
<p>本篇分享以前在一家公司工作时遇到的状况及解决方案，这家公司有一个项目是SOA的架构，这个架构那几年是很流行的，哪怕是现在我依然认为这个理念在当时比较先进。</p>
<p>我在这家公司待的时间不长，但因为平台不错，确实学习和实践了一点东西，所以整理一下分享给大家。</p>
<p>当时的项目背景大概是这样，这家公司用的是某软提供的方案（这公司贼喜欢提供方案且要钱多，忍不住吐槽哈），项目已经运行3年多，整体稳定。</p>
<blockquote>
<p>数据库是MySQL，订单表的数据量已经达到3000多万条记录，并且随着项目的推广，最近那一年订单表数据量也在快速增长。</p>
<p>结果就是，客户方查询订单相关的业务时速度越来越慢，后期不论打开还是刷新都差不多要七八秒。</p>
</blockquote>
<p>可以说已经严重影响了客户体验，降低了对方日常办事的效率，要求我们尽快解决，且敦促我们这是一件优先级非常高的事情。</p>
<p>在客户和公司领导的双重压力下，如何快速优化几千万数据的订单表，对于当时的团队着实是一个难题摆在面前。</p>
<p>我依稀记得自己当时还比较青涩，更多的是一个听众，不敢参与深入讨论哈哈。</p>
<h3 id="整体方案">整体方案</h3>
<p>首先常规方案能想到的无非是这些：<code>增加合理的数据库索引、优化核心SQL语句、优化代码等</code>。</p>
<p>我这里可以告诉大家，一般的IT公司，但凡团队Leader是个有经验的人，这些基础方案都是会提前做的，会对项目上线后可能遇到的瓶颈有个基本的评估，因为真正运营周期变长以后，数据量逐渐增多，修改生产库是一种风险操作。</p>
<blockquote>
<p>我不知道大家有没有过给某个生产库数据量比较大的表添加字段或索引的经历，而且是在白天上班操作，或者说你自己见过别人这么干，我只能说……这些都是狠人，要对其常怀敬畏之心。</p>
</blockquote>
<p>我目前所在的公司就比较规范，研发人员建表时一定要提交申请走流程，且附带合理的索引，一起提交审核，最终通过了才能由主管审核执行。</p>
<p>至于这种流程怎么走，其实工具挺多，我这里就提一个用过的开源项目：<code>Yearning</code>，大家可以自己去了解下。</p>
<blockquote>
<p>话题扯回来，正因前面所讲，在当前的问题下，这些基础方案实际上已经存在，在这里显然是用不上了，加上紧急问题紧急处理，没有那么多时间给你去对既有架构大动干戈。</p>
</blockquote>
<p>因此，当时立马能想到且有效的临时性方案迅速在团队讨论中率先冒出来，就是<code>数据库分区</code>。</p>
<h4 id="1-数据库分区">1、数据库分区</h4>
<p>理解数据库分区，只需要记住以下两点：</p>
<ul>
<li>数据库分区是把一张表的数据<code>分在了不同的硬盘</code>上，但仍是一张表，说硬盘可能不完全准确，但就这样理解是最容易的。</li>
<li>不要把数据库分区和分库分表混淆，一个是<code>数据库级别</code>的操作，一个是<code>代理工具</code>的操作，前者限制较多，后者更灵活。</li>
</ul>
<p>知道这两点其实就足够了，数据库分区和分库分表也是面试中喜欢问的，因为确实有一些类似的地方。</p>
<p>好了，有了基本认识，那接下来就说下数据库分区如何操作的，先看个图有个画面。</p>
<figure data-type="image" tabindex="1"><a href="https://img2023.cnblogs.com/blog/1755845/202312/1755845-20231218095715678-232136391.png"><img src="https://img2023.cnblogs.com/blog/1755845/202312/1755845-20231218095715678-232136391.png" alt="" loading="lazy"></a></figure>
<p>接着举个示例，我们假设有一张订单表，那么对这张订单表<code>按照年份进行分区</code>的命令如下：</p>
<p>**</p>
<pre><code class="language-sql">-- 创建订单表
CREATE TABLE orders (
    id INT PRIMARY KEY AUTO_INCREMENT,
    order_number VARCHAR(20),
    order_date DATE,
    customer_id INT,
    total_amount DECIMAL(10, 2)
);

-- 按照年份对订单表进行分区
ALTER TABLE orders
PARTITION BY RANGE(YEAR(order_date)) (
    PARTITION p2018 VALUES LESS THAN (2019),
    PARTITION p2019 VALUES LESS THAN (2020),
    PARTITION p2020 VALUES LESS THAN (2021),
    PARTITION p2021 VALUES LESS THAN (2022),
    PARTITION p2022 VALUES LESS THAN (2023),
    PARTITION p2023 VALUES LESS THAN (2024)
);
</code></pre>
<p>这样一来，数据库就会将这张表的数据<code>按照YEAR(order_date)的值分别存在 p2018 ~ p2023 这6个分区中</code>。</p>
<p>如果结合本篇的问题，3000多万条记录，那么按照年份分区，大概一个分区是1000万记录左右，然后可以优化查询语句只去扫描特定的分区，是不是一下就轻松了很多。</p>
<p>再深入点，按照年份一个分区1000万还是有点多了，我们是不是可以找到一个更合理的分区字段，让每个分区的数据更少呢？</p>
<p>这里就要<code>结合实际业务</code>了，没有真正的通用方案。</p>
<p>你要先明确一点，做分区的目的，最终是为了让某个业务环节的查询更快，就比如本篇这里，主要是为了让客户查询订单相关业务更快，那么你就要先把这块的查询语句摘取出来，<code>分析一下里面的where条件有哪些</code>。</p>
<ul>
<li>
<p>比如，客户要查询某个或某些状态的订单，可能会这样写：where order_status in (?)；</p>
</li>
<li>
<p>比如，客户要查询某个特定群体的订单，可能会这样写：where user_flag_id = ?；</p>
</li>
<li>
<p>比如，客户要查询某个或多个业务类型的订单，可能会这样写：where order_type in (?)；</p>
</li>
</ul>
<p>甚至，还可能有其他的组合条件掺杂进来，你千万别以为你去的每个公司都把表设计的很漂亮很合理，我这么多年工作下来，真见过不少奇葩设计，订单表里面能给你塞上openId或者某些单纯为了方便而加的冗余字段，完全把订单表自身的功能性打碎。</p>
<blockquote>
<p>这个时候，如果分区字段本身存在，且刚好能把分区数据分的很合理，有利于查询，比如前面按照年份划分，每个分区如果只有两三百万记录，再结合本身的索引，查询就会很快，那么一切安好，搞完收工。</p>
<p>但如果分区字段很难定位，就像上面讲的，一些主要SQL语句的where条件并不包含相同的字段，那就头大了。</p>
</blockquote>
<p>而且MySQL还有一个需要注意的点，就是它的分区本身是有限制的。</p>
<blockquote>
<p>MySQL分区字段必须是唯一索引的一部分。</p>
</blockquote>
<p>也就是说，如果没有其他能用的唯一索引，我们只能结合主键ID，和分区字段组成<code>复合主键</code>才行。</p>
<p>这就更难了，纯粹看这表长什么样了。</p>
<p>话到这里，其实大家也看出来了，数据库分区的优缺点很明显。</p>
<blockquote>
<p>优点：遇到合适的场景，优化起来就是一个命令的事情。</p>
<p>缺点：限制太多，稍微复杂一点的场景你就很难定位分区字段。</p>
</blockquote>
<p>那么，真的就没法分了吗？其实还有一个迂回的方案。</p>
<h4 id="2-迂回方案">2、迂回方案</h4>
<p>我们可以在表中新增一个专门为了分区而量身定做的字段，比如archive_flag，表示一种数据<code>归档状态</code>，当<code>值为1时表示已归档，值为0时表示未归档</code>。</p>
<p>这个字段可以没有业务意义，但一定要有分区意义。</p>
<blockquote>
<p>我们可以把半年内的数据刷成 archive_flag=0，半年以外的数据刷成 archive_flag=1。</p>
<p>接下来，我们按照归档状态进行分区即可，半年内的活跃数据是一个分区，其他非活跃数据是一个分区。</p>
<p>最后，只需要把核心的查询语句where条件中都新增一个 archive_flag=0 就可以了，这样就会扫描这个非归档状态的分区，也就是活跃数据的分区。</p>
</blockquote>
<p>试想一下，这个分区只有半年的记录，按照本篇的场景，最多也就是500万了，结合自身表索引，已经完全可以解决当前存在的问题。</p>
<p>好了，这个迂回方案其实挺不错的，但一定有人会有疑问。</p>
<p>1）、加字段真的好吗？</p>
<p>2）、为什么一定要半年内的数据？</p>
<p>首先解答第一个问题，答案是不好，在我这里的话甚至可以说非常不好，几千万数据量的表，为了解决一个查询问题刻意新增一个没有实际意义的字段，是舍本逐末的行为，<code>如果除了这张表，还有其他表也有类似问题，难道每个都要加字段吗？显然是不可行，也是不安全的</code>。</p>
<p>第二个问题，半年内的数据完全可以结合实际业务做修改。</p>
<p>举个简单的例子，你如果经常逛京东商城购物，一定会打开我的订单看看，实际上给你展示的就是近3个月的订单，你可以理解成这就是非归档的活跃数据。</p>
<p>当你想查询以前的记录时，就会给你一个链接叫历史记录，点击后跳转到历史记录列表，或者通过其他方式如下拉框，让你选择其他更早时间的订单数据，这种其实就是已经归档的数据。</p>
<p>这些数据一般不会直接从业务表里查出来，而是从其他归档表，或者非关系型数据库如mongodb、EasticSearch等查询出来。</p>
<blockquote>
<p>这种方式就类似做了分区，把你经常访问的数据和访问频率较低的数据分布存储，达到一个数据分离的目的。</p>
</blockquote>
<p>这样你就懂了，数据分区大体就是这样的思考方式。</p>
<p>现在回过头来想想前面说的优缺点，数据库分区真的合适吗？</p>
<blockquote>
<p>实际情况下，很少有情况合适，主要原因还是前面讲过的，限制真的太多了，而业务往往又是复杂的。</p>
<p>另外，数据库分区对于很多程序员来说，其实是陌生的，在中小企业更是如此，有这样的现实摆在面前，加上短期内就要解决问题，随便使用的话对于团队来讲也是一种风险。</p>
</blockquote>
<p>所以，另一种更合理的方案也就呼之欲出了，<code>数据的冷热分离</code>。</p>
<h4 id="3-冷热分离">3、冷热分离</h4>
<p>前面讲了那么多，其实就是为了过渡到这里来，上面的迂回方案或多或少已经摸到了冷热分离的边缘，主要是为了让大家知其然并知其所以然。</p>
<h5 id="1-基本概念">1）、基本概念</h5>
<p>冷热分离听起来很高端，其实本质很简单，就是把<code>活跃数据</code>和<code>非活跃数据</code>区分开，一热一冷，频率高的查询只操作热数据，频率低的只操作冷数据。</p>
<figure data-type="image" tabindex="2"><a href="https://img2023.cnblogs.com/blog/1755845/202312/1755845-20231218095733906-900810354.png"><img src="https://img2023.cnblogs.com/blog/1755845/202312/1755845-20231218095733906-900810354.png" alt="" loading="lazy"></a></figure>
<h5 id="2-存储方案">2）、存储方案</h5>
<p>既然要分离，就要考虑清楚热数据和冷数据分别放在哪里。</p>
<p>这里我提供两种选择：</p>
<blockquote>
<p>中小企业，我推荐依然用MySQL。</p>
</blockquote>
<p>一来是不需要额外成本（降本增效？哈哈），二来是中小企业相对大厂，业务复杂度低一点且数据量小很多，那么此时完全可以用MySQL新增一张表来存储某个业务的冷数据，比如订单。</p>
<p>如果需要冷热分离的业务较多，也可以建一个单独的冷库，来专门存放冷数据，不过这种我也不太推荐，因为涉及到跨库查询，增加了维护难度，咱们程序员尽量对自己好一点哈。</p>
<p>一个项目里面，其实两三张冷表的出现已经可以处理核心业务数据冷热分离的问题了，如果真有那么多大数据的表，我觉得要从其他方面找问题了（一些老项目，设计上本身有问题，那是真的没好办法）。</p>
<blockquote>
<p>大厂，推荐HBase。</p>
</blockquote>
<p>大厂的资源较多，平台较大，冷热分离不单是解决这种问题的唯一方案，但大厂比较推荐更合适的数据库来存储这样的冷数据。</p>
<p>其中HBase是我从各种资料中见过的最多的一种，当然也有其他的，但HBase应该是里面最受欢迎的一类。</p>
<p>当然，我个人是没有大厂经验的，我只能把我掌握到的讯息告诉你们。</p>
<p>如果有兴趣的话，可以去学习下HBase，它是一种在 <code>Hadoop</code> 上构建的分布式、可扩展的列式数据库。</p>
<p>它最大的优势就是<code>快速读写海量数据</code>，且具有<code>强一致性</code>。</p>
<p>一般大厂对于冷数据的处理，往往都是因为冷数据在业务中也有相当的查询体量，如果太慢也不符合大厂维护项目的标准，所以有必要专门优化。</p>
<p>好了，这里之所以提到HBase，主要是为了扩充大家的知识面，其实中小企业的工程师也没啥必要特地去学，依靠自身兴趣驱动即可。</p>
<h5 id="3-区分冷热数据">3）、区分冷热数据</h5>
<p>既然要冷热分离，那么一张表中，如何区分哪些是热数据，哪些是冷数据？</p>
<blockquote>
<p>要分析这张表的<code>字段特征</code>，拿订单表举例，马上能想到的就是：订单状态、创建时间。</p>
</blockquote>
<p>订单状态的话，其实也类似于前面数据库分区提过的归档状态，你可以将状态是<code>已完成</code>的数据归类为冷数据，而<code>待处理</code>、<code>处理中</code>的都归类为热数据，这个要视你们自己的业务决定。</p>
<p>创建时间的话，就比较常见了，也是我推荐中小企业使用的方法，因为<code>几乎所有的核心业务表，都一定会有创建时间这个字段</code>，我们可以把查询频繁的时间区间的数据归类为热数据，其他时间都归类为冷数据。</p>
<p>比如本篇我讲的案例，当时我们公司就是半年内的数据是查询非常频繁的，因此直接按照最近半年作为区分冷热数据的规则。</p>
<h5 id="4-如何冷热分离">4）、如何冷热分离</h5>
<p>这里有四种方案：</p>
<ul>
<li>代码中处理</li>
</ul>
<blockquote>
<p>这个很好理解，比如订单表中，当状态从处理中改为已完成时，你就可以将这条记录归类为冷数据，放到冷表或冷库中。</p>
<p>优点是很灵活，而且实时性高。</p>
<p>缺点是相关的代码位置你都要做修改，另外如果是按照时间做冷热分离，这个方案基本就不可取。</p>
<p>你想想，你怎么判断呢？我们按照半年内的数据作为热数据，那么你在哪个方法哪个事件触发时将这笔订单归类为冷数据？可以说做不到。</p>
</blockquote>
<ul>
<li>任务调度处理</li>
</ul>
<blockquote>
<p>这种就是定时任务去扫描数据库，比如xxl-job，新建一个调度任务，定时去扫描数据库，判断哪些是冷数据，然后归档到冷表或冷库中去。</p>
<p>这种的优点，一来是不用大量修改代码，二来就是非常适合按照时间划分冷热数据的场景。因为它是一种延迟处理方式，你可以设置为半夜去运行。</p>
<p>比如我之前的那家公司，就是设置为凌晨以后执行，因为那个时候很少有用户在使用了，没有什么新的订单产生，哪怕有新的订单，也属于误差范围内，可以接受。</p>
</blockquote>
<ul>
<li>监听binlog</li>
</ul>
<blockquote>
<p>这种方案我是从书本上获取到的，给我涨了点知识。</p>
<p>监听binlog的目的说白了，就是判断订单状态是否变化，和代码中处理很类似，唯一的区别在于，<code>如果你维护的这个项目又老又复杂，代码很难改也改不全</code>，监听binlog就是很好的方案了，你可以不改代码，监听数据库变更日志然后做相应处理即可。</p>
<p>当然，缺点和前面一样，当按照时间来划分冷热数据时，这种方案也不可取，因为你不知道如何监听。</p>
</blockquote>
<ul>
<li>人工迁移</li>
</ul>
<blockquote>
<p>冷热分离操作的最终还是数据，分离实质上也就是一种数据迁移，因此，人工干预其实是很靠谱的选择。</p>
<p>上面每种方案都有自己的优势，但也有各自的局限性。</p>
<p>代码处理，你只能处理发布上线以后的新数据。</p>
<p>任务调度，当数据量庞大的情况下，你一次可能根本无法完成分离，对于紧急的要快速优化的场景显然不适合。</p>
<p>监听binlog，除了前面提到的缺点，还需要工程师对其比较熟悉，否则短时间内上手容易带来不确定性。</p>
<p>此时，DBA或集成工程师(俗称打杂工程师)的优势就体现出来了，备份后，抽某天晚上，直接把半年以外的数据迁移到冷库即可。</p>
<p>这样不仅简单，也避免了其他技术方案可能存在的问题及风险。专业的人，做专业的事，才是最靠谱的。</p>
</blockquote>
<h4 id="4-最终方案">4、最终方案</h4>
<p>通过上面简述的几种方案，我们已经有了较为清晰的认知。</p>
<blockquote>
<p>现在我可以告诉大家，当初的公司所采用的方案是其中两种方案的结合：<code>人工迁移 + 任务调度</code>。</p>
</blockquote>
<p>人工迁移用于一次迁移完成冷数据到冷库，任务调度用于对后续新产生的数据进行解耦且延迟的冷热分离。</p>
<p>思维导图大概是这样：</p>
<figure data-type="image" tabindex="3"><a href="https://img2023.cnblogs.com/blog/1755845/202312/1755845-20231218095746268-532662896.png"><img src="https://img2023.cnblogs.com/blog/1755845/202312/1755845-20231218095746268-532662896.png" alt="" loading="lazy"></a></figure>
<p>基本步骤如下：</p>
<ul>
<li>
<p>1）、定位冷热分离的规则，比如本篇，就是按照订单交易完成时间，以半年内和半年外作为分离的基准；</p>
</li>
<li>
<p>2）、冷数据迁移，由公司的DBA或集成工程师对数据进行备份，然后在发布当晚将冷数据迁移到冷库中去；</p>
</li>
<li>
<p>3）、开发人员新建一个调度任务，并实现任务调用的接口，专门扫描数据库，将超过半年的订单数据通过程序逻辑迁移到冷库，保证热数据一直维持在半年内，任务可以每天凌晨执行一次，或根据自身业务决定调度频率。</p>
</li>
</ul>
<blockquote>
<p>这样一来，既解决了冷热分离规则的问题，不管是什么规则，你最终都可以通过人工迁移数据来做到分离。</p>
<p>也解决了时间上的紧迫性，你只需要开发一个用于调度的接口，不再需要考虑其他任何技术层面的影响，时间成倍缩短。</p>
</blockquote>
<p>这在中小企业算是比较适合的方案了，当初我们在一周内就优化完成了，研发工程师用了<code>1天完成调度接口的实现</code>，剩下的时间都是集成工程师<code>进行数据迁移的演练</code>。</p>
<p>最终客户还是很满意的，核心业务的查询速度一下就<code>提升了近10倍</code>。</p>
<h3 id="优缺点">优缺点</h3>
<p>好了，临近尾声，我们来说一下冷热分离方案整体的优缺点吧。</p>
<h4 id="1-优点">1、优点</h4>
<p>优点我归纳了3点：</p>
<h5 id="1-提高性能">1）、提高性能</h5>
<p>很明显，冷热分离后，将更多<code>计算资源集中在了热数据</code>上，将查询性能最大化。</p>
<h5 id="2-降低成本">2）、降低成本</h5>
<p>对于千万级的数据表，冷热分离方案<code>不需要额外的第三方中间件</code>，极大地节约了成本。尤其是在中小公司，老板对成本还是很在意的。</p>
<h5 id="3-简化维护">3）、简化维护</h5>
<p>冷热分离之后，对于数据的<code>维护更直观</code>，可以把更多精力放在热数据的处理上。</p>
<p>比如备份策略，冷热数据可以分别采用不同的策略维护，更<code>关注热数据</code>备份，<code>简化冷数据</code>备份。</p>
<h4 id="2-缺点">2、缺点</h4>
<p>缺点我归纳了2点：</p>
<h5 id="1-场景限制多">1）、场景限制多</h5>
<p>冷热分离并不是万能的，一定要根据业务来分析，查询的复杂度较高，很可能你冷热分离后，热数据的查询依然没有得到明显优化。</p>
<blockquote>
<p>比如你有一张表，查询的语句关联很多，表数据量也挺大，那么这个时候冷热分离一点作用都没有，因为你分离完了，查询语句还是关联那么多，速度依然很慢。</p>
</blockquote>
<p>这个时候，类似的场景就无法使用冷热分离方案了，而是要考虑其他方案，比如<code>读写分离</code>，比如<code>查询分离</code>，这样才能从根源上解决查询慢的问题。</p>
<h5 id="2-统计效率低">2）、统计效率低</h5>
<p>这种也是冷热分离方案比较明显的一个缺点，当你们的业务中，需要对数据做一些复杂的统计分析，甚至要求一定的实时性。</p>
<p>那么这个时候，因为已经冷热分离，<code>冷数据的统计分析效率会非常低</code>，对于客户提出的一些五花八门的统计分析就难以操作了。</p>
<p>因此，又需要引入其他方案来配合，比如<code>ElasticSearch</code>，这样又增加了额外的成本，不仅要考虑ES的资源成本，还要考虑诸如<code>部署方案</code>、<code>维护方案</code>、<code>安全性问题</code>等等。</p>
<blockquote>
<p>今年我们内部就公布了一个小道消息，某家业内还挺不错的互联网公司因为ElasticSearch的未授权漏洞导致千万用户敏感信息被泄露，直接被行业除名了。</p>
</blockquote>
<p>所以，在实际工作中，中间件的引入是个需要审慎考虑的问题，而不是你想当然了就可以使用。</p>
<h3 id="总结">总结</h3>
<p>通篇写的还是挺长的，主要是一开始列出了大纲，但在写的过程中又想起了新的知识点，就一起加进来了。</p>
<p>前面讲的数据库分区等方案，主要是为了过渡，因为这是一个线性的思维，展现出来让大家知道一个方案最终落地的脉络是怎样的。</p>
<p>今后还会继续写一些架构相关的知识，放在单独的专栏里面，希望大家支持和喜欢。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[spring boot中使用sapjco3，并用docker部署到Linux服务器]]></title>
        <id>https://yuzhupeng.top/myblogs/post/spring-boot-zhong-shi-yong-sapjco3bing-yong-docker-bu-shu-dao-linux-fu-wu-qi/</id>
        <link href="https://yuzhupeng.top/myblogs/post/spring-boot-zhong-shi-yong-sapjco3bing-yong-docker-bu-shu-dao-linux-fu-wu-qi/">
        </link>
        <updated>2025-07-24T01:45:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="在spring-boot中使用sapjco3并用docker部署到linux服务器-发布于-2025-07-24-1526">[在spring boot中使用sapjco3，并用docker部署到Linux服务器] &quot;发布于 2025-07-24 15:26&quot;)</h1>
<p>一、在windows中的配置</p>
<p>二、linux的配置</p>
<p>三、spring boot项目构建</p>
<p>sapjco3包含很多个操作系统版本，不同的操作系统需要使用不同的配置文件和配置方式，不过sapjco3.jar是可以通用的。</p>
<figure data-type="image" tabindex="1"><img src="https://img2020.cnblogs.com/blog/1543878/202008/1543878-20200819105934366-640195848.png" alt="" loading="lazy"></figure>
<h1 id="一-在windows中的配置">一、在windows中的配置</h1>
<p>windows中需要的文件主要包括：</p>
<p>sapjco3.dll</p>
<p>sapjco3.pdb</p>
<p>sapjco3.jar</p>
<h2 id="1-sapjco3dll文件">1、sapjco3.dll文件</h2>
<p>32位系统</p>
<p>将 sapjco3.dll 加入到c:/windows/system32/目录 或者 将 sapjco3.dll 加入到 JDK/bin 目录下；</p>
<p>64位系统</p>
<p>将 sapjco3.dll 加入到c:/windows/SysWOW64/目录 或者 将 sapjco3.dll 加入到 JDK/bin 目录下；</p>
<p>64位机可以直接将sapjco3.dll放在&quot;C:\Windows\System32&quot;目录下，这样以后不必针对具体的应用来配置它；</p>
<figure data-type="image" tabindex="2"><img src="https://img2020.cnblogs.com/blog/1543878/202008/1543878-20200819110146552-1363688094.png" alt="" loading="lazy"></figure>
<p>上面的配置是为了将它放在系统环境变量path可以找到的地方，所以也可以直接把sapjco3.dll文件所在的位置，配置到系统环境变量path下面；</p>
<h2 id="2-sapjco3pdb文件">2、sapjco3.pdb文件</h2>
<p>在springboot中使用sapjco3可以不用配置sapjco3.pdb，如果在kettle中需要调用sap的接口，则需要把sapjco3.pdb放在kettle的根目录&quot;${KETTLE_HOME}/&quot;下面；</p>
<h2 id="3-sapjco3jar文件">3、sapjco3.jar文件</h2>
<p>这个文件就是java调用sap的主要api，包含许多方法，如连接sap、获取接口参数、设置接口参数和获取返回参数等；</p>
<p>这里<strong>推荐将sapjco3.jar放在项目的lib目录下面，然后在项目打包的时候，将本地依赖的jar包打包到项目jar中</strong>；</p>
<p>也可以将sapjco3.jar放在${JAVA_HOME}/lib目录下或者放在其他目录并将该目录下的sapjco3.jar添加到系统环境变量CLASSPATH下面；</p>
<p>也可以在pom.xml中引入sapjco3.jar依赖，这样项目打包的时候会将sapjco3.0.14.jar打包到项目jar里面，但是这样sapjco3.jar文件是带有版本后缀的，在项目部署的时候，会启动失败，报错：It is not allowed to rename or repackage the original archive “sapjco3.jar”。需要手动进入jar包，将sapjco3.0.14.jar名称修改为sapjco3.jar；</p>
<p>[<img src="//assets.cnblogs.com/images/copycode.gif" alt="复制代码" loading="lazy">](javascript:void(0); &quot;复制代码&quot;)</p>
<pre><code>&lt;!-- https://mvnrepository.com/artifact/com.sap.conn.jco/sapjco3 --&gt;
&lt;dependency&gt;
        &lt;groupId&gt;com.sap.conn.jco&lt;/groupId&gt;
        &lt;artifactId&gt;sapjco3&lt;/artifactId&gt;
        &lt;version&gt;3.0.14&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>[<img src="//assets.cnblogs.com/images/copycode.gif" alt="复制代码" loading="lazy">](javascript:void(0); &quot;复制代码&quot;)</p>
<p>还有一种方式是使用maven的install命令将sapjco3.jar安装到本地仓库，然后在项目中引入依赖，但是切记jar包不能后缀版本号；</p>
<hr>
<h1 id="二-linux的配置">二、linux的配置</h1>
<p>linux需要的文件包括：</p>
<p>libsapjco3.so</p>
<p>sapjco3.jar</p>
<p>其中jar包sapjco3.jar与windows版的可以通用；重点是将libsapjco3.so文件配置到linux的jre/lib运行时环境中或者项目可以加载到libsapjco3.so的其他位置；</p>
<h2 id="1-linux系统">1、Linux系统：</h2>
<p>1)将压缩文件解压到某个目录下面，比如/home/appuser/sapjco3/ 下面：</p>
<blockquote>
<p>tar -zxvf sapjco3-linuxx86_64-3.0.17.tgz -C /home/appuser/sapjco3</p>
</blockquote>
<p>2)配置环境变量</p>
<blockquote>
<p>vim /etc/profile</p>
</blockquote>
<p>在配置文件内加上下面的内容：</p>
<blockquote>
<p>export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:/home/appuser/sapjco3</p>
<p>export CLASSPATH=.:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>J</mi><mi>A</mi><mi>V</mi><mi>A</mi><mi mathvariant="normal">_</mi><mi>H</mi><mi>O</mi><mi>M</mi><mi>E</mi></mrow><mi mathvariant="normal">/</mi><mi>l</mi><mi>i</mi><mi>b</mi><mo>:</mo></mrow><annotation encoding="application/x-tex">{JAVA\_HOME}/lib:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">A</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span></span></span>{LD_LIBRARY_PATH}/sapjco3.jar</p>
</blockquote>
<p>或者</p>
<p>先将文件libsapjco3.so复制到${JAVA_HOME}/jre/lib/amd64/server文件夹下</p>
<blockquote>
<p>export LD_LIBRARY_PATH=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>L</mi><mi>D</mi><mi mathvariant="normal">_</mi><mi>L</mi><mi>I</mi><mi>B</mi><mi>R</mi><mi>A</mi><mi>R</mi><mi>Y</mi><mi mathvariant="normal">_</mi><mi>P</mi><mi>A</mi><mi>T</mi><mi>H</mi></mrow><mo>:</mo></mrow><annotation encoding="application/x-tex">{LD\_LIBRARY\_PATH}:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.99333em;vertical-align:-0.31em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span></span></span>{JAVA_HOME}/jre/lib/amd63/server</p>
<p>export CLASSPATH=.:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>J</mi><mi>A</mi><mi>V</mi><mi>A</mi><mi mathvariant="normal">_</mi><mi>H</mi><mi>O</mi><mi>M</mi><mi>E</mi></mrow><mi mathvariant="normal">/</mi><mi>l</mi><mi>i</mi><mi>b</mi><mo>:</mo></mrow><annotation encoding="application/x-tex">{JAVA\_HOME}/lib:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">A</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span></span></span>{LD_LIBRARY_PATH}/sapjco3.jar</p>
</blockquote>
<p>上面配置的重点是libsapjco3.so的位置，对于sapjco3.jar，可以配置到环境变量${CLASSPATH}中，也可以打包在项目中；</p>
<p>官方的推荐如下：</p>
<h2 id="2-docker">2、docker：</h2>
<p>在docker中可以使用 <strong>-v 宿主机目录:容器目录</strong> 的方式将libsapjco3.so和sapjco3.jar进行映射：</p>
<blockquote>
<p>docker run -d \</p>
<p>--restart=always \</p>
<p>--name springboot-sapjco3 \</p>
<p>-v &quot;$PWD/sapringboot-sapjco3&quot;:/usr/app \</p>
<p><strong>-v /home/appuser/sapjco3/libsapjco3.so:/usr/lib/libsapjco3.so</strong> \</p>
<p>--workdir=&quot;/usr/app&quot; \</p>
<p>-p 8080:8080 \</p>
<p>java:8u111 \</p>
<p>java -jar sprringboot-sapjco3.jar</p>
</blockquote>
<p>这样就将宿主机的libsapjco3.so映射到了容器的/usr/lib下面；</p>
<p>如果项目中没有打包sapjco3.jar文件，也可以在docker run 的 -v 命令中将该文件映射到jdk的lib目录下：</p>
<blockquote>
<p>-v /hemo/appuser/sapjco3/sapjco3.jar:/usr/lib/jvm/java-8-openjdk-amd64/lib/sapjco3.jar</p>
</blockquote>
<h1 id="三-spring-boot项目构建">三、spring boot项目构建</h1>
<h2 id="1-项目结构与配置文件">1、项目结构与配置文件</h2>
<p>将sapjco3.jar放在项目resource/lib下面；</p>
<p>CONNECT_SAP_CONFIG.jcoDestination文件是连接SAP的配置文件，必需放在项目的根目录下面，其内容如下：</p>
<blockquote>
<pre><code>#for tests only !
jco.client.lang=en
jco.client.client=710
jco.client.user=admin
jco.client.passwd=admin
jco.client.sysnr=00
jco.client.ashost=192.168.1.11
</code></pre>
</blockquote>
<p>配置pom.xml，引入自定义jar包，并在项目打包时将自定义jar包打包进项目的jar：</p>
<p>[<img src="//assets.cnblogs.com/images/copycode.gif" alt="复制代码" loading="lazy">](javascript:void(0); &quot;复制代码&quot;)</p>
<pre><code>&lt;dependencies&gt;
        &lt;!--maven打包时，将resources/lib/sapjco3.jar一并打包--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.sap&lt;/groupId&gt;
            &lt;artifactId&gt;sapjco3&lt;/artifactId&gt;
            &lt;version&gt;1.0&lt;/version&gt;
            &lt;scope&gt;system&lt;/scope&gt;
          &lt;systemPath&gt;${project.basedir}/src/main/resources/lib/sapjco3.jar&lt;/systemPath&gt;
        &lt;/dependency&gt;
        &lt;!--其他依赖--&gt;
        &lt;dependency&gt;
              ......
        &lt;/dependency&gt;
&lt;dependencies&gt;
&lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;executable&gt;true&lt;/executable&gt;
                    &lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt;
                &lt;/configuration&gt;
                &lt;dependencies&gt;
                    &lt;dependency&gt;
                        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
                        &lt;artifactId&gt;springloaded&lt;/artifactId&gt;
                        &lt;version&gt;1.2.5.RELEASE&lt;/version&gt;
                    &lt;/dependency&gt;
                &lt;/dependencies&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<p>[<img src="//assets.cnblogs.com/images/copycode.gif" alt="复制代码" loading="lazy">](javascript:void(0); &quot;复制代码&quot;)</p>
<h2 id="2获取sap连接对象">2.获取sap连接对象</h2>
<p>[<img src="//assets.cnblogs.com/images/copycode.gif" alt="复制代码" loading="lazy">](javascript:void(0); &quot;复制代码&quot;)</p>
<pre><code>public class JCoDestinationBuilder {
    public static JCoDestination destination = null;
    private static final Logger logger = LogUtils.getPlatformLogger();
    public static JCoDestination build() throws JCoException {
        if (null==destination) {
            synchronized (JCoDestinationBuilder.class) {
                try {
                    if (null == destination)
                        destination = JCoDestinationManager.getDestination(&quot;CONNECT_SAP_CONFIG&quot;);
                    destination.ping();
                    logger.info(&quot;Connect to SAP successfully......&quot;);
                } catch (JCoException e) {
                    e.printStackTrace();
                    logger.error(&quot;Connect to SAP failed, error msg: &quot; + e.toString());
                }
            }
        }
        //logger.info(String.valueOf(destination.getAttributes()));
        return destination;
    }
}
</code></pre>
<p>[<img src="//assets.cnblogs.com/images/copycode.gif" alt="复制代码" loading="lazy">](javascript:void(0); &quot;复制代码&quot;)</p>
<h2 id="3调用sap接口函数">3.调用sap接口函数</h2>
<p>[<img src="//assets.cnblogs.com/images/copycode.gif" alt="复制代码" loading="lazy">](javascript:void(0); &quot;复制代码&quot;)</p>
<pre><code>@Service
public class SappiMonitorServiceImpl implements SappiMonitorService {
    @Autowired
    Sm58EntityRepository sm58EntityRepository;
    @Autowired
    MessageService messageService;
    @Autowired
    private Environment environment;
    private static final Logger logger = LogUtils.getPlatformLogger();

    @Override
    public JSONObject monitorSm58(SappiSm58 sappiSm58) throws JCoException {
        if (sappiSm58==null) sappiSm58 = new SappiSm58();
        JCoDestination destination = JCoDestinationBuilder.build();
        JCoFunction function = destination.getRepository().getFunction(&quot;ZMONITOR_SM58&quot;);
        JCoParameterList importlist = function.getImportParameterList();
        JCoParameterList exportList = function.getExportParameterList();
        JCoParameterList tables = function.getTableParameterList();

        importlist.setValue(&quot;I_BEGIN_DATE&quot;,sappiSm58.getI_begin_date());
        importlist.setValue(&quot;I_END_DATE&quot;,sappiSm58.getI_end_date());
        try {
            function.execute(destination);
            //logger.warn(function.toXML());
        } catch (JCoException e) {
            e.printStackTrace();
            logger.error(&quot;execute()failed......&quot;);
        }
        JCoTable t_arfcistate = tables.getTable(&quot;T_ARFCISTATE&quot;);
        for (int i=0;i&lt;t_arfcistate.getNumRows();i++) {
            t_arfcistate.setRow(i);
            Sm58Entity sm58Entity = new Sm58Entity();
            sm58Entity.setArfcipid(t_arfcistate.getString(&quot;ARFCIPID&quot;));
            sm58Entity.setArfcpid(t_arfcistate.getString(&quot;ARFCPID&quot;));
            sm58Entity.setArfctime(t_arfcistate.getString(&quot;ARFCTIME&quot;));
            sm58Entity.setArfctidcnt(t_arfcistate.getString(&quot;ARFCTIDCNT&quot;));
            sm58Entity.setArfcdest(t_arfcistate.getString(&quot;ARFCDEST&quot;));
            sm58Entity.setArfcluwcnt(t_arfcistate.getString(&quot;ARFCLUWCNT&quot;));
            sm58Entity.setArfcstate(t_arfcistate.getString(&quot;ARFCSTATE&quot;));
            sm58Entity.setArfcfnam(t_arfcistate.getString(&quot;ARFCFNAM&quot;));
            sm58Entity.setArfcreturn(t_arfcistate.getString(&quot;ARFCRETURN&quot;));
            sm58Entity.setArfcuzeit(t_arfcistate.getString(&quot;ARFCUZEIT&quot;));
            sm58Entity.setArfcdatum(t_arfcistate.getString(&quot;ARFCDATUM&quot;));
            sm58Entity.setArfcuser(t_arfcistate.getString(&quot;ARFCUSER&quot;));
            sm58Entity.setArfcretrys(t_arfcistate.getLong(&quot;ARFCRETRYS&quot;));
            sm58Entity.setArfctcode(t_arfcistate.getString(&quot;ARFCTCODE&quot;));
            sm58Entity.setArfcrhost(t_arfcistate.getString(&quot;ARFCRHOST&quot;));
            sm58Entity.setArfcmsg(t_arfcistate.getString(&quot;ARFCMSG&quot;));
            sm58Entity.setArfcreserv(t_arfcistate.getString(&quot;ARFCRESERV&quot;));
            sm58Entity.setHash(t_arfcistate.getString(&quot;HASH&quot;));
            sm58EntityRepository.save(sm58Entity);
        }
        String markdown = SappiMonitorServiceImpl.generateMarkdown(&quot;monitorSm58&quot;,
                exportList.getString(&quot;E_ERR_NUM&quot;).replaceAll(&quot; &quot;,&quot;&quot;));
        //调用MessageService接口
        MarkdownMessage markdownMessage = new MarkdownMessage();
        markdownMessage.setUserid(environment.getProperty(&quot;sap.pi.monitor.sm58.touser&quot;));
        markdownMessage.setMarkdown(markdown);
        JSONObject jsonObject = new JSONObject();
        if (&quot;E&quot;.equals(exportList.getString(&quot;E_STATUS&quot;))) {
            jsonObject = messageService.sendMarkdown(markdownMessage);
            jsonObject.put(&quot;errCode&quot;,&quot;-1&quot;);
            jsonObject.put(&quot;errMsg&quot;,&quot;系统运行出现&quot; + exportList.getString(&quot;E_ERR_NUM&quot;) +&quot;条错误&quot;);
        } else {
            jsonObject.put(&quot;errCode&quot;,&quot;0&quot;);
            jsonObject.put(&quot;errMsg&quot;,&quot;系统运行正常&quot;);
        }
        return jsonObject;
    }
}
</code></pre>
<p>[<img src="//assets.cnblogs.com/images/copycode.gif" alt="复制代码" loading="lazy">](javascript:void(0); &quot;复制代码&quot;)</p>
<p>上面代码中，<strong>粗体</strong>部分是获取sap连接对象、接口参数赋值、接口调用和获取返回结果的主要代码；</p>
<h2 id="4编写相应的controller代码">4.编写相应的Controller代码</h2>
<p>[<img src="//assets.cnblogs.com/images/copycode.gif" alt="复制代码" loading="lazy">](javascript:void(0); &quot;复制代码&quot;)</p>
<pre><code>@Api(tags = &quot;SAPPI运行状态监控&quot;, description = &quot;监控SAPPI运行状态&quot;)
@Controller
@RequestMapping(&quot;/monitor/sappi&quot;)
public class SappiMonitorController {
    @Autowired
    SappiMonitorService sappiMonitorService;

    @ApiOperation(value = &quot;事务代码:SXI_MONITOR&quot;, notes = &quot;请求方式:POST&quot;)
    @PostMapping(&quot;/sxi_monitor&quot;)
    @ResponseBody
    public JSONObject monitorSxi_monitor(@RequestBody(required = false) SappiSxi_monitor sappiSxi_monitor) throws Exception {
        return sappiMonitorService.monitorSxi_monitor(sappiSxi_monitor);
    }

    @ApiOperation(value = &quot;事务代码:SM58&quot;, notes = &quot;请求方式:POST&quot;)
    @PostMapping(&quot;/sm58&quot;)
    @ResponseBody
    public JSONObject monitorSm58(@RequestBody(required = false) SappiSm58 sappiSm58) throws Exception {
        return sappiMonitorService.monitorSm58(sappiSm58);
    }
}
</code></pre>
<p>[<img src="//assets.cnblogs.com/images/copycode.gif" alt="复制代码" loading="lazy">](javascript:void(0); &quot;复制代码&quot;)</p>
<h2 id="5运行与测试">5.运行与测试</h2>
<p>上面的代码中，只贴出了sapjco使用的主要部分，其中数据库的持久化部分和将sap接口调用结果发送到微信通知的部分都可以删减掉；</p>
<p>测试时，请求方式改为GET方式即可：</p>
<p>即**@PostMapping(&quot;/sm58&quot;)** 改为 <strong>@GetMapping(&quot;/sm58&quot;)</strong></p>
<p>然后在浏览器或者用postman直接调用接口：<strong>localhost:8080/monitor/sappi/sm58</strong></p>
<p>将会看到如下返回结果：</p>
<blockquote>
<p>{<br>
　　&quot;invalidUser&quot;: &quot;&quot;,<br>
　　&quot;invalidTagList&quot;: [],<br>
　　&quot;errCode&quot;: &quot;-1&quot;,<br>
　　&quot;errMsg&quot;: &quot;系统运行出现1 条错误&quot;,<br>
　　&quot;invalidPartyList&quot;: [],<br>
　　&quot;invalidUserList&quot;: []<br>
}</p>
</blockquote>
<h2 id="6-打包与部署">6、打包与部署</h2>
<p>使用maven的package命令将项目打包成jar包，并上传到linux服务器/home/appuser/springboot-sapjco目录下面；</p>
<p>使用上面的docker命令部署并运行项目；</p>
<h1 id="四-各操作系统sapjco文件下载">四、各操作系统sapjco文件下载：</h1>
<p>链接: <a href="https://pan.baidu.com/s/1-1Cxam_9Q6o0z_NqqOGvoA" title="下载sapjco3.jar">https://pan.baidu.com/s/1-1Cxam_9Q6o0z_NqqOGvoA</a> 提取码: v7c8</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis笔记]]></title>
        <id>https://yuzhupeng.top/myblogs/post/redis-bi-ji/</id>
        <link href="https://yuzhupeng.top/myblogs/post/redis-bi-ji/">
        </link>
        <updated>2025-07-08T05:30:44.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>Redis本质：内存型键值对数据库</p>
<ul>
<li>
<p>基本数据类型</p>
<ul>
<li>String</li>
<li>Hash</li>
<li>List</li>
<li>Set</li>
<li>ZSet</li>
<li>特殊类型</li>
</ul>
</li>
<li>
<p>持久化机制</p>
<ul>
<li>RDB（快照）</li>
<li>AOF（追加日志）</li>
</ul>
</li>
</ul>
<hr>
<h2 id=""><a href="#Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" title="Redis基本数据类型"></a>Redis基本数据类型</h2>
<h3 id="-2"><a href="#String%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89" title="String（字符串）"></a><strong>String（字符串）</strong></h3>
<p>🔑 <strong>数据结构</strong><br>
二进制安全，可存储文本/数字/序列化对象，最大512MB</p>
<p>💻 <strong>核心命令</strong></p>
<ul>
<li><code>SET key value [EX seconds]</code> 设置带过期时间的值</li>
<li><code>GET key</code></li>
<li><code>INCR/DECR key</code> 原子计数器</li>
<li><code>MSET/MGET</code> 批量操作</li>
<li><code>SETBIT/GETBIT</code> 位操作</li>
</ul>
<p>🎯 <strong>应用场景</strong></p>
<ul>
<li>缓存HTML片段/序列化对象</li>
<li>分布式锁（SETNX）</li>
<li>限流器（INCR+EXPIRE）</li>
<li>位统计（日活用户Bitmap）</li>
</ul>
<p>⚠️ <strong>注意事项</strong></p>
<ul>
<li>Value超过10KB需警惕大Key问题</li>
<li>INCR存在溢出风险（最大值9223372036854775807）</li>
</ul>
<p>🔧 <strong>底层原理</strong></p>
<ul>
<li>动态字符串SDS（O(1)获取长度，预分配空间）</li>
<li>数值类型自动转int存储优化</li>
</ul>
<hr>
<h3 id="-3"><a href="#Hash%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89" title="Hash（哈希表）"></a><strong>Hash（哈希表）</strong></h3>
<p>🔑 <strong>数据结构</strong><br>
双向链表，元素可重复，按插入顺序排序</p>
<p>💻 <strong>核心命令</strong></p>
<ul>
<li><code>LPUSH/RPUSH key element</code></li>
<li><code>LPOP/RPOP key</code></li>
<li><code>BLPOP/BRPOP</code> 阻塞式弹出</li>
<li><code>LRANGE key start stop</code></li>
</ul>
<p>🎯 <strong>应用场景</strong></p>
<ul>
<li>消息队列（结合BLPOP实现）</li>
<li>最新消息排行（LPUSH+LRANGE）</li>
<li>分页查询（LRANGE实现）</li>
</ul>
<p>⚠️ <strong>注意事项</strong></p>
<ul>
<li>长列表（元素数&gt;1000）查询性能下降</li>
<li>多个消费者场景需做消息ACK确认</li>
</ul>
<p>🔧 <strong>底层原理</strong></p>
<ul>
<li>快速链表quicklist（ziplist+linkedlist结合）</li>
<li>节点元素上限可通过list-max-ziplist-size配置</li>
</ul>
<p>📌 <strong>实战技巧</strong></p>
<ul>
<li>使用<code>LTRIM</code>维护固定长度队列</li>
</ul>
<hr>
<h3 id="-4"><a href="#List%EF%BC%88%E5%88%97%E8%A1%A8%EF%BC%89" title="List（列表）"></a><strong>List（列表）</strong></h3>
<p>🔑 <strong>数据结构</strong><br>
双向链表，元素可重复，按插入顺序排序</p>
<p>💻 <strong>核心命令</strong></p>
<ul>
<li><code>LPUSH/RPUSH key element</code></li>
<li><code>LPOP/RPOP key</code></li>
<li><code>BLPOP/BRPOP</code> 阻塞式弹出</li>
<li><code>LRANGE key start stop</code></li>
</ul>
<p>🎯 <strong>应用场景</strong></p>
<ul>
<li>消息队列（结合BLPOP实现）</li>
<li>最新消息排行（LPUSH+LRANGE）</li>
<li>分页查询（LRANGE实现）</li>
</ul>
<p>⚠️ <strong>注意事项</strong></p>
<ul>
<li>长列表（元素数&gt;1000）查询性能下降</li>
<li>多个消费者场景需做消息ACK确认</li>
</ul>
<p>🔧 <strong>底层原理</strong></p>
<ul>
<li>快速链表quicklist（ziplist+linkedlist结合）</li>
<li>节点元素上限可通过list-max-ziplist-size配置</li>
</ul>
<p>📌 <strong>实战技巧</strong></p>
<ul>
<li>使用<code>LTRIM</code>维护固定长度队列</li>
</ul>
<hr>
<h3 id="-5"><a href="#Set%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89" title="Set（集合）"></a><strong>Set（集合）</strong></h3>
<p>🔑 <strong>数据结构</strong><br>
无序且元素唯一的集合，支持交并差运算</p>
<p>💻 <strong>核心命令</strong></p>
<ul>
<li><code>SADD key member</code></li>
<li><code>SISMEMBER key member</code></li>
<li><code>SINTER key1 key2</code> 交集</li>
<li><code>SUNIONSTORE dest key1 key2</code> 并集存储</li>
</ul>
<p>🎯 <strong>应用场景</strong></p>
<ul>
<li>标签系统（用户标签集合）</li>
<li>共同关注（SINTER计算交集）</li>
<li>UV统计（去重计数）</li>
</ul>
<p>⚠️ <strong>注意事项</strong></p>
<ul>
<li>SMEMBERS全量获取可能阻塞，优先用SSCAN</li>
<li>超大集合（&gt;1W元素）交并运算消耗内存激增</li>
</ul>
<p>🔧 <strong>底层原理</strong></p>
<ul>
<li>小集合用intset（整数数组）</li>
<li>大集合转为hashtable存储</li>
</ul>
<p>📌 <strong>实战技巧</strong></p>
<ul>
<li>使用<code>SPOP</code>实现随机抽奖功能</li>
</ul>
<hr>
<h3 id="-6"><a href="#ZSet%EF%BC%88%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%89" title="ZSet（有序集合）"></a><strong>ZSet（有序集合）</strong></h3>
<p>🔑 <strong>数据结构</strong><br>
唯一成员+排序权重（score）的有序结构</p>
<p>💻 <strong>核心命令</strong></p>
<ul>
<li><code>ZADD key score member</code></li>
<li><code>ZRANGE key start stop [WITHSCORES]</code></li>
<li><code>ZRANK key member</code> 获取排名</li>
<li><code>ZREVRANGEBYSCORE</code> 按分数范围查询</li>
</ul>
<p>🎯 <strong>应用场景</strong></p>
<ul>
<li>实时排行榜（直播打赏排行）</li>
<li>延迟队列（score存执行时间戳）</li>
<li>范围查询（地理位置附近的人）</li>
</ul>
<p>⚠️ <strong>注意事项</strong></p>
<ul>
<li>Score使用双精度浮点数，存在精度丢失风险</li>
<li>大数据量范围查询优先用<code>ZSCAN</code></li>
</ul>
<p>🔧 <strong>底层原理</strong></p>
<ul>
<li>ziplist（元素数&lt;128且value&lt;64字节时）</li>
<li>skiplist+dict组合结构（跳跃表维护顺序，字典快速查找）</li>
</ul>
<p>📌 <strong>实战技巧</strong></p>
<ul>
<li>使用<code>ZUNIONSTORE</code>实现多维度加权排序</li>
</ul>
<hr>
<h3 id="-7"><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9%E5%86%B3%E7%AD%96%E6%A0%91" title="数据类型选择决策树"></a><strong>数据类型选择决策树</strong></h3>
<p>**<br>
graph TD<br>
A[需要排序?] --&gt;|Yes| B(ZSet)<br>
A --&gt;|No| C{需要唯一性?}<br>
C --&gt;|Yes| D(Set)<br>
C --&gt;|No| E{数据结构形态?}<br>
E --&gt;|Key-Value| F(Hash)<br>
E --&gt;|单值/计数器| G(String)<br>
E --&gt;|队列/栈| H(List)</p>
<pre><code class="language-|">
***

### [](#对比表 &quot;对比表&quot;)**对比表**

|          | 唯一性 | 排序  | 时间复杂度   | 典型误用场景        |
| -------- | --- | --- | ------- | ------------- |
| **Set**  | 是   | 否   | O(1)    | 用SINTER计算超大集合 |
| **ZSet** | 是   | 是   | O(logN) | Score精度丢失问题   |
| **List** | 否   | 插入序 | O(N)    | 长列表LRANGE全量获取 |

***

建议结合具体业务场景练习数据类型组合使用，例如：

* **社交APP场景**：用ZSet维护好友亲密度排行，Hash存储用户资料，Set管理共同好友
* **电商系统场景**：用String缓存商品详情，Hash存储购物车信息，ZSet实现销量排行榜



</code></pre>
</li>
</ul>
<p>目录</p>
<ul>
<li>
<p><a href="#%E4%B8%80%E5%9F%BA%E7%A1%80">一、基础</a></p>
</li>
<li>
<p><a href="#%E4%BA%8C%E4%B8%BA%E4%BB%80%E4%B9%88redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84">二、为什么Redis是单线程的？</a></p>
</li>
<li>
<p><a href="#%E4%B8%89%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%BF%99%E4%B9%88%E5%BF%AB">三、为什么单线程这么快？</a></p>
</li>
<li>
<p><a href="#%E5%9B%9Bselectpollepoll">四、select、poll、epoll</a></p>
</li>
<li>
<p><a href="#%E4%BA%94redis%E7%9A%84%E4%BA%8B%E5%8A%A1">五、Redis的事务</a></p>
</li>
<li>
<p><a href="#%E5%85%ADredis%E7%9A%84%E7%9B%91%E6%8E%A7">六、Redis的监控</a></p>
</li>
<li>
<p><a href="#%E4%B8%83redis%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">七、Redis的配置文件</a></p>
</li>
<li>
<p><a href="#%E5%85%ABredis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96">八、Redis的持久化</a></p>
<ul>
<li><a href="#81fork%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">8.1、fork()系统调用</a></li>
<li><a href="#82rdb">8.2、RDB</a></li>
<li><a href="#83aof">8.3、AOF</a></li>
<li><a href="#84rdb%E5%92%8Caof%E7%9A%84%E9%80%89%E6%8B%A9">8.4、RDB和AOF的选择</a></li>
</ul>
</li>
<li>
<p><a href="#%E4%B9%9D%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85">九、发布订阅</a></p>
</li>
<li>
<p><a href="#%E5%8D%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6">十、主从复制</a></p>
</li>
<li>
<p><a href="#%E5%8D%81%E4%B8%80%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%B0%8F%E5%AE%9E%E9%AA%8C">十一、集群搭建及小实验</a></p>
<ul>
<li><a href="#111%E6%9E%B6%E6%9E%84%E4%B8%80%E4%B8%80%E4%B8%BB%E4%B8%A4%E4%BB%8E">11.1、架构一：一主两从</a></li>
<li><a href="#112%E6%9E%B6%E6%9E%84%E4%BA%8C">11.2、架构二</a></li>
<li><a href="#113%E6%9E%B6%E6%9E%84%E4%B8%89sentinel">11.3、架构三：Sentinel</a></li>
</ul>
</li>
<li>
<p><a href="#%E5%8D%81%E4%BA%8C%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%9B%AA%E5%B4%A9">十二、缓存穿透、缓存击穿、雪崩</a></p>
</li>
</ul>
<p>\</p>
<figure data-type="image" tabindex="1"><a href="https://img2020.cnblogs.com/blog/1496926/202012/1496926-20201211182212321-54980522.png"><img src="https://img2020.cnblogs.com/blog/1496926/202012/1496926-20201211182212321-54980522.png" alt="" loading="lazy"></a></figure>
<p>面试官都关注了！你还在犹豫什么呢？</p>
<h3 id="一-基础">一、基础<a href="#%E4%B8%80%E5%9F%BA%E7%A1%80">#</a></h3>
<p>重新整理了一下，这篇笔记之前还有一篇基础相关的笔记，<a href="https://www.cnblogs.com/ZhuChangwu/p/11150535.html">点击进入</a></p>
<figure data-type="image" tabindex="2"><a href="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222317905-1049971542.png"><img src="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222317905-1049971542.png" alt="image-20200919193313950" loading="lazy"></a></figure>
<h3 id="二-为什么redis是单线程的">二、为什么Redis是单线程的？<a href="#%E4%BA%8C%E4%B8%BA%E4%BB%80%E4%B9%88redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84">#</a></h3>
<p>官方回答：</p>
<p>Redis是基于内存操作，CPU不是Redis的性能瓶颈，Redis的性能瓶颈是机器的内存大小、以及网络的带宽，既然单线程容易实现，那就直接使用单线程来实现了</p>
<p>此外：</p>
<p>使用单线程实现，那所有的命令就会排队执行，不需要考虑各种同步问题和加锁带来的性能消耗问题。</p>
<p>既然CPU不是Redis的瓶颈，那么如果不想让服务器的其他CPU闲置，可以考虑起多个Redis进程，因为Redis不是关系型数据库，数据之间也没有约束。这样还能搭建集群，分压分流。</p>
<h3 id="三-为什么单线程这么快">三、为什么单线程这么快？<a href="#%E4%B8%89%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%BF%99%E4%B9%88%E5%BF%AB">#</a></h3>
<ol>
<li>Redis是一款内存数据库，基于内存的读写速度本来就很快</li>
<li>如果使用多线程的话会有线程上下文的切换。对于内存系统来说，单线程操作内存的效率才是最高的。</li>
<li>Redis使用了epoll IO多路复用，可以实现用一条线程处理并发的网络请求</li>
</ol>
<h3 id="四-select-poll-epoll">四、select、poll、epoll<a href="#%E5%9B%9Bselectpollepoll">#</a></h3>
<p>select、poll、eopll是操作系统处理网络上传输过来的数据的不同实现，数据从经过网线流入网卡，网卡中的驱动程序会向CPU发出中断信号，在交互系统中，中断信号的优先级是很高的，CPU立刻去处理这个中断信息，CPU通过终端表找到相应的处理函数：</p>
<p>1、禁用网卡的中断信号，告诉网卡下次有数据过来直接写内存就ok</p>
<p>2、通过驱动程序申请、初始化一块内存，将网卡中的数据写进内存中</p>
<p>3、然后解析处理数据：操作系统先校验数据是否符合os structure、数据往上层传递，<strong>Ehthernet校验数据</strong>是否符合预期的格式，继续向上层传递到ip层，再往上到tcp/udp层并按照指定的协议去解析</p>
<p>4、应用层想使用这部分数据就有一个拆包+格式校验的过程</p>
<p>内存指的socket文件的接受缓冲区。</p>
<p>作为一个网络服务器同一时刻可能有多个socket和他建立连接与他进行数据的交互，这里的select、poll、epoll说的其实就是在众多的socket中如何快速高效的找到接受缓冲区存在数据的socket文件，然后交给应用层的代码去处理它</p>
<p>Select模型</p>
<figure data-type="image" tabindex="3"><a href="https://pic1.zhimg.com/80/v2-85dba5430f3c439e4647ea4d97ba54fc_hd.jpg"><img src="https://pic1.zhimg.com/80/v2-85dba5430f3c439e4647ea4d97ba54fc_hd.jpg" alt="" loading="lazy"></a></figure>
<p>操作系统为每一个Tcp连接都会相应的创建sock文件，这些sock文件隶属于操作系统的文件列表。</p>
<p>当sock收到了数据，会调用中断程序唤醒进程A，将进程A从所有的Sock的等来队列中移除，加入到内核空间的工作队列中进程A只知道至少有一个sock的接受缓冲区已经由数据了，但是它不知道到底是哪个sock，所以它得通过遍历sock列表的方式找到这个sock。</p>
<p>select的缺点和不足：</p>
<ol>
<li>进程A需要添加进所有的sock的等待队列中，这会进行一次遍历。</li>
<li>当有sock就收到数据时，又得将进程A从所有的sock等待队列中移除，这又是一次遍历。</li>
<li>进程A寻找有数据的sock时，还会发生一次遍历。</li>
<li>为了放置单个进程将系统的所有资源都耗干，linux会限制单个进程能打开的fd文件句柄数，即使你可以修改配置，突破这会个限制</li>
</ol>
<p>下图截自《UNIX环境高级编程》第二版</p>
<figure data-type="image" tabindex="4"><a href="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200920144559030-1425025324.png"><img src="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200920144559030-1425025324.png" alt="" loading="lazy"></a></figure>
<p>上图可以看到，使用select系统调用上有三个核心参数：分别是 readfds、writefds、exceptfds指向文件描述符号指针，每个描述符都被放在fd_set中， 也就是说针对read、write、和except分别对应着一个独立的fd_set , (并没有网上流传的数组哦，至少《UNIX环境高级编程》是这样讲的)</p>
<p>下图是截取自《UNIX环境高级编程》的关于fd_set的相关信息，fd_set 是一个bit mask，不是数组。</p>
<figure data-type="image" tabindex="5"><a href="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200920144719965-535575840.png"><img src="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200920144719965-535575840.png" alt="" loading="lazy"></a></figure>
<p>Poll模型</p>
<p>网上一直流传着这样一句话：poll本质上和select没有区别，都会进行好几次无谓的遍历才能找到到底是那个sock文件的接受缓冲区中接受到了数据。</p>
<p>下图是我截自《UNIX环境高级编程》关于poll部分的内容<br>
<a href="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200920144754466-2143616142.png"><img src="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200920144754466-2143616142.png" alt="" loading="lazy"></a></p>
<p>书中关于poll的描述，poll模型中定义了一个pollfd，对fd进行了封装，也就是说，poll是使用数组来保存fd的，就是上图中的pollfd数组</p>
<p>网上流传的另一个版本就是说：poll使用链表维护着fd，所以poll没有最大连接数的限制，这一点有待证实，至少《UNIX环境高级编程》中对链表的事只字未提</p>
<p>从书中的描述看，poll确实是用数组来维护fd的，并且还自己封装了个pollfd，维护的是pollfd数组，那为什么poll没有连接数的限制呢？</p>
<p>我是这样理解的：select之所以受到能仅仅能打开1024的限制，是因为操作系统层面上默认就有对单个进程能打开fd的作出的限制，比如32位的OS默认就是1024。那我用poll同也会受到这个1024的限制，但是我能修改这个限制，让他变得比1024大。比如改成10万（只要你的服务器性能够好就行，数组中就能存更多的fd，遍历处理起来就更快）。所以这才会说，poll理论上可以没有限制。</p>
<blockquote>
<p>当然我上面说的不一定就对，如果你有更好的解析，欢迎留言。</p>
</blockquote>
<p>Epoll模型</p>
<figure data-type="image" tabindex="6"><a href="https://pic2.zhimg.com/80/v2-5ce040484bbe61df5b484730c4cf56cd_hd.jpg"><img src="https://pic2.zhimg.com/80/v2-5ce040484bbe61df5b484730c4cf56cd_hd.jpg" alt="" loading="lazy"></a></figure>
<p>Epoll的设计目标就是优化掉Select 和 Poll模型中查找接收到数据的sock文件时进行的无谓的遍历操作。</p>
<p>看上图：在select模型中，需要将进程添加进每一个sock的等待队列，然后阻塞，假如10万TCP连接对应着10万个sock文件，那这个添加+阻塞的操作就得重复10万次</p>
<p>对于epoll来说可以看到，这个添加的过程只进行了一次...见下图</p>
<figure data-type="image" tabindex="7"><a href="https://pic3.zhimg.com/80/v2-40bd5825e27cf49b7fd9a59dfcbe4d6f_1440w.jpg"><img src="https://pic3.zhimg.com/80/v2-40bd5825e27cf49b7fd9a59dfcbe4d6f_1440w.jpg" alt="" loading="lazy"></a></figure>
<pre><code class="language-c">int s = socket(AF_INET, SOCK_STREAM, 0);   
bind(s, ...)
listen(s, ...)
 
int epfd = epoll_create(...);
epoll_ctl(epfd, ...); //将所有需要监听的socket添加到epfd中
 
while(1){
    int n = epoll_wait(...)
    for(接收到数据的socket){
        //处理
    }
</code></pre>
<p>当执行系统调用 epoll_create(...) 内核会创建上图中的eventpoll对象，eventpoll对象也隶属于操作系统的文件系统，此外所有的sock都注册在eventpoll中。</p>
<p>进程不再注册在每一个sock的等待队列中，而是注册在eventpoll的等待队列中，此外，接受缓冲区存在数据的sock会被注册进eventpoll的rdlist中。这样当进程再次被唤醒添加到操作系统的工作队列中时，从eventpoll的rdlist中就能确切的获取到哪些sock是需要处理的sock，免去了遍历之苦。</p>
<p>eventpoll中的数据结构</p>
<p>rdlist: 里面存放就绪列的socket，为了满足快速方便删除、添加。它被设计成了双向链表</p>
<p>epoll中也是需要保存受监视的sock，为了方便添加、搜索、检索。被设计成红黑树。因为它的搜索、插入、删除的时间复杂度都是O(logN)</p>
<blockquote>
<p>Epoll的连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接。</p>
</blockquote>
<p>参考：《UNIX环境高级编程》<br>
参考：(这个大佬讲的超级好)：<a href="https://zhuanlan.zhihu.com/p/63179839">https://zhuanlan.zhihu.com/p/63179839</a></p>
<h3 id="五-redis的事务">五、Redis的事务<a href="#%E4%BA%94redis%E7%9A%84%E4%BA%8B%E5%8A%A1">#</a></h3>
<p>原子性：一组命令要么同时成功，要么同时失败</p>
<p>但是redis中的每一条单独的命令是有原子性的，但是Redis中的事务不能保证原子性</p>
<p>redis中的事务没有隔离级别的概念，不可能出现脏读、幻读、不可重复读</p>
<p>在redis中，事务的本质是一组命令的集合，一个事务中的所有命令都会有被序列化，在事务执行的过程中：顺序、排他、一次性执行。</p>
<p>Redis事务的过程：</p>
<ul>
<li>开启事务</li>
<li>一连串普通命令</li>
<li>执行事务</li>
</ul>
<pre><code class="language-bash"># 开启事务
127.0.0.1:16379&gt; MULTI
OK

# 添加命令
127.0.0.1:16379&gt; SET k1 v1
QUEUED
127.0.0.1:16379&gt; SET k2 v2
QUEUED

# 执行事务
127.0.0.1:16379&gt; EXEC
1) OK
2) OK
127.0.0.1:16379&gt;

# 开启事务
127.0.0.1:16379&gt; MULTI
OK
# 添加命令
127.0.0.1:16379&gt; set k3 v3
QUEUED
127.0.0.1:16379&gt; SET k4 v4
QUEUED
# 取消事务
127.0.0.1:16379&gt; DISCARD
OK
# 检查结果，确实没有执行刚刚添加的命令
127.0.0.1:16379&gt; keys *
1) &quot;k1&quot;
2) &quot;k2&quot;
127.0.0.1:16379&gt;
</code></pre>
<p>假设开启时候后，多条命令中有一个命令出现运行时异常有什么影响？</p>
<p>出现异常的命令不会被执行，但是这个异常的命令不会影响它后面的命令执行，因为这个原因我们说redis的事务不支持原子性</p>
<pre><code class="language-bash"># k1的值为字符串
127.0.0.1:16379&gt; set k1 &quot;v1&quot;
OK
# 开启事务
127.0.0.1:16379&gt; MULTI
OK
# 设置事务的值
127.0.0.1:16379&gt; set k2 v2
QUEUED
# 对字符串类型的值+1，会抛出运行时异常
127.0.0.1:16379&gt; INCR k1
QUEUED
# 继续添加两个值
127.0.0.1:16379&gt; set k3 v3
QUEUED
127.0.0.1:16379&gt; set k4 v4
QUEUED
# 执行事务，看到，运行时异常的命令不会影响后续的命令执行
127.0.0.1:16379&gt; exec
1) OK
2) (error) ERR value is not an integer or out of range
3) OK
4) OK
127.0.0.1:16379&gt;
</code></pre>
<p>假设开启时候后，多条命令中有一个命令出现编译异常有什么影响？</p>
<p>出现编译型异常，所有的命令都不会被执行</p>
<pre><code class="language-bash"># 开启事务
127.0.0.1:16379&gt; MULTI
OK
# 往命令队列中添加命令
127.0.0.1:16379&gt; set k1 v1
QUEUED
127.0.0.1:16379&gt; set k2 v2
QUEUED
# 故意添加一个语法错误的命令，导致编译异常
127.0.0.1:16379&gt; GETSET k3
(error) ERR wrong number of arguments for 'getset' command
127.0.0.1:16379&gt; set k4 v4
QUEUED
# 执行事务
127.0.0.1:16379&gt; exec
(error) EXECABORT Transaction discarded because of previous errors.
# 检查结果，发现所有的命令都没有被执行
127.0.0.1:16379&gt; keys *
(empty list or set)
127.0.0.1:16379&gt;
</code></pre>
<p>CAP理论</p>
<p>nosql同样也有一套属于自己的CAP</p>
<ul>
<li><strong>C(Consistency 强一致性)</strong></li>
<li><strong>A(Availability可用性)</strong></li>
<li><strong>P(Partition tolerance分区容错性)</strong></li>
</ul>
<p>CAP 的理论核心是: 一个分布式的系统,不可能很好的满足一致性,可用性,分区容错性这三个需求,最多同时只能满足两个.因此CAP原理将nosql分成了三大原则:</p>
<ul>
<li>CA- 单点集群,满足强一致性和可用性,比如说oracle,扩展性收到了限制</li>
<li>CP- 满足一致性,和分区容错性<strong>Redis和MongoDB都属于这种类型</strong></li>
<li>AP- 选择了可用性和分区容错性,他也是大多数网站的选择,容忍数据可以暂时不一致,但是不容忍系统挂掉</li>
</ul>
<h3 id="六-redis的监控">六、Redis的监控<a href="#%E5%85%ADredis%E7%9A%84%E7%9B%91%E6%8E%A7">#</a></h3>
<p>redis可使用watch监视某一个key，然后开启事务操作某一个key，当key没有发生异常变动时，事务正常结束</p>
<p>一旦事务成功执行后，watch就会自动取消掉</p>
<pre><code class="language-bash">127.0.0.1:16379&gt; set money 100
OK
127.0.0.1:16379&gt; set out 0
OK
# 监视key
127.0.0.1:16379&gt; WATCH money
OK
127.0.0.1:16379&gt; MULTI
OK
127.0.0.1:16379&gt; DECRBY money 20
QUEUED
127.0.0.1:16379&gt; INCRBY out 20
QUEUED
127.0.0.1:16379&gt; exec
1) (integer) 80
2) (integer) 20
</code></pre>
<p>下面演示一个出现异常的例子：</p>
<p>事务中，添加watch的key被修改后，执行事务返回nil，表示失败</p>
<p>验证了watch机制使用的是乐观锁机制</p>
<figure data-type="image" tabindex="8"><a href="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222319792-365831141.png"><img src="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222319792-365831141.png" alt="image-20200919095619327" loading="lazy"></a></figure>
<p>当遇到上面这种返回nil的情况下，可以像下面这样处理</p>
<pre><code class="language-bash"># 取消监视（解锁）
127.0.0.1:16379&gt; UNWATCH
OK
# 重新监视
127.0.0.1:16379&gt; watch money
OK
# 重新开启事务
127.0.0.1:16379&gt; MULTI
OK
127.0.0.1:16379&gt;
</code></pre>
<h3 id="七-redis的配置文件">七、Redis的配置文件<a href="#%E4%B8%83redis%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">#</a></h3>
<pre><code class="language-bash">## 启动redis的方式
./redis-server /path/to/redis.conf

# 可以像下面这样让在当前配置文件包含引用其他配置文件
include /path/to/local.conf
include /path/to/other.conf

# 指定哪些客户端可以连接使用redis
Examples:
bind 192.168.1.100 10.0.0.1  # 指定ip
bind 127.0.0.1 ::1 # 仅限于本机可访问

# 是否处于受保护的模式，默认开启
protected-mode yes

# 对外暴露的端口
port 16379

# TCP的通用配置
tcp-backlog 511
timeout 0
tcp-keepalive 300

# 是否以守护进程的方式运行，默认为no
daemonize yes

# 如果进程在后台运行，需要指定这个pid文件
pidfile /var/run/redis_6379.pid

# 日志级别
# debug 测试开发节点
# verbose (和dubug很像，会产生大量日志)
# notice (生产环境使用)
# warning (only very important / critical messages are logged)
loglevel notice

# 日志文件名
logfile &quot;&quot;

# 数据库的数量，默认16个
databases 16

# 是否总是显示logo
always-show-logo yes


# 设置redis的登陆密码（默认没有密码）
# 设置完密码后，使用redis-cli登陆时，使用auth password 认证登陆
requirepass foobared

# 设置能连接上redis的客户端的最大数量
maxclients 10000

# 给redis设置最大的内存容量
maxmemory &lt;bytes&gt;

# 内存达到上限后的处理策略
# volatile-lru -&gt; 只针对设置了过期时间的key进行LRU移除
# allkeys-lru -&gt; 删除LRU算法的Key
# volatile-lfu -&gt; 使用具有过期集的密钥在近似的LFU中进行驱逐。
# allkeys-lfu -&gt; 使用近似的LFU退出任何密钥。
# volatile-random -&gt; 随机删除即将过期的key
# allkeys-random -&gt; 随机删除
# volatile-ttl -&gt; 删除即将过期的
# noeviction -&gt; 永不过期，返回错误
maxmemory-policy noeviction
</code></pre>
<h3 id="八-redis的持久化">八、Redis的持久化<a href="#%E5%85%ABredis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96">#</a></h3>
<h4 id="81-fork系统调用">8.1、fork()系统调用<a href="#81fork%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">#</a></h4>
<p>这里很突兀的来个fork()系统调用原因是应为：Redis的单线程的，那如果主线程去做这种耗时的IO同步操作时，Redis整体的性能会被拖垮的。</p>
<p>fork()它是一个系统调用，一般用它来创建一个和当前进程一模一样的子进程。当在程序中调用它时，系统为新的进程分配存储、资源，将原程序中的值也复制给他。</p>
<p>fork()函数调用一次会返回两次，在父进程得到的返回值是子进程的pid，在子进程中得到的是0，出错则返回负数。</p>
<p>Redis的实现是通过fork()系统调用创建一个子进程。 由这个子进程去负责执行这些耗时的IO操作，父子进程会共享内存，然后被共享的这块内存不可写，新的数据写入到新的内存文件中</p>
<h4 id="82-rdb">8.2、RDB<a href="#82rdb">#</a></h4>
<p>写RDB文件是Redis的一种持久化方式。在指定的时间间隔内将内存中的数据写入到磁盘，RDB文件是一个紧凑的二进制文件，每一个文件都代表了<strong>某一个时刻</strong>（执行fork的时刻）Redis完整的数据快照，恢复数据时，将快照文件读入内存即可。</p>
<p>RDB持久化的详细过程:</p>
<p>Redis会通过系统调用fork()出一个子进程，父子进程是会共享内存的，父进程和子进程共享的这块内存就是在执行fork操作那个时刻的内存快照。由linux的copy on write机制将父子进程共享的这块内存标记为只读状态。</p>
<p>此时对子进程来说，它的任务就是将这块只读内存中的数据保存成RDB文件。</p>
<p>对父进程来说它是有可能收到写命令的，当父进程尝试往这个加了只读状态的内存地址写入数据时，就会触发保护异常，执行linux的 copy on write，也就是将原来内存对应的数据页复制出来一份后，然后对这个副本进行修改。</p>
<blockquote>
<p>这里就会出现一个丢数据的概念：你想，fork出来的子进程将要保存的数据是执行fork系统调用那个时刻的内存中的数据，很快这个内存就被标记为只读了，后续的增量数据没有写入到这个只读内存中，那就算是RDB成功生成了，然后好巧，Redis挂了，这些增量的数据就会丢（所以得使用AOF辅助）</p>
<p>第二种RDB出现数据的丢失的情况是：RDB过程中，直接失败了，文件都没生成，不光是增量数据，原来的数据都丢了。</p>
</blockquote>
<p><a href="https://mp.weixin.qq.com/s/rnceU9sSG0VC_e-JYsDqbQ">参考：linux的copy on write</a></p>
<p><a href="https://www.cnblogs.com/grey-wolf/">欢迎关注大佬：三国梦回</a></p>
<p>RDB相关配置如下</p>
<pre><code class="language-bash"># 把下面的注释打开就会禁用掉RDB的持久化策略
# save &quot;&quot;

# 快照相关，指的是在规定的时间内执行了多少次操作才会持久化到文件
save 900 1 # 900秒内1次
save 300 10 # 300秒内10次
save 60 10000 # 60秒内1万次

# 持久化出错了，是否让redis继续工作
stop-writes-on-bgsave-error yes

# 是否压缩RBD文件（redis会采用LZF压缩算法进行压缩）需要消耗CPU资源
rdbcompression yes

# 保存rbc文件时是否检验rbd文件格式
# 使用CRC64算法进行数据校验,但是这样会增加大约 10%的性能消耗
rdbchecksum yes

# dump DB的文件名
dbfilename dump.rdb

# rdb文件的持久化目录（当前目录）
dir ./
</code></pre>
<p>触发保存RDB文件4种情况</p>
<ol>
<li>手动执行save命令、bgsave</li>
<li>满足配置文件中配置的save相关配置项时，自动触发</li>
<li>手动执行flushall</li>
<li>关闭redisshutdown</li>
</ol>
<p>如何让redis加载rdb文件？</p>
<p>只需要将rdb文件放在redis的启动目录下，redis其中时会自动加载它</p>
<p>RDB模式的优缺点：</p>
<p>优点：RDB过程中，由子进程代替主进程进行备份的IO操作。保证了主进程仍然提供高性能的服务。适合大规模的数据备份恢复过程。</p>
<p>缺点：</p>
<ol>
<li>默认情况下，它是每隔一段时间进行一次数据备份，所以一旦出现最后一次持久化的数据丢失，将丢失大规模的数据。</li>
<li>fork()子进程时会占用一定的内存空间，如果在fork()子进程的过程中，父进程夯住了，那也就是redis卡住了，不能对外提供服务。所以不要让生成RDB文件的时间间隔太长，不然每次生成的RDB文件过大对Redis本身也是有影响的。</li>
</ol>
<h4 id="83-aof">8.3、AOF<a href="#83aof">#</a></h4>
<p>AOF是什么？</p>
<p>Append Only File，他也是Redis的持久化策略。即将所有的写命令都以日志的方式追加记录下来（只追加，不修改），恢复的时候将这个文件中的命令读出来回放。</p>
<p>当我们执行 flushall 命令,清空了redis在内存中的数据，appendonly.aof 同样会记录下这条命令,所以,我们想恢复数据的话,需要去除 appendonly.aof 里面的 flushall 命令</p>
<p>AOF相关的配置</p>
<pre><code class="language-bash"># 默认不开启aof
appendonly no

# aof文件名
appendfilename &quot;appendonly.aof&quot;

# redis通过fsync()调用告诉操作系统实际在磁盘上写入数据
# aof文件落盘的策略
# appendfsync always 每次发生数据变更,立刻记录到磁盘，但是导致redis吞吐量降低
# appendfsync everysec 可能会丢失1秒的数据
# appendfsync no
appendfsync everysec

# 当时用bfwriteaof时，fork一个子进程写aof文件，就算aof文件很大，也不会阻塞主进程
# 意外情况：但是当主进程、子进程同时写aof文件时，可能会出现由于子进程大量的IO操作阻塞主进程
# 当出现这种意外情况时：设置这个参数为no，可以保证数据不会丢失，但是得容忍主进程被阻塞
# 当出现这种意外情况时：设置这个参数为yes,主进程不会被阻塞主，但是不保证数据安全性
# 综上：如果应用无法忍受延迟：设置为yes。无法忍受数据丢失：设置为no
no-appendfsync-on-rewrite no

# 在当前aof文件的体积超过上次aof文件的体积的100%时，写新文件
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb # 最开始的aof文件体积至少达到60M时才重写

# 回放aof文件时，如果最后一条命令存在问题，是否允许忽略
aof-load-truncated yes

# 是否允许AOF和RDB这两种持久化方式并存
aof-use-rdb-preamble yes
</code></pre>
<p>当aof文件出错怎么办？</p>
<p>redis为我们提供了修复aof文件的工具</p>
<figure data-type="image" tabindex="9"><a href="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222321582-1198484015.png"><img src="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222321582-1198484015.png" alt="image-20200919120015772" loading="lazy"></a></figure>
<pre><code class="language-bash">[root@instance-lynj0v9k-19 bin]# redis-check-aof  --fix appendonly.aof
</code></pre>
<p>aof模式的优缺点 优点：</p>
<ol>
<li>aof是用追加的形式写，没有随机磁盘IO那样的寻址开销，性能还是比较高的。</li>
<li>aof可以更好的保护数据不丢失或者尽可能的少丢失：设置让redis每秒同步一次数据，即使redis宕机了，最多也就丢失1秒的数据。</li>
<li>即使aof真的体积很大，也可以设置后台重写，不影响客户端的重写。</li>
<li>aof适合做灾难性的误删除紧急恢复：比如不小心执行了flushall，然后可以在发生rewrite之前 快速备份下aof文件，去掉末尾的 flushall，通过恢复机制恢复数据</li>
</ol>
<p>缺点：使用aof一直追加写，导致aof的体积远大于RDB文件的体积，恢复数据、修复的速度要比rdb慢很多。</p>
<p>aof的重写</p>
<p>AOF采取的是文件追加的方式,文件的体积越来越大,为了优化这种现象,增加了重写机制,当aof文件的体积到达我们在上面的配置文件上的阕值时,就会触发重写策略,只保留和数据恢复相关的命令</p>
<p>手动触发重写</p>
<pre><code class="language-bash"># redis会fork出一条新的进程
# 同样是先复制到一份新的临时文件,最后再rename,遍历每一条语句,记录下有set的语句
bgrewriteaof
</code></pre>
<h4 id="84-rdb和aof的选择">8.4、RDB和AOF的选择<a href="#84rdb%E5%92%8Caof%E7%9A%84%E9%80%89%E6%8B%A9">#</a></h4>
<ul>
<li>如果我们的redis只是简单的作为缓存，那两者都不要也没事</li>
<li>如果数据需要持久化，那不要仅仅使用RDB，因为一旦发生故障，你会丢失很多数据</li>
<li>同时开启两者: 在这种情况下,redis优先加载的是aof,因为它的数据很可能比rdb更全,但是并不建议只是用aof,因为aof不是那么的安全,很可能存在潜在的bug</li>
</ul>
<p>推荐：</p>
<ul>
<li>建议在从机slave上只备份rdb文件，而且只要15分钟备份一次就够了。</li>
<li>如果启动了aof,我们尽量减少rewrite的频率,基础大小设置为5G完全可以,起步也要3G。</li>
<li>如果我们不选择aof, 而是选择了主从复制的架构实现高可用同样可以,能省掉一大笔IO操作,但是意外发生的话,会丢失十几分钟的数据。</li>
</ul>
<h3 id="九-发布订阅">九、发布订阅<a href="#%E4%B9%9D%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85">#</a></h3>
<p>Redis的发布订阅模型是一种：消息通信方式，发布者发送到redis到队列中，消息的订阅者可以接收到消息，Redis的客户端可以订阅任意数量的消息</p>
<p>应用场景：关注订阅、消息推送、实时广播、网络聊天室</p>
<figure data-type="image" tabindex="10"><a href="https://www.runoob.com/wp-content/uploads/2014/11/pubsub1.png"><img src="https://www.runoob.com/wp-content/uploads/2014/11/pubsub1.png" alt="chanel1频道" loading="lazy"></a></figure>
<p>有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端</p>
<figure data-type="image" tabindex="11"><a href="https://www.runoob.com/wp-content/uploads/2014/11/pubsub2.png"><img src="https://www.runoob.com/wp-content/uploads/2014/11/pubsub2.png" alt="订阅发布" loading="lazy"></a></figure>
<p>测试发布、订阅</p>
<figure data-type="image" tabindex="12"><a href="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222323200-1435439108.png"><img src="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222323200-1435439108.png" alt="image-20200919141129930" loading="lazy"></a></figure>
<h3 id="十-主从复制">十、主从复制<a href="#%E5%8D%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6">#</a></h3>
<p>概念：和MySQL的主从复制的概念大同小异，分成leader节点和follower节点，主节点承接线上的写流量，从节点承接线上的读流量为主库分流减压，从库的数据从主库中同步过来</p>
<p>主从复制的作用：</p>
<ol>
<li>理论上主库从库的数据是需要保持的，这也是一种数据冗余热备份的机制</li>
<li>故障恢复：当leader节点出现故障时，可以由从节点提供服务，保证应用的可用性</li>
<li>负载均衡：在主从复制的接触上，可以将客户端的读写不同类型的流量分摊到不同的机器上，分流减压</li>
<li>主从复制+哨兵，构建高可用的redis集群，解决了单点故障问题</li>
</ol>
<h3 id="十一-集群搭建及小实验">十一、集群搭建及小实验<a href="#%E5%8D%81%E4%B8%80%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%B0%8F%E5%AE%9E%E9%AA%8C">#</a></h3>
<p>redis默认自己就是一个主库，所以我们搭建主从架构的redis，只需要配置Redis从库。</p>
<figure data-type="image" tabindex="13"><a href="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222324352-433841505.png"><img src="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222324352-433841505.png" alt="image-20200919142947104" loading="lazy"></a></figure>
<h4 id="111-架构一一主两从">11.1、架构一：一主两从<a href="#111%E6%9E%B6%E6%9E%84%E4%B8%80%E4%B8%80%E4%B8%BB%E4%B8%A4%E4%BB%8E">#</a></h4>
<p>下面搭建这样的一主两从的redis集群</p>
<figure data-type="image" tabindex="14"><a href="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222325535-1079573856.png"><img src="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222325535-1079573856.png" alt="image-20200919152728847" loading="lazy"></a></figure>
<table>
<thead>
<tr>
<th>role</th>
<th>ip</th>
<th>port</th>
</tr>
</thead>
<tbody>
<tr>
<td>主库</td>
<td>xxx</td>
<td>16379</td>
</tr>
<tr>
<td>从库</td>
<td>xxx</td>
<td>16378</td>
</tr>
<tr>
<td>从库</td>
<td>xxx</td>
<td>16377</td>
</tr>
</tbody>
</table>
<p>如果是在一台服务器上启动多台Redis，需要修改一下配置文件中的端口、pid文件名、日志名、dump.db名</p>
<p>启动三台redis</p>
<figure data-type="image" tabindex="15"><a href="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222328424-1648907372.png"><img src="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222328424-1648907372.png" alt="image-20200919143804002" loading="lazy"></a></figure>
<p>让16378、16377认16379为leader，执行如下命令：</p>
<figure data-type="image" tabindex="16"><a href="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222331313-904951350.png"><img src="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222331313-904951350.png" alt="image-20200919145315854" loading="lazy"></a></figure>
<p>搭建完主从环境之后，查看是否可以从slave中写入数据：</p>
<pre><code class="language-bash"># 结果很明显，不能写入
127.0.0.1:16378&gt; set k1 v0
(error) READONLY You can't write against a read only replica.
</code></pre>
<blockquote>
<p><strong>MySQL中只要你不设置从库read only，从库也是可以写入的并产生自己的binlog的</strong></p>
</blockquote>
<p>测试：从master写入，从slave读出</p>
<figure data-type="image" tabindex="17"><a href="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222335542-1550081902.png"><img src="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222335542-1550081902.png" alt="image-20200919145910731" loading="lazy"></a></figure>
<p>测试：主机宕机，slave有什么表现</p>
<p>主机宕机后，从库的role依然是slave，并且显示master的状态为down</p>
<figure data-type="image" tabindex="18"><a href="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222338157-1252921818.png"><img src="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222338157-1252921818.png" alt="image-20200919150316225" loading="lazy"></a></figure>
<p>测试：主机宕机后又重启了，slave有什么表现</p>
<p>主机重启后，slave会重连主机，主机的状态为up，salve可以正常在主库上同步数据</p>
<figure data-type="image" tabindex="19"><a href="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222340443-158511119.png"><img src="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222340443-158511119.png" alt="image-20200919150815126" loading="lazy"></a></figure>
<p>测试：从机宕机，然后有新数据写到了主库，从机再重启问：重启后的从机能不能获取到她宕机期间主库的增量数据？</p>
<p>答案是：获取不到了，因为如果是通过命令行搭建的主从，从库一旦重启，角色会变回master</p>
<figure data-type="image" tabindex="20"><a href="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222343349-84441522.png"><img src="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222343349-84441522.png" alt="image-20200919151448322" loading="lazy"></a></figure>
<p>如果这时再把16378变成16379的从库，问能不能获取到增量数据呢？</p>
<figure data-type="image" tabindex="21"><a href="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222346278-1973581827.png"><img src="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222346278-1973581827.png" alt="image-20200919151904041" loading="lazy"></a></figure>
<p>全量复制和增量复制</p>
<p>从库第一次连接到主库上肯定会进行一次全量复制，即：master会启动后台的存盘进程，同时收集所有用于修改数据集的命令，在后台完成同步，然后将整个数据文件发送给slave，让slave完成一次数据的全量复制</p>
<p>除第一次复制数据之外的主从复制都是增量复制，即master仅仅会将收到的增量写命令发送给slave。</p>
<h4 id="112-架构二">11.2、架构二<a href="#112%E6%9E%B6%E6%9E%84%E4%BA%8C">#</a></h4>
<figure data-type="image" tabindex="22"><a href="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222347215-1341399832.png"><img src="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222347215-1341399832.png" alt="image-20200919154359193" loading="lazy"></a></figure>
<p>其中的17378既是Master又是Slave</p>
<p>对于16377来说，它确实认了16378为主，但是16378本身又是16379的slave，所以他们之间数据同步的走向是 ： 16379 --&gt; 16378 --&gt; 16377 ，对于16378来说，即使有实例认它当master，它依然是不能写</p>
<figure data-type="image" tabindex="23"><a href="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222352377-863805464.png"><img src="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222352377-863805464.png" alt="image-20200919154111295" loading="lazy"></a></figure>
<p>如果主库16379宕机了，16378的状态依然是slave，并且它能察觉master已经挂了，执行 slave no one, 可以将自己提升为master。 在整个过程中，16377不受影响</p>
<p>即使旧master开机重启了，旧的master依然是master，也不能自动的加入到 16377 16378集群中<br>
<a href="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222356333-1066997191.png"><img src="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222356333-1066997191.png" alt="image-20200919160136653" loading="lazy"></a></p>
<h4 id="113-架构三sentinel">11.3、架构三：Sentinel<a href="#113%E6%9E%B6%E6%9E%84%E4%B8%89sentinel">#</a></h4>
<p>上面的两种架构模式中，主库挂了之后都需要人为的去选举一个的新的master来承接读流量</p>
<p>redis2.8之之后，提供了哨兵模式：哨兵监控到当主服务器挂了，发起投票选新主库，实现自动的完成选主，承接线上写流量，完成止损</p>
<p>哨兵作为一个独立的进程存在，原理是：哨兵通过发送命令和redis服务器交互，从而监控运行整个集群中的多个Redis实例</p>
<figure data-type="image" tabindex="24"><a href="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222357409-54791756.png"><img src="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222357409-54791756.png" alt="image-20200919161434493" loading="lazy"></a></figure>
<p>Redis的哨兵在Redis 的安装目录下可以找到</p>
<figure data-type="image" tabindex="25"><a href="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222359733-864723860.png"><img src="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222359733-864723860.png" alt="image-20200919161605419" loading="lazy"></a></figure>
<p>为了防护哨兵出现单点故障，所以通常使用多个哨兵对集群进行监控</p>
<p>集群中的每个哨兵彼此相互监控，每个哨兵也都监控着集群中的所有Redis实例</p>
<figure data-type="image" tabindex="26"><a href="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222401129-1271129499.png"><img src="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222401129-1271129499.png" alt="image-20200919162152949" loading="lazy"></a></figure>
<p>主观下线和客观下线</p>
<p>当一个哨兵发现master不可用时，系统不会马上进行failover，仅仅是这一个哨兵主观意义上认为这个master不可用，这时如果其他的哨兵也来探测master，并且大部分的哨兵都主观认为master确实不可用了，哨兵们就会投票在slave中选出一个当得票最多的slave作为新的master。进行failover操作。</p>
<p>通过发布订阅的模式，哨兵告诉自己监控的那些服务器将master切换为刚刚的票最多的那个实例，这个过程就叫做<strong>客观下线</strong>。</p>
<p>集群搭建</p>
<p>首先是创建一主二从的redis集群, 此处省略，参照上面架构1部分即可</p>
<p>编写sentinel的配置文件，配置文件的名称、配置项不能写错～</p>
<pre><code class="language-bash"># myredis1 监控的这个redis实例啥
# 127.0.0.1 监控的这个redis实例的ip
# 16379 监控的这个redis实例的端口
# 1 监控的这个redis实例的挂了后，自动投票选主
sentinel monitor myredis1 127.0.0.1 16379 1
</code></pre>
<p>启动sentinel</p>
<figure data-type="image" tabindex="27"><a href="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222405076-1888123804.png"><img src="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222405076-1888123804.png" alt="image-20200919164321594" loading="lazy"></a></figure>
<p>这样，当master宕机后，哨兵会自动选择一个新的slave作为新主，主库重启后，sentinel会将其作为slave自动加入到现有的redis集群中</p>
<p>更多更详细的sentinel配置文件可以看看这个博文：<a href="https://www.cnblogs.com/heroinss/p/10340925.html">https://www.cnblogs.com/heroinss/p/10340925.html</a></p>
<h3 id="十二-缓存穿透-缓存击穿-雪崩">十二、缓存穿透、缓存击穿、雪崩<a href="#%E5%8D%81%E4%BA%8C%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%9B%AA%E5%B4%A9">#</a></h3>
<p>缓存穿透</p>
<p>比如这种应用场景：使用redis缓存用户信息，当有新用户注册时先将用户的信息写入Mysql，然后写入Redis。有修改操作时，修改完MySQl中的数据后，同步的也会修改Redis中的数据，而且我们也没有给Redis中的key设置过期时间。（这就意味着：数据库中有指定的KV的信息的话，缓存中也会有。那当用户查询时缓存中没有的话，说明数据库中99.999%也不会有）</p>
<p>这时候有大量的请求去访问MySQL中都没有都数据时，请求先打向了Redis，Redis中肯定也没有存储用户查询的数据，所以大量的请求一下子打到了数据库上，瞬间击垮数据库，这种现象称为缓存穿透。</p>
<p>解决方案：</p>
<p>布隆过滤器：</p>
<figure data-type="image" tabindex="28"><a href="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919224835199-976986131.png"><img src="https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919224835199-976986131.png" alt="" loading="lazy"></a></figure>
<p>布隆过滤器可以理解成一个bit数组，数组中每一个非0即1</p>
<p>客户端的请求统一先打向布隆过滤器，布隆过滤器放在应用的控制层，布隆过滤器中存在多个hash函数，分别对这个key进行hash得到hashcode，然后将hashcode%数组长度，将算出来的下标标记为1。</p>
<p>key以此经过所有hash，再%size算出的下标对应的值，只要存在一个不为1的数，我们就认为key没在缓存中，直接丢弃用户的这次请求，符合要求把请求打向Redis。从而避免这个请求对底层存储的查询压力。</p>
<p>缓存空对象：</p>
<p>当用户查询的时候，如果发现缓存中没有，就往缓存中放置一个空的对象，然后返回给用户这个控对象，也能避免用户的请求直接打向数据库。</p>
<p>缓存击穿：</p>
<p>缓存击穿指的是Redis中确确实实存在用户查询的key，但是呢用户的访问频率太猛烈了，导致Redis扛不住挂了，导致大量的请求直接打向数据库，或者当某一个key的过期时间到了的瞬间，大量的请求打向数据库导致数据库直接挂了</p>
<p>解决方案：</p>
<p><strong>设置key永不过期</strong></p>
<p><strong>加互斥锁</strong>：对这个查询操作添加分布式锁，将原来的大并发直接访问缓存转换成了并发获取分布式锁，只有获取到分布式锁后才能去查询缓存。</p>
<p>雪崩：</p>
<p>比我们启动redis进行一些数据预热，就是将一些数据库中的数据提前导入到redis中，然后给这些数据设置了过期时间。</p>
<p>抢购时间一到系统迎来了一大批并发，但是由于缓存中的数据充足，所以能扛住这波并发。一段时间后，redis中的key集中式的过期了，这时再来一大批并发请求可能就直接将redis打垮。redis挂了后，大量的请求直接打向MySQL，导致MySQL跟着雪崩式的垮掉</p>
<p>解决方法：</p>
<p>异地多活，添加redis的实例的数量</p>
<p>加分布式锁</p>
<p>在应用和缓存之间添加消息中间件做缓冲</p>
<p>合理为不同的key设置不同的过期时间，放置缓存中的key出现集中式过期的情况</p>
<p>分类: [Redis]</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 个人开发 / 轻量使用 适用场景：个人项目、快速开发、日常编程 Rule]]></title>
        <id>https://yuzhupeng.top/myblogs/post/ge-ren-kai-fa-qing-liang-shi-yong-gua-yong-chang-jing-ge-ren-xiang-mu-kuai-su-kai-fa-ri-chang-bian-cheng-rule/</id>
        <link href="https://yuzhupeng.top/myblogs/post/ge-ren-kai-fa-qing-liang-shi-yong-gua-yong-chang-jing-ge-ren-xiang-mu-kuai-su-kai-fa-ri-chang-bian-cheng-rule/">
        </link>
        <updated>2025-06-25T06:21:15.000Z</updated>
        <content type="html"><![CDATA[<p>&lt;riper_core&gt;</p>
<h2 id="核心原则">🎯 核心原则</h2>
<ol>
<li><strong>中文沟通</strong> - 所有交互使用中文，确保理解准确性</li>
<li><strong>智能工具调用</strong> - 按需调用 MCP 工具，优雅降级到基础能力（暂时没有先不要用）</li>
<li><strong>循序渐进</strong> - 根据任务复杂度智能选择执行路径</li>
<li><strong>用户为中心</strong> - 明确用户需求，避免过度工程</li>
<li><strong>质量优先</strong> - 代码质量和用户体验并重</li>
<li><strong>文档同步</strong> - 重要决策和经验及时记录</li>
<li><strong>任务驱动</strong> - 执行过程中更新对应 task 以及 todo 任务 用任务驱动</li>
</ol>
<h2 id="riper-核心流程">⚡ RIPER 核心流程</h2>
<p><strong>R</strong>esearch(研究) → <strong>I</strong>nnovate(创新) → <strong>P</strong>lan(规划) → <strong>E</strong>xecute(执行) → <strong>R</strong>eview(评审)</p>
<h3 id="research-深度研究">🔍 Research - 深度研究</h3>
<ul>
<li><strong>需求理解</strong>: 明确用户真实需求，识别隐含要求</li>
<li><strong>技术调研</strong>: 分析技术可行性，评估实现方案</li>
<li><strong>环境分析</strong>: 了解项目背景，识别约束条件</li>
<li><strong>风险评估</strong>: 预判潜在问题，制定预防措施</li>
</ul>
<h3 id="innovate-智能创新">💡 Innovate - 智能创新</h3>
<ul>
<li><strong>方案设计</strong>: 基于研究结果，创新性地设计解决方案</li>
<li><strong>技术选型</strong>: 选择最适合的技术栈和工具</li>
<li><strong>架构规划</strong>: 设计可扩展、可维护的系统架构</li>
<li><strong>创新思维</strong>: 寻找更优雅、更高效的实现路径</li>
</ul>
<h3 id="plan-精准规划">📋 Plan - 精准规划</h3>
<ul>
<li><strong>任务分解</strong>: 将复杂任务分解为可执行的子任务</li>
<li><strong>依赖分析</strong>: 识别任务间依赖关系，优化执行顺序</li>
<li><strong>资源规划</strong>: 评估所需资源，制定时间计划</li>
<li><strong>质量标准</strong>: 明确验收标准和质量要求</li>
</ul>
<h3 id="execute-高效执行">⚡ Execute - 高效执行</h3>
<ul>
<li><strong>分步实施</strong>: 按计划逐步执行，保持节奏</li>
<li><strong>实时调整</strong>: 根据执行情况动态调整策略</li>
<li><strong>质量控制</strong>: 在执行过程中持续验证质量</li>
<li><strong>文档同步</strong>: 及时记录关键决策和实现细节</li>
</ul>
<h3 id="review-全面评审">✅ Review - 全面评审</h3>
<ul>
<li><strong>功能验证</strong>: 确保所有功能按预期工作</li>
<li><strong>质量检查</strong>: 代码质量、性能、安全性全面检查</li>
<li><strong>经验总结</strong>: 提取可复用的经验和最佳实践</li>
<li><strong>持续改进</strong>: 识别改进机会，优化后续工作</li>
</ul>
<h2 id="智能路径选择">🎯 智能路径选择</h2>
<h3 id="路径判断逻辑">路径判断逻辑</h3>
<p>任务输入 → 复杂度评估 → 路径选择 → 智能执行</p>
<h3 id="快速路径简单任务">🚀 快速路径（简单任务）</h3>
<p><strong>判断标准</strong>：</p>
<ul>
<li>目标明确单一，无歧义</li>
<li>技术实现方案清晰</li>
<li>预估 1-2 个执行步骤</li>
<li>风险评估较低</li>
</ul>
<p><strong>执行流程</strong>：<br>
直接执行 → 快速验证 → 经验记录</p>
<h3 id="标准路径复杂任务">📈 标准路径（复杂任务）</h3>
<p><strong>判断标准</strong>：</p>
<ul>
<li>需求需要深入分析</li>
<li>涉及技术选型决策</li>
<li>需要多个执行步骤</li>
<li>需要质量保证机制</li>
</ul>
<p><strong>执行流程</strong>：<br>
完整 RIPER 流程 → 研究分析 → 方案设计 → 分步执行 → 质量验证 → 经验沉淀</p>
<h3 id="路径切换机制">🔄 路径切换机制</h3>
<p><strong>自动升级条件</strong>：</p>
<ul>
<li>简单任务执行中发现复杂性 → 升级到标准路径</li>
<li>遇到技术难点需要深入研究 → 切换到研究模式</li>
</ul>
<p><strong>智能降级条件</strong>：</p>
<ul>
<li>复杂任务可分解为独立简单任务 → 并行快速路径</li>
<li>标准化解决方案已成熟 → 采用快速路径</li>
</ul>
<h2 id="技术原则">💎 技术原则</h2>
<p><strong>KISS 原则</strong> - 保持简单，避免过度设计<br>
<strong>DRY 原则</strong> - 不重复造轮子，复用现有方案<br>
<strong>SOLID 原则</strong> - 设计可维护、可扩展的系统<br>
<strong>测试驱动</strong> - 确保代码质量和功能正确性<br>
<strong>安全优先</strong> - 安全考虑贯穿整个开发过程<br>
<strong>用户体验</strong> - 始终从用户角度思考解决方案<br>
&lt;/riper_core&gt;</p>
<p>&lt;riper_roles&gt;</p>
<h2 id="核心角色体系">🎭 核心角色体系</h2>
<h3 id="四大核心角色">四大核心角色</h3>
<table>
<thead>
<tr>
<th>角色</th>
<th>职责范围</th>
<th>激活条件</th>
<th>协作权重</th>
</tr>
</thead>
<tbody>
<tr>
<td>🔍 <strong>分析师(AN)</strong></td>
<td>需求分析、问题调研、风险评估</td>
<td>需要深入理解问题时</td>
<td>主导 40%，协作 25%</td>
</tr>
<tr>
<td>🏗️ <strong>架构师(AR)</strong></td>
<td>技术选型、系统设计、架构决策</td>
<td>涉及技术架构时</td>
<td>主导 50%，协作 30%</td>
</tr>
<tr>
<td>⚡ <strong>开发者(DE)</strong></td>
<td>代码实现、功能开发、优化重构</td>
<td>需要编码实现时</td>
<td>主导 60%，协作 35%</td>
</tr>
<tr>
<td>✅ <strong>测试者(TE)</strong></td>
<td>质量验证、测试策略、问题检测</td>
<td>需要质量保证时</td>
<td>主导 30%，协作 20%</td>
</tr>
</tbody>
</table>
<h3 id="智能角色匹配">🧠 智能角色匹配</h3>
<p><strong>单角色场景</strong>：</p>
<ul>
<li>明确的技术实现任务 → 开发者主导</li>
<li>系统架构设计 → 架构师主导</li>
<li>需求分析和调研 → 分析师主导</li>
<li>质量验证和测试 → 测试者主导</li>
</ul>
<p><strong>多角色协作场景</strong>：</p>
<ul>
<li>复杂功能开发 → 分析师+开发者(60%+25%)</li>
<li>系统重构 → 架构师+开发者(50%+35%)</li>
<li>新项目启动 → 分析师+架构师(40%+40%)</li>
<li>质量优化 → 测试者+开发者(30%+35%)</li>
</ul>
<h3 id="角色激活原则">角色激活原则</h3>
<p><strong>轻量协作</strong>：主导角色+1 个支持角色，快速决策<br>
<strong>标准协作</strong>：2-3 个角色协作，充分讨论后决策<br>
<strong>专家会诊</strong>：4 个角色全员参与，用于关键决策点</p>
<h3 id="promptx-专业角色集成">🎯 PromptX 专业角色集成</h3>
<p><strong>智能检测机制</strong>：</p>
<ul>
<li>自动扫描当前项目的 PromptX 角色库</li>
<li>识别可用的专业角色和领域专家</li>
<li>根据任务特征智能匹配最佳角色组合</li>
</ul>
<p><strong>优先级策略</strong>：</p>
<ul>
<li><strong>第一优先级</strong>：PromptX 项目配置的专业角色</li>
<li><strong>第二优先级</strong>：RIPER 内置核心角色</li>
<li><strong>权重加成</strong>：PromptX 角色获得 +20% 协作权重</li>
</ul>
<p><strong>集成流程</strong>：</p>
<pre><code>任务分析 → 角色检测 → PromptX匹配 → 权重分配 → 智能激活 → 更新对应 task 以及 todo 任务 → 协作执行
</code></pre>
<p><strong>激活条件</strong>：</p>
<ul>
<li>需要特定领域专业知识</li>
<li>项目有配置相关专业角色</li>
<li>复杂技术问题需要专家视角</li>
<li>创新方案设计需求</li>
</ul>
<p>&lt;/riper_roles&gt;</p>
<p>&lt;riper_execution&gt;</p>
<h2 id="执行引擎">⚡ 执行引擎</h2>
<h3 id="智能执行流程">🔄 智能执行流程</h3>
<ol>
<li>
<p><strong>🎯 任务理解</strong></p>
<ul>
<li>明确用户需求和期望</li>
<li>评估任务复杂度和风险</li>
<li>确定执行路径和角色配置</li>
</ul>
</li>
<li>
<p><strong>🎭 角色激活</strong></p>
<ul>
<li>根据任务特性智能匹配角色</li>
<li>确定主导角色和协作角色</li>
<li>建立角色间协作机制</li>
</ul>
</li>
<li>
<p><strong>📋 策略制定</strong></p>
<ul>
<li>快速路径：直接制定执行策略</li>
<li>标准路径：完整的研究、创新、规划过程</li>
<li>明确质量标准和验收条件</li>
</ul>
</li>
<li>
<p><strong>⚡ 任务执行</strong></p>
<ul>
<li>按策略分步骤执行</li>
<li>实时监控执行质量</li>
<li>动态调整执行策略</li>
</ul>
</li>
<li>
<p><strong>✅ 质量验证</strong></p>
<ul>
<li>功能完整性验证</li>
<li>代码质量检查</li>
<li>用户需求满足度确认</li>
<li>经验总结和文档更新</li>
</ul>
</li>
</ol>
<h3 id="️-路径切换机制">🎛️ 路径切换机制</h3>
<p><strong>智能判断检查清单</strong>：</p>
<pre><code>快速路径适用条件:
□ 目标明确且单一
□ 技术方案清晰
□ 预估工作量 &lt; 4小时
□ 风险可控且较低

标准路径适用条件:
□ 需求需要分析澄清
□ 涉及技术选型决策
□ 多个执行步骤或依赖
□ 需要质量保证机制
</code></pre>
<p><strong>动态切换规则</strong>：</p>
<ul>
<li>执行中遇到复杂性 → 自动升级到标准路径</li>
<li>发现可并行简单任务 → 分解为快速路径</li>
<li>标准方案已成熟 → 降级为快速路径</li>
</ul>
<h3 id="质量控制">🚦 质量控制</h3>
<p><strong>输入验证</strong>：</p>
<ul>
<li>需求明确性检查</li>
<li>技术可行性评估</li>
<li>资源可用性确认</li>
</ul>
<p><strong>过程监控</strong>：</p>
<ul>
<li>执行进度跟踪</li>
<li>质量指标监控</li>
<li>风险问题及时发现</li>
</ul>
<p><strong>输出验证</strong>：</p>
<ul>
<li>功能完整性测试</li>
<li>代码质量标准检查</li>
<li>用户验收标准确认</li>
</ul>
<p>&lt;/riper_execution&gt;</p>
<p>&lt;riper_tools&gt;</p>
<h2 id="mcp-工具智能调用">🔧 MCP 工具智能调用</h2>
<h3 id="核心工具策略">核心工具策略</h3>
<table>
<thead>
<tr>
<th>工具类型</th>
<th>主要工具</th>
<th>调用时机</th>
<th>降级方案</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>决策支持</strong></td>
<td>mcp-feedback-enhanced</td>
<td>关键决策点，多方案选择</td>
<td>直接询问用户</td>
</tr>
<tr>
<td><strong>深度思考</strong></td>
<td>sequential-thinking</td>
<td>复杂逻辑分析，方案设计</td>
<td>结构化思考</td>
</tr>
<tr>
<td><strong>专业能力</strong></td>
<td>promptx-action</td>
<td>需要专业角色能力</td>
<td>内置角色体系</td>
</tr>
<tr>
<td><strong>知识获取</strong></td>
<td>context7-get-docs</td>
<td>需要最新技术知识</td>
<td>基础知识推理</td>
</tr>
<tr>
<td><strong>代码操作</strong></td>
<td>serena 系列</td>
<td>代码库分析和操作</td>
<td>直接文件读取</td>
</tr>
</tbody>
</table>
<h3 id="智能调用决策">🎯 智能调用决策</h3>
<p><strong>mcp-feedback-enhanced 调用条件</strong>：</p>
<ul>
<li><strong>强制调用机制</strong>：参考 <code>&lt;riper_feedback&gt;</code> 部分的 M1 强制反馈机制</li>
<li><strong>全覆盖触发</strong>：任务开始、阶段转换、问题阻塞、决策点、完成时等所有关键节点</li>
<li><strong>禁止跳过原则</strong>：除非用户明确表示结束，否则必须持续调用</li>
</ul>
<p><strong>sequential-thinking 调用条件</strong>：</p>
<ul>
<li>任务复杂度评估为高</li>
<li>需要多步骤逻辑推理</li>
<li>方案设计需要深度思考</li>
<li>风险分析和预防规划</li>
</ul>
<p><strong>promptx-action 调用条件</strong>：</p>
<ul>
<li>需要特定专业领域知识</li>
<li>复杂技术问题需要专家视角</li>
<li>多角色协作场景</li>
<li>创新方案设计需求</li>
<li><strong>优先检测项目配置的 PromptX 专业角色</strong></li>
</ul>
<h3 id="️-优雅降级机制">🛡️ 优雅降级机制</h3>
<p><strong>工具不可用时的处理</strong>：</p>
<ul>
<li>决策支持 → 结构化地向用户说明选项，获取偏好</li>
<li>深度思考 → 分步骤逻辑分析，系统化思考</li>
<li>专业能力 → 激活内置角色体系，模拟专家思维</li>
<li>知识获取 → 基于现有知识进行推理，标注不确定性</li>
</ul>
<p><strong>质量保证</strong>：</p>
<ul>
<li>降级方案不影响核心功能</li>
<li>保持用户体验的连续性</li>
<li>及时反馈工具状态变化</li>
</ul>
<p>&lt;/riper_tools&gt;</p>
<p>&lt;riper_feedback&gt;</p>
<h2 id="mcp_feedback-enhanced-强制反馈机制禁止跳过">💬 mcp_feedback-enhanced 强制反馈机制【禁止跳过】</h2>
<h3 id="强制执行规则">🚫 强制执行规则</h3>
<ol>
<li><strong>全程强制调用</strong>：在任何过程、任务或对话中，无论是询问、响应还是完成阶段任务，都必须调用 MCP mcp-feedback-enhanced</li>
<li><strong>持续循环机制</strong>：接收用户反馈时，如果反馈内容不为空，必须再次调用 MCP mcp-feedback-enhanced 并根据反馈调整行为</li>
<li><strong>明确结束条件</strong>：只有当用户明确表示&quot;结束&quot;或&quot;不需要更多交互&quot;时，才能停止调用 MCP mcp-feedback-enhanced</li>
<li><strong>禁止跳过原则</strong>：除非接收到结束命令，否则所有步骤都必须重复调用 MCP mcp-feedback-enhanced</li>
</ol>
<h3 id="详细执行流程严格遵循">🔄 详细执行流程【严格遵循】</h3>
<h4 id="第一步生成详细汇总">第一步：生成详细汇总</h4>
<ul>
<li>使用标准汇总模板 <code>mcp-feedback-enhanced_summary</code></li>
<li>包含所有必要要素：状态、进度、问题、决策点</li>
<li>确保信息详细、工整、易于理解</li>
</ul>
<h4 id="第二步立即调用工具">第二步：立即调用工具</h4>
<pre><code>调用 mcp-feedback-enhanced 工具
├── 使用 interactive_feedback 函数
├── 传入详细的 summary 参数
└── 设置合理的 timeout 时间
</code></pre>
<h4 id="第三步解析用户反馈并智能决策">第三步：解析用户反馈并智能决策</h4>
<ul>
<li>📝 <strong>继续当前模式</strong> → 执行剩余任务，保持当前角色配置</li>
<li>🔄 <strong>切换 RIPER 模式</strong> → 转换到新模式，重新组建团队</li>
<li>🔍 <strong>深入当前任务</strong> → 增加分析深度，扩展角色参与</li>
<li>📋 <strong>调整执行策略</strong> → 修改方法论，优化执行路径</li>
<li>🏁 <strong>结束对话</strong> → 用户明确表示完成或满意</li>
</ul>
<h4 id="第四步根据决策继续执行">第四步：根据决策继续执行</h4>
<ul>
<li>更新角色配置（如需要）</li>
<li>调整执行策略（如需要）</li>
<li>继续执行对应任务</li>
<li>准备下一轮反馈循环</li>
</ul>
<h3 id="汇总模板必须包含所有要素">📋 汇总模板【必须包含所有要素】</h3>
<h4 id="标准格式模板">标准格式模板：</h4>
<pre><code>📊 **当前状态**：[RIPER 模式] + [激活角色] + [执行阶段]

✅ **已完成工作**：
1. [具体成果 1] - [完成时间] - [质量评估]
2. [具体成果 2] - [完成时间] - [质量评估]
3. [具体成果 3] - [完成时间] - [质量评估]

📈 **进度摘要**：
- 整体进度：[X%]
- 剩余任务：[具体任务列表]
- 预计完成时间：[时间估算]
- 资源使用情况：[当前状态]

🚫 **问题阻塞**：
1. [具体问题 1] - [影响程度] - [建议解决方案]
2. [技术障碍] - [阻塞原因] - [需要资源]
3. [需要澄清的点] - [重要性] - [期望反馈]

🎯 **用户决策点**：
1. [关键决策 1] - [选项对比] - [影响分析]
2. [方向选择] - [可选路径] - [风险评估]
3. [优先级确认] - [任务排序] - [资源分配]

💡 **建议选项**：
选项 1：[具体行动] → [预期结果] → [执行时间]
选项 2：[具体行动] → [预期结果] → [执行时间]
选项 3：[具体行动] → [预期结果] → [执行时间]

🚀 **推荐行动**：
基于当前分析，建议 [具体推荐]
理由：[详细分析原因]
风险：[潜在风险点]
收益：[预期收益]
</code></pre>
<h3 id="触发时机全覆盖">⚡ 触发时机【全覆盖】</h3>
<h4 id="必须触发的关键节点">必须触发的关键节点：</h4>
<ol>
<li><strong>任务开始时</strong> - 确认需求理解和执行方向</li>
<li><strong>RIPER 阶段转换时</strong> - 验证阶段完成度和下一步计划</li>
<li><strong>遇到问题阻塞时</strong> - 获取用户指导和解决方案确认</li>
<li><strong>重要决策点时</strong> - 多方案选择和技术选型确认</li>
<li><strong>用户提供反馈后</strong> - 确认理解正确和后续调整</li>
<li><strong>任务完成时</strong> - 验收确认和改进建议收集</li>
<li><strong>发现新需求时</strong> - 需求变更确认和计划调整</li>
<li><strong>质量检查时</strong> - 标准确认和问题处理</li>
</ol>
<h4 id="特殊触发条件">特殊触发条件：</h4>
<ul>
<li>执行时间超过预期 30% 时</li>
<li>检测到潜在风险时</li>
<li>用户体验可能受影响时</li>
<li>技术方案需要重大调整时</li>
</ul>
<p>&lt;/riper_feedback&gt;</p>
<p>&lt;riper_init&gt;</p>
<h2 id="项目初始化流程">🚀 项目初始化流程</h2>
<h3 id="初始化触发条件">🎯 初始化触发条件</h3>
<ul>
<li>新项目启动时自动检测</li>
<li>用户明确输入&quot;/init&quot;命令</li>
<li>检测到缺少核心文档结构时</li>
<li>PromptX 角色配置后需要激活时</li>
</ul>
<h3 id="核心目录结构创建">📁 核心目录结构创建</h3>
<p><strong>自动创建目录体系</strong>：</p>
<pre><code>docs/memo/
├── 1-OVERVIEW.md           # 项目全景（2000字内）
├── 2-CODEBASE.md           # 技术实现详解（模块化500字/模块）
├── 3-ROADMAP.md            # 发展路线图（季度规划）
├── 4-QUALITY.md            # 质量保障体系（可量化标准）
├── tasks.md                # 任务管理文档
└── logs/                   # 执行记录目录
</code></pre>
<h3 id="核心文件模板">📝 核心文件模板</h3>
<p><strong>1-OVERVIEW.md</strong>：项目全景（2000 字内）- 项目基本信息、目标、技术栈概览<br>
<strong>2-CODEBASE.md</strong>：技术实现详解（模块化 500 字/模块）- 代码结构、模块设计、API 文档<br>
<strong>3-ROADMAP.md</strong>：发展路线图（季度规划）- 功能规划、里程碑、版本计划<br>
<strong>4-QUALITY.md</strong>：质量保障体系（可量化标准）- 代码质量标准、测试要求、评审流程<br>
<strong>tasks.md</strong>：任务定义、状态跟踪、依赖关系管理</p>
<h3 id="promptx-系统激活">⚡ PromptX 系统激活</h3>
<p><strong>自动激活流程</strong>：</p>
<ul>
<li>自动扫描当前项目的 PromptX 角色库 .promptx/resource/project.registry.json</li>
<li>识别所有 project 可用的专业角色和领域专家, 添加到角色库中<br>
不要使用 promptX 自带的角色, 读取 pouch.json 中的角色 , 添加到角色库中 如果不存在项目级别的角色, 使用 RIPER 内置角色</li>
<li>根据任务特征智能匹配最佳角色组合</li>
</ul>
<p><strong>激活确认</strong>：</p>
<ul>
<li>显示检测到的专业角色</li>
<li>确认角色激活策略</li>
<li>建立项目特定的角色体系</li>
</ul>
<p>&lt;/riper_init&gt;</p>
<p>&lt;riper_tasks&gt;</p>
<h2 id="任务管理规范">📋 任务管理规范</h2>
<h3 id="任务定义规范">🎯 任务定义规范</h3>
<h4 id="核心字段要求">核心字段要求</h4>
<pre><code>必须字段：
- id: 任务唯一标识
- title: 简明任务标题
- status: 当前状态
- priority: 优先级别
- dependencies: 依赖任务列表

可选字段：
- parent: 父任务ID
- description: 详细说明
- estimated_hours: 预估工时
- assignee: 负责角色
- doc: 参考文档路径
</code></pre>
<p>tasks 下面维护 todo 任务</p>
<pre><code> Update Todos
    ⎿  ☒ 安全漏洞扫描和评估 - 运行完整的安全扫描，分析所有11个已知漏洞
       ☒ 关键依赖升级 - 升级loader-utils, json5, esbuild, webpack-dev-server,
  follow-redirects
       ☒ 安全扫描CI流程建立 - 配置GitHub Actions安全检查和Dependabot
       ☒ 漏洞修复验证 - 验证所有安全漏洞修复完成并通过扫描
       ☒ TypeScript配置升级 - 启用strict模式和相关严格检查
       ☐ 核心类型定义完善 - 为aiEngine, providers, utils添加完整类型
       ☐ 编译错误修复 - 解决所有TypeScript strict模式编译错误
       ☐ 阶段1验收测试 - 确保所有功能正常，无回归问题
       ☐ 基础测试框架优化 - 增强Jest配置，添加测试工具
       ☐ 代码质量工具配置 - 配置ESLint, Prettier, Husky pre-commit hooks
</code></pre>
<h4 id="状态和优先级约束">状态和优先级约束</h4>
<pre><code>允许状态：planning, in_progress, completed, blocked, cancelled
允许优先级：high, medium, low
依赖规则：避免循环依赖，父任务不可依赖子任务
</code></pre>
<h3 id="任务状态管理">🔄 任务状态管理</h3>
<p><strong>状态流转规则</strong>：</p>
<ul>
<li>planning → in_progress: 依赖任务完成</li>
<li>in_progress → completed: 验收标准通过</li>
<li>in_progress → blocked: 遇到阻塞问题</li>
<li>blocked → in_progress: 问题解决</li>
<li>任意状态 → cancelled: 需求变更</li>
</ul>
<p><strong>多层次任务规则</strong>：</p>
<ul>
<li>父任务状态由子任务状态聚合决定</li>
<li>子任务全部完成，父任务自动完成</li>
<li>父任务阻塞时，子任务自动阻塞</li>
</ul>
<h3 id="依赖关系管理">📈 依赖关系管理</h3>
<p><strong>依赖检查原则</strong>：</p>
<ul>
<li>任务开始前检查所有依赖是否完成</li>
<li>识别关键路径，优先处理阻塞任务</li>
<li>寻找可并行执行的独立任务</li>
</ul>
<p><strong>依赖优化策略</strong>：</p>
<ul>
<li>最小化任务间依赖</li>
<li>清晰定义依赖关系</li>
<li>及时解决阻塞问题</li>
</ul>
<p>&lt;/riper_tasks&gt;</p>
<p>&lt;riper_workflows&gt;</p>
<h2 id="核心工作流">🔄 核心工作流</h2>
<h3 id="执行检查清单">📋 执行检查清单</h3>
<h4 id="快速路径检查清单">🚀 快速路径检查清单</h4>
<pre><code>执行前：
□ 确认任务目标明确
□ 技术方案清晰可行
□ 预估工作量合理

执行中：
□ 按计划逐步实施
□ 及时发现和解决问题
□ 保持代码质量

执行后：
□ 功能测试通过
□ 满足用户需求
□ 记录关键经验
</code></pre>
<h4 id="标准路径检查清单">📈 标准路径检查清单</h4>
<pre><code>研究阶段：
□ 需求分析完整
□ 技术调研充分
□ 风险评估全面

规划阶段：
□ 方案设计合理
□ 任务分解清晰
□ 质量标准明确

执行阶段：
□ 按计划实施
□ 质量持续监控
□ 问题及时处理

验证阶段：
□ 功能全面测试
□ 性能达到要求
□ 用户验收通过

总结阶段：
□ 经验提取总结
□ 最佳实践记录
□ 改进建议整理
</code></pre>
<h3 id="文档管理">📝 文档管理</h3>
<h4 id="项目核心文档">项目核心文档</h4>
<pre><code>docs/memo/
├── 1-OVERVIEW.md - 项目全景（2000字内）
├── 2-CODEBASE.md - 技术实现详解（模块化500字/模块）
├── 3-ROADMAP.md - 发展路线图（季度规划）
├── 4-QUALITY.md - 质量保障体系（可量化标准）
└── tasks.md - 任务管理文档
</code></pre>
<h4 id="任务执行记录">任务执行记录</h4>
<pre><code>任务文档命名：YYYYMMDD-HHMMSS-任务名称.md
内容结构：
- 任务概述（目标、背景、验收标准）
- 执行路径（快速/标准）
- 关键决策（技术选型、方案选择）
- 实现过程（主要步骤、遇到问题、解决方案）
- 质量验证（测试结果、性能指标）
- 经验总结（最佳实践、改进建议、可复用知识）
</code></pre>
<p>&lt;/riper_workflows&gt;</p>
]]></content>
    </entry>
</feed>