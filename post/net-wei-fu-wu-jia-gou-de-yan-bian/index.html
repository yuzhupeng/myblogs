<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>NET微服务架构的演变 | fishyue</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://yuzhupeng.top/myblogs//favicon.ico?v=1755503043926">
<link rel="stylesheet" href="https://yuzhupeng.top/myblogs//styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="NET微服务架构的演变
服务架构的演变

单体架构=&gt;分布式架构=&gt;SOA架构=&gt;微服务架构=&gt;Service Mesh=&gt;Cloud Native

单体架构/垂直架构

分布式架构

SOA架构

微服务架..." />
    <meta name="keywords" content="NET" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://yuzhupeng.top/myblogs/">
        <img src="https://yuzhupeng.top/myblogs//images/avatar.png?v=1755503043926" class="site-logo">
        <h1 class="site-title">fishyue</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/myblogs" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/myblogs/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/myblogs/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/myblogs/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/yuzhupeng" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      由奢入俭难，由俭入奢易
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/yuzhupeng" target="_blank">Fishyue</a> | <a class="rss" href="https://yuzhupeng.top/myblogs//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">NET微服务架构的演变</h2>
            <div class="post-date">2025-06-01</div>
            
            <div class="post-content" v-pre>
              <p>NET微服务架构的演变</p>
<h1 id="服务架构的演变">服务架构的演变</h1>
<blockquote>
<p>单体架构=&gt;分布式架构=&gt;SOA架构=&gt;微服务架构=&gt;Service Mesh=&gt;Cloud Native</p>
</blockquote>
<h2 id="单体架构垂直架构">单体架构/垂直架构</h2>
<figure data-type="image" tabindex="1"><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250525105841130-669816846.png" alt="Image 13: image" loading="lazy"></figure>
<h2 id="分布式架构">分布式架构</h2>
<figure data-type="image" tabindex="2"><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250525105834679-1121298161.png" alt="Image 14: image" loading="lazy"></figure>
<h2 id="soa架构">SOA架构</h2>
<figure data-type="image" tabindex="3"><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250525110505385-766738942.png" alt="Image 15: image" loading="lazy"></figure>
<h2 id="微服务架构">微服务架构</h2>
<figure data-type="image" tabindex="4"><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250525110731646-171717451.png" alt="Image 16: image" loading="lazy"></figure>
<h1 id="微服务架构的核心">微服务架构的核心</h1>
<blockquote>
<p>需要注意一点，微服务架构是分布式架构的一种落地，它们之间是接口与实现类的关系。</p>
</blockquote>
<h2 id="服务发现">服务发现</h2>
<blockquote>
<p>为什么需要服务发现？</p>
</blockquote>
<ol>
<li>服务实例的动态变化</li>
</ol>
<p>在水平架构中，我们的服务集群往往是通过Nginx/IIS的<code>静态配置</code>来实现节点的增/减。加上节点少，因此，每次修改节点配置都是人工修改。</p>
<p>而微服务架构天然的动态性与不确定性，服务实例通常需要动态扩容/缩容，故障重启，滚动升级等特点，因此服务示例的<code>网络地址是随时变化的</code>，加上微服务化之后，<code>服务实例呈指数级增加</code>，再由人工干预就不明智了。 2. 分布式环境的网络复杂性</p>
<p>服务实例可能步骤在不同的物理机，虚拟机，容器中，将它们整合非常麻烦，需要一个能够<code>屏蔽底层细节，提供统一入口</code>的组件，让调用方无需关心目标服务具体位置 3. 抽象网络地址</p>
<p>水平架构中，我们常常依赖IP+端口的形式来确定服务实例，在微服务架构中，使用Service-Name来提供一个<code>逻辑名称</code> 4. 去除不可用实例</p>
<p>通过<code>心跳访问</code>实例提供的Healthcheck，当某个实例故障时，自动去除，避免访问到不可用节点。</p>
<blockquote>
<p>简单来说，服务发现解决的是微服务实例之间的动态通信问题，主要用于内部服务间的调用。</p>
</blockquote>
<figure data-type="image" tabindex="5"><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250524132436118-1124537890.png" alt="Image 17: image" loading="lazy"></figure>
<h2 id="api网关">API网关</h2>
<blockquote>
<p>API 网关是什么，它具备什么功能?</p>
</blockquote>
<ol>
<li>统一路由</li>
</ol>
<p>根据请求路径将请求转发到后端实例，比如<a href="https://gateway.XXXXX.com/%E4%BD%A0%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%AE%9E%E4%BE%8B%E5%89%8D%E7%BC%80/user/%7Bid%7D">https://gateway.XXXXX.com/你的业务实例前缀/user/{id}</a>; 2. 协议转换</p>
<p>将前端的HTTP请求转换为服务内部的rbc协议 3. 身份认证与鉴权</p>
<p>集中处理JWT，OAuth2等鉴权操作，避免每个微服务都重复校验 4. 流量管理</p>
<p>实现服务的负载均衡，限流等操作，避免微服务收到冲击。 5. 日志与指标分析</p>
<p>作为统一入口，可以统一记录请求量，响应实践，成功率等指标，方便分析。</p>
<blockquote>
<p>感觉服务发现与API网关重合了？</p>
</blockquote>
<p>服务发现解决的是微服务实例之间的动态通信问题，主要用于<code>内部服务间的调用</code>。</p>
<p>API 网关是外部客户端访问微服务的统一入口，主要用于<code>客户端与微服务之间的通信</code>。</p>
<p>举个例子：</p>
<ol>
<li>客户端认证需求</li>
</ol>
<p>若没有API网关，客户端直接调用微服务，每个微服务都要重复检验用户的JWT。 2. 多协议支持</p>
<p>微服务内部使用gRPC协议，而客户端是HTTP协议，这中间无法转换。 3. 流量保护</p>
<p>服务发现仅能实现简单的负载均衡（如轮询），但 API 网关可通过限流策略（如令牌桶、漏桶算法）防止突发流量压垮后端服务，这是服务发现无法实现的 4. 数据聚合优化</p>
<p>比如客户端需要同时获取 user与order信息，若通过服务发现，需要分别调用user service与order service，产生多次网络请求，而API网关将多个响应结果合并为一个，减少客户端的请求量。</p>
<blockquote>
<p>有人可能会问了，我让服务发现与API网关合并就好了，这样不就大而全了？</p>
<p>合二为一的组件确实存在，如 Kong、Traefik、Istio Gateway 等，它们通过集成服务发现机制到网关中，简化了微服务架构的复杂度。</p>
</blockquote>
<figure data-type="image" tabindex="6"><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250525103053814-1346252574.png" alt="Image 18: image" loading="lazy"></figure>
<h2 id="服务发现与api网关如何协同工作">服务发现与API网关如何协同工作？</h2>
<ol>
<li>API网关接收客户端请求后，根据route规则确定service.</li>
</ol>
<p>比如<a href="https://gateway.XXXXX.com/user-service/user/%7Bid%7D">https://gateway.XXXXX.com/user-service/user/{id}</a></p>
<p>根据user-service前缀，便可确定需要调用哪个微服务。 2. 通过服务发现接口，查询获得可用服务列表</p>
<p>调用注册中心 API。 3. 选择一个实例转发</p>
<p>基于负载均衡策略 4. 微服务之间内部流转</p>
<p>微服务 A 调用微服务 B 时，直接通过服务发现获取 B 的实例地址，无需经过 API 网关。微服务之间走轻量级通信方式，比如gRPC，避免使用HTTP协议提高性能。</p>
<p><strong>网关+服务发现+服务实例=微服务架构的核心</strong>，这两个核心组件便已经组成了微服务基本实现，剩下的组件都是对微服务架构的<code>锦上添花</code>，但<code>不是雪中送炭</code>。</p>
<h2 id="为什么还有服务间负载均衡">为什么还有服务间负载均衡？</h2>
<p>API网关只负责外部HTTP请求，微服务内部之间通信不走API网关，因此需要一个服务间负载均衡的组件来承担内部流量的转发</p>
<h1 id="微服务架构的拓展">微服务架构的拓展</h1>
<figure data-type="image" tabindex="7"><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250525104132578-2097043458.png" alt="Image 19: image" loading="lazy"></figure>
<h2 id="分布式配置">分布式配置</h2>
<blockquote>
<p>为什么需要分布式配置中心?</p>
</blockquote>
<p>在单体架构或水平架构，抑或是简单的分布式架构中，配置文件通常以文件形式(appsettings.json)打包在application中，锁着系统规模的扩大，之前的管理方式就非常折磨人了。</p>
<blockquote>
<p>举个例子，你有10个微服务，每个微服务部署3个实例，此时你要修改数据库连接，那么你的工作就是要修改30次配置文件，并重启服务器，然后还要小心中途不出错，还要考虑敏感信息的加密。</p>
</blockquote>
<p>分布式配置中心是<strong>微服务中用于集中管理和动态推送配置的拓展组件</strong>。它通过统一的平台解决传统配置管理的痛点（如配置分散、修改复杂、环境隔离困难），是保障系统高可用、可维护的关键基础设施。</p>
<table>
<thead>
<tr>
<th><strong>传统配置管理的痛点</strong></th>
<th><strong>分布式配置中心的解决方式</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>配置分散在各服务实例中，修改需逐个操作（如修改Nginx限流阈值需登录100台服务器）</td>
<td>集中存储配置，通过统一界面或API修改，自动同步到所有实例</td>
</tr>
<tr>
<td>配置变更需重启服务（如Spring Boot修改<code>server.port</code>需重启）</td>
<td>支持<strong>动态推送</strong>，配置修改后服务无需重启即可生效</td>
</tr>
<tr>
<td>多环境（开发/测试/生产）配置重复，易因复制错误导致线上故障</td>
<td>支持<strong>环境隔离</strong>（如按<code>dev/test/prod</code>划分配置）</td>
</tr>
<tr>
<td>配置版本混乱（如回滚时找不到历史版本）</td>
<td>提供<strong>版本管理</strong>和<strong>回滚</strong>功能，记录每次修改的时间、操作人</td>
</tr>
<tr>
<td>敏感配置（如数据库密码）明文存储，存在安全风险</td>
<td>支持<strong>加密存储</strong>和<strong>权限控制</strong>（如仅管理员可修改数据库配置）</td>
</tr>
</tbody>
</table>
<h2 id="分布式日志">分布式日志</h2>
<p>分布式日志处理是指在分布式系统，对于分散在不同节点的日志进行集中收集，存储，分析和监控。<code>其核心目标是解决分布式环境下的日志的分散性，异构性，高并发问题</code>，帮助团队快速定位故障，挖掘数据。</p>
<blockquote>
<p>为什么需要分布式日志中心?</p>
</blockquote>
<ol>
<li>全链路追踪，快速定位问题</li>
</ol>
<p>通过唯一请求 ID（如 Trace ID）将跨服务的日志串联，形成完整调用链路，秒级定位故障节点。。 2. 统一日志管理，提升可观测性</p>
<p>将分散日志汇聚到统一平台（如 Elasticsearch），支持多维度查询（按时间、服务名、关键字、日志级别），通过标准化格式将日志转换为统一JSON格式。 3. 数据驱动的决策与优化</p>
<p>统计用户行为日志（如页面访问、按钮点击），优化产品功能设计。</p>
<p>分析日志中的耗时数据，识别服务瓶颈（如数据库慢查询、接口响应超时）</p>
<p>通过日志量趋势分析，预测服务器存储和计算资源需求。</p>
<h3 id="结构化日志的重要性">结构化日志的重要性</h3>
<p>非结构化日志如同 “原始矿石”，而结构化日志是 “精雕细琢的宝石”—— 前者仅能提供原始信息，后者则通过标准化和字段化，让日志成为驱动系统优化、业务增长的核心资产。</p>
<p>无论是故障排查、性能优化，还是合规审计，结构化日志都是实现 “数据驱动运维” 的必经之路。</p>
<blockquote>
<p>举个例子，你想统计出某个特定时间段用户登陆失败的次数。通过结构化日志，你可以轻松的以SQL的形式得出统计结果。</p>
<p>再举个例子，通过提取response_time，设置 “当 95% 请求耗时&gt; 500ms 时触发告警</p>
</blockquote>
<pre><code class="language-bash">{
  &quot;timestamp&quot;: &quot;2025-05-24T14:30:00Z&quot;,
  &quot;service_name&quot;: &quot;user-service&quot;,
  &quot;response_time&quot;:182ms,
  &quot;level&quot;: &quot;ERROR&quot;,
  &quot;message&quot;: &quot;用户登录失败&quot;,
  &quot;metadata&quot;: {
    &quot;user_id&quot;: &quot;U12345&quot;,
    &quot;error_code&quot;: &quot;AUTH_001&quot;,
    &quot;trace_id&quot;: &quot;abc-123&quot;
  }
}
</code></pre>
<blockquote>
<p>简单来说，结构化日志，使得日志变成了数据库中的字段，从而发生质变。从之前的仅用于故障排查，上升到挖掘商业价值，用户行为分析的高度，让日志拥有了无限种可能。</p>
<figure data-type="image" tabindex="8"><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250524215203560-272590583.png" alt="Image 20: image" loading="lazy"></figure>
</blockquote>
<h2 id="分布式链路跟踪">分布式链路跟踪</h2>
<p>链路跟踪主要用于<code>追踪和记录跨多个服务/组件</code>的链路请求，并分析经过的每个节点的处理时间，状态和依赖关系。其核心目标是解决分布式系统中又臭又长的调用链路，并<code>结合分布式日志帮助开发者快速定位</code>性能瓶颈与故障点</p>
<blockquote>
<p>为什么需要链路跟踪？</p>
</blockquote>
<ol>
<li>线上故障快速排查</li>
</ol>
<p>一个请求可能设计到数十个服务，一个服务一个服务的查看，非常废人，效率也非常低下。</p>
<p>比如用户支付失败，但无法确定是支付服务故障、库存服务超时，还是网络问题。链路跟踪通过 Trace ID 串联所有相关 Span，快速定位出错的服务或节点。</p>
<ol start="2">
<li>性能优化</li>
</ol>
<p>识别慢调用（如超时的 RPC 接口、低效的数据库查询），优化服务间调用逻辑或资源配置。</p>
<ol start="3">
<li>指导集群容量规划</li>
</ol>
<p>通过分析链路流量和资源消耗，评估各服务压力，指导集群扩/缩容</p>
<ol start="4">
<li>指导服务治理</li>
</ol>
<p>通过可视化的服务依赖关系，指导辅助熔断、限流策略的制定（如对高延迟服务设置降级规则）。</p>
<figure data-type="image" tabindex="9"><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250525101929576-1100629894.png" alt="Image 21: image" loading="lazy"></figure>
<p><strong>根据我的血泪史，链路跟踪最大的好处就是跟其它项目组扯皮的时候有理有据，免得其它项目组不认账！</strong></p>
<h2 id="分布式事务">分布式事务</h2>
<p>分布式事务是指在分布式系统种，涉及多个服务节点或数据库节点的操作，需要保证其<code>操作原子性</code>，也就是要么全部成功，要么全部回滚。</p>
<blockquote>
<p>为什么需要链路跟踪？</p>
</blockquote>
<ol>
<li>微服务架构下的业务拆分</li>
</ol>
<p>例如电商系统中，用户下单时需要同时完成：</p>
<p>*. 订单服务创建订单（写入订单数据库）</p>
<p>*. 库存服务扣减库存（写入库存数据库）；</p>
<p>*. 支付服务冻结预授权（调用第三方支付接口）。</p>
<p>若其中某一步骤失败（如库存不足或支付超时），需回滚所有已完成的操作（如撤销订单、恢复库存），否则会导致数据不一致（例如用户下单成功但库存未扣减，或库存扣减但支付失败）。</p>
<ol start="2">
<li>分布式数据库的事务需求</li>
</ol>
<p>使用分库分表，一个事务可能涉及多个数据库节点的数据操作。</p>
<p>传统数据库的本地事务无法跨节点保证一致性，需分布式事务机制（如 2PC、3PC）协调各节点的提交或回滚。</p>
<p>根据业务不同，金融、电商等对数据敏感的领域必须保证强一致性。</p>
<p>受限于CAP定理，一致性，可用性，分区容错性无法同事满足，因此需要根据业务场景权衡。</p>
<figure data-type="image" tabindex="10"><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250525095935871-90852901.png" alt="Image 22: image" loading="lazy"></figure>
<table>
<thead>
<tr>
<th><strong>模式</strong></th>
<th><strong>核心思想</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>两阶段提交（2PC）</strong></td>
<td>通过事务管理器协调各参与者的“准备”和“提交”阶段，保证强一致性但性能较低。</td>
<td>金融交易、实时数据同步</td>
</tr>
<tr>
<td><strong>三阶段提交（3PC）</strong></td>
<td>优化 2PC 的超时问题，引入“预提交”阶段，降低阻塞但实现复杂。</td>
<td>高可用分布式系统</td>
</tr>
<tr>
<td><strong>事务消息（最终一致性）</strong></td>
<td>通过消息中间件异步协调，允许短暂不一致，最终达到一致。</td>
<td>异步业务（如订单通知、物流更新）</td>
</tr>
<tr>
<td><strong>TCC（Try-Confirm-Cancel）</strong></td>
<td>自定义“尝试-确认-取消”逻辑，灵活处理部分成功的操作，适合复杂业务。</td>
<td>微服务架构中的复杂流程（如支付）</td>
</tr>
<tr>
<td><strong>最大努力通知</strong></td>
<td>通过重试机制和回调接口确保最终一致性，允许人工干预。</td>
<td>非核心业务（如短信通知）</td>
</tr>
</tbody>
</table>
<blockquote>
<p>如果将微服务架构比作数学高考，那么分布式事务就是最后那道压轴题。这道题做好了，清华就离你不远了。</p>
<p>别理解错了，我的意思不是让你玩好分布式事务，而是尽量避免使用分布式事务，它的收益其实很低，性能也不高。对于互联网业务，我们应该在设计阶段就尽量避免，能补偿就补偿，尽量不要高频次使用分布式事务。</p>
<p>对于平庸的大多数而言，最后一道压轴题直接放弃会比较明智。</p>
</blockquote>
<p><code>微服务不是套公式，你的架构可以是Application微服务化，但底层数据库是同一个。你要相信SQL Server的能力，绝大多数公司业务达不到能让SQL Server出现瓶颈的时候</code></p>
<h1 id="微服务架构的演化简单介绍版">微服务架构的演化，简单介绍版</h1>
<h2 id="service-mesh">Service Mesh</h2>
<p>随着微服务规模扩大，传统 SDK 模式的弊端（如代码侵入、升级成本高）凸显，服务网格作为基础设施层应运而生。</p>
<figure data-type="image" tabindex="11"><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250525111558504-1330714590.png" alt="Image 23: image" loading="lazy"></figure>
<blockquote>
<p>服务网格解决了什么问题？</p>
</blockquote>
<p>在传统微服务架构中，服务间通信需要<code>处理大量复杂逻辑</code>，例如：</p>
<p>服务发现：如何找到目标服务的地址？</p>
<p>负载均衡：如何将请求均匀分配到多个实例？</p>
<p>流量控制：如何处理超时、重试、熔断？</p>
<p>安全通信：如何实现服务间的认证、授权和加密？</p>
<p>可观测性：如何收集调用链、指标、日志以监控系统？</p>
<p>这些逻辑通常通过 SDK集成到服务代码中，<code>代码侵入性强，维护成本高</code>。</p>
<p>而Service Mesh将这些底层通信逻辑从业务代码中剥离，下沉到独立的基础设施层，实现透明化、标准化、自动化的服务间通信。</p>
<blockquote>
<p>简单来说，就是做了一层抽象，解决了微服务架构中最复杂的 “连接” 问题。服务网格就像微服务之间的 “智能路由器” 和 “通信管家”，自动处理所有网络相关的脏活累活，让服务只需关心 “做什么”，而不是 “如何连接”。</p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>传统微服务（如Spring Cloud）</strong></th>
<th><strong>服务网格</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>通信实现</strong></td>
<td>通过SDK集成到服务代码中（侵入式）</td>
<td>独立Sidecar代理（无侵入）</td>
</tr>
<tr>
<td><strong>语言绑定</strong></td>
<td>强绑定（如Java用Spring Cloud）</td>
<td>语言无关（服务可由任意语言开发）</td>
</tr>
<tr>
<td><strong>升级成本</strong></td>
<td>需修改服务代码并重新部署</td>
<td>只需升级Sidecar或控制平面</td>
</tr>
<tr>
<td><strong>复杂度</strong></td>
<td>服务代码包含底层逻辑，复杂度高</td>
<td>底层逻辑下沉到网格，服务逻辑更纯粹</td>
</tr>
<tr>
<td><strong>资源消耗</strong></td>
<td>低（无额外进程）</td>
<td>高（每个服务需运行Sidecar，Sidecar 的资源消耗通常为 “10%-20% 的额外 CPU / 内存）</td>
</tr>
</tbody>
</table>
<h2 id="cloud-native">Cloud Native</h2>
<p>Cloud Native（云原生） 是一种利用云计算特性设计、构建和运行应用的技术理念与实践方法，其核心目标是通过云的弹性、分布式和自动化能力，实现应用的高可用、可扩展、快速迭代。云原生并非单一技术，而是一套包含方法论、架构模式和工具链的完整体系</p>
<figure data-type="image" tabindex="12"><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250525114205692-1567043550.png" alt="Image 24: image" loading="lazy"></figure>
<blockquote>
<p>云原生解决了什么问题？</p>
</blockquote>
<p>微服务解决了 “拆” 的问题，云原生解决了 “在云中管好、用好这些拆分后的服务” 的问题。</p>
<p>简单来说说，当服务上云后，云原生通过容器化、编排、服务网格等技术，解决了微服务在云环境中的部署、运维、治理难题，让微服务真正 “跑好” 在云中。</p>
<p>极大的<code>简化了微服务架构的工作量</code>，协助开发人员更加专注于业务，而不是陷在微服务架构的技术细节中爬不出来。</p>
<blockquote>
<p>由于.NET 在互联网的生态不足，相对JAVA的Spring Cloud这种商店式脚手架，采用.NET技术栈的公司往往需要投入更大的资源才能完成微服务化建设，但上云后，由云厂商提供的简单快捷的SDK与UI ，极大简化了微服务架构的复杂性，甚至可以不需要架构师。</p>
</blockquote>
<h3 id="service-mesh与cloud-native的关系">Service Mesh与Cloud Native的关系？</h3>
<p>Cloud Native的核心是微服务架构，而微服务的高效运行依赖可靠的服务间通信。传统微服务通过 SDK实现通信逻辑，但存在代码侵入、语言绑定等问题。Service Mesh 通过 Sidecar 代理拦截流量，将通信逻辑下沉到基础设施层，完美契合 Cloud Native 对 “解耦” 和 “无侵入” 的要求。</p>
<blockquote>
<p>说人话就是在Service Mesh的基础上又做了一层抽象。</p>
</blockquote>
<h2 id="serverless">Serverless</h2>
<p>Serverless（无服务器架构） 是一种云原生时代的计算模型和开发模式，其核心是将服务器的运维和资源管理完全交给云服务商，开发者只需专注于编写业务代码（如函数、事件处理逻辑），无需关心服务器的采购、部署、扩容或故障修复。它通过 “按需付费” 和 “事件驱动” 的设计，彻底改变了传统应用的开发与运维方式。</p>
<table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>传统架构（VM/容器）</strong></th>
<th><strong>Serverless架构</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>资源管理</strong></td>
<td>需手动申请/释放服务器，管理扩缩容</td>
<td>云服务商自动管理，开发者无需干预</td>
</tr>
<tr>
<td><strong>付费模式</strong></td>
<td>按服务器时长付费（如包年包月）</td>
<td>按实际使用的计算资源（执行时间、内存）付费</td>
</tr>
<tr>
<td><strong>开发重心</strong></td>
<td>需编写服务器配置、运维脚本、监控代码</td>
<td>仅需编写业务逻辑（函数或调用BaaS API）</td>
</tr>
<tr>
<td><strong>扩缩容能力</strong></td>
<td>需手动或脚本触发，响应延迟高（分钟级）</td>
<td>自动扩缩容，支持毫秒级启动（冷启动可能延迟）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>长生命周期、高并发、状态敏感的应用</td>
<td>短任务、事件驱动、无状态或轻状态的应用</td>
</tr>
</tbody>
</table>
<h1 id="理论与具体落地">理论与具体落地</h1>
<blockquote>
<p>逼逼了这么多，道理谁都懂，你又是如何落地呢？</p>
<p>再次强调一点，微服务不是套公式，也不是银弹，技术始终是为业务服务，符合当前业务发展规模的架构就是好架构！</p>
<figure data-type="image" tabindex="13"><img src="https://img2024.cnblogs.com/blog/1084317/202505/1084317-20250527110706093-1032486162.png" alt="Image 25: image" loading="lazy"></figure>
</blockquote>
<p>我司在实践微服务的10年中，从最开始的单体到水平拓展再到拥抱AWS Cloud，中间经历了多次变更，虽未严格按照理论实践，<code>但始终与业务发展步调一致，持续更新</code>。</p>
<p>以下是与理论不同的地方：</p>
<ol>
<li>合并API网关与服务发现/治理</li>
</ol>
<p>评论区说得对，<code>一个分布式服务治理框架，市面上99%都是处于这个阶段</code>，我们的实践也是如此，使用Kong网关，作为分布式服务治理框架，集成了API与服务治理，服务发现。</p>
<p>简化了绝大多数建设成本，因为类似ESB的服务发现/服务治理就是实现微服务的核心，剩余的组件均是锦上添花。</p>
<ol start="2">
<li>Application微服务化，数据库只使用一个</li>
</ol>
<p>不同项目组使用不同的数据库，但都统一部署在同一个物理机上，因为我们相信SQL Server的能力，要万一遇到了瓶颈，因为也照了业务划分数据库，所以快速切成独立的物理数据库成本也较低。</p>
<p>还有一个原因是，分布式事务成本不低，实现复杂，也增加了运维/开发难度。SQL Server做好读写分离，主从同步，足以支撑业务发展很长一段时间。</p>
<blockquote>
<p>我司从起步到被收购，12年期间，成为了全美TOP级别房产公司，SQL Server从未掉过链子，也从未成为过木桶效应的那块短板。</p>
</blockquote>
<ol>
<li>各微服务之间通过HTTP调用</li>
</ol>
<p>倒反天罡！微服务不用Grpc，你这还叫微服务吗？</p>
<p>首先要明白一个点，Grpc快的根本在于使用HTTP2，所以我们内部调用协议是用的HTTP2甚至HTTP3，即可满足业务发展需要。</p>
<ol start="2">
<li>有了Kafka为什么还要使用AWS SQS/SNS</li>
</ol>
<p>Kafka 是面向大数据和流处理的 “重型” 平台，适合构建数据基础设施，但在延迟队列/死信号队列上需要插件实现。团队希望单一职责，保持Kafka纯粹性。</p>
<p>SQS/SNS 是面向应用解耦和通知的 “轻量级” 托管服务，适合快速开发和 AWS 生态内的场景。</p>
<ol start="3">
<li>为什么要使用Kong网关而不是K8s全家桶</li>
</ol>
<p><code>技术为业务服务</code>，研发人员不应该陷在技术细节中出不来，尽管技术是研发的基本盘，但boss喊人来做事是来解决问题的，不是逢1，3，5升插件版本，逢2，4开技术分享会。</p>
<p>说人话就是，<code>项目和你有一个能跑就不要动</code>，每天这么多会议，要跟产品斗智斗勇，没有这么多精力去学习新框架。</p>
<p>框架复框架，框架何其多，你还记得大明湖畔的WCF,Silverlight,WindowsPhone吗？</p>
<h2 id="参考资料">参考资料</h2>
<blockquote>
<p><a href="https://blog.51cto.com/universsky/5850036">https://blog.51cto.com/universsky/5850036</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1549492">https://cloud.tencent.com/developer/article/1549492</a></p>
<p><a href="https://blog.csdn.net/weixin_43114209/article/details/144203876">https://blog.csdn.net/weixin_43114209/article/details/144203876</a></p>
</blockquote>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://yuzhupeng.top/myblogs/tag/bH6nQ51Eep/" class="tag">
                    NET
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://yuzhupeng.top/myblogs/post/iciocrispebrokerascef-prompt-framework/">
                  <h3 class="post-title">
                      ICIO、CRISPE、BROKE、RASCEF  Prompt framework
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
