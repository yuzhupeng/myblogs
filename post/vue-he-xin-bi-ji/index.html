<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Vue核心 笔记 | fishyue</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://yuzhupeng.top/myblogs//favicon.ico?v=1755503043926">
<link rel="stylesheet" href="https://yuzhupeng.top/myblogs//styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="一、Vue核心
Vue是什么
Vue是前端优秀框架，是一套用于构建用户界面的渐进式框架。
Vue API风格
Vue的组件可以按两种不同的风格书写：选项式API和组合式API
Vue开发前端的准备

前提条件：
命令行
nodejs 15...." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://yuzhupeng.top/myblogs/">
        <img src="https://yuzhupeng.top/myblogs//images/avatar.png?v=1755503043926" class="site-logo">
        <h1 class="site-title">fishyue</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/myblogs" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/myblogs/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/myblogs/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/myblogs/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/yuzhupeng" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      由奢入俭难，由俭入奢易
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/yuzhupeng" target="_blank">Fishyue</a> | <a class="rss" href="https://yuzhupeng.top/myblogs//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Vue核心 笔记</h2>
            <div class="post-date">2025-07-30</div>
            
            <div class="post-content" v-pre>
              <h1 id="一-vue核心">一、Vue核心</h1>
<h2 id="vue是什么">Vue是什么</h2>
<p>Vue是前端优秀框架，是一套用于构建用户界面的<strong>渐进式框架</strong>。</p>
<h2 id="vue-api风格">Vue API风格</h2>
<p>Vue的组件可以按两种不同的风格书写：<em><strong>选项式API</strong></em>和<strong>组合式API</strong></p>
<h2 id="vue开发前端的准备">Vue开发前端的准备</h2>
<blockquote>
<p>前提条件：</p>
<p>命令行</p>
<p>nodejs 15.0或更高版本</p>
</blockquote>
<p>vuejs的使用官方提供了2中方式：</p>
<p>1、基于脚本导入使用，下载vue.js文件，通过script标签引入到html网页。</p>
<p>2、基于项目构建工具来使用，需要安装项目构建工具，自动构建程一个独立的项目。</p>
<p>目前官方推荐的项目构建项目：vue-CLI,vite</p>
<h2 id="el唯一根标签">el唯一根标签</h2>
<pre><code class="language-vue"> &lt;!-- 定义唯一根元素div --&gt;
    &lt;div id=&quot;app&quot;&gt;{{name}}&lt;/div&gt;
    &lt;script&gt;
        var vm = new Vue({
            el: &quot;#app&quot;, //通过el与div元素绑定
            data: {
                name: &quot;Vue 实例创建成功!&quot;
            }
        })
    &lt;/script&gt;
</code></pre>
<pre><code class="language-vue">    &lt;!-- 定义唯一根元素div --&gt;
    &lt;div id=&quot;app&quot;&gt;{{name}}&lt;/div&gt;
    &lt;script&gt;
        var vm = new Vue({
            // el: &quot;#app&quot;, //通过el与div元素绑定
            data: {
                name: &quot;Vue 实例创建成功!&quot;
            }
        })
        vm.$mount(&quot;#app&quot;)
    &lt;/script&gt;
</code></pre>
<h2 id="data与el的2种写法">data与el的2种写法</h2>
<p>1、el有2种写法：</p>
<ul>
<li>new Vue时候配置el属性</li>
<li>先创建Vue实例，随后再通过vm.$mount('#app')指定el的值。</li>
</ul>
<p>2、data有2种写法</p>
<ul>
<li>对象式</li>
<li>函数式</li>
</ul>
<p>以后学习组件时，data必须使用<strong>函数式</strong></p>
<p>3、一个重要的原则：</p>
<p>由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再式Vue实例了。</p>
<p>Vue中数据代理：通过vm对象来代理data对象中属性的操作（读/写）</p>
<p>Vue中数据代理的好处：更加方便的操作data中的数据</p>
<p>基本原理：通过Object.defineProperty()把data对象中所有属性添加到vm上。</p>
<p>为每一个添加到vm上的属性，都指定一个getter/setter。</p>
<p>在getter/setter内部去操作（读/写）data中对应的属性。</p>
<h3 id="事件的基本使用">事件的基本使用：</h3>
<ul>
<li>使用v-on:xxx 或@xxx绑定事件，其中xxx是事件名</li>
<li>事件的回调需要配置在methods对象中，最终会在vm上</li>
<li>methods中配置的函数，不要用箭头函数！否则this就不是vm了。</li>
<li>methods中配置的函数，都是被Vue所管理的函数，this的指向是vm或组件实例对象；</li>
<li>@click=&quot;demo&quot; 和 @click=“demo($event)&quot;效果一致，单后者可以传参数。</li>
</ul>
<h3 id="vue中的事件修饰符">Vue中的事件修饰符：</h3>
<ul>
<li>prevent：阻止默认事件</li>
<li>stop：阻止事件冒泡</li>
<li>once：事件只触发一次</li>
<li>capture：使用是哪的捕获模式</li>
<li>self：只有event.target是当前操作的元素时才触发事件</li>
<li>passive：事件的默认行为立即执行，无需等待事件回调执行完毕</li>
</ul>
<h2 id="vue中常用的按键别名">Vue中常用的按键别名：</h2>
<ul>
<li>回车=&gt;enter</li>
<li>删除-》delete</li>
<li>退出-》esc</li>
<li>空格-》space</li>
<li>换行-》tab（特殊，必须配合keydown去使用）</li>
<li>上-》up</li>
<li>下-》down</li>
<li>左-》left</li>
<li>右-》right</li>
</ul>
<p>Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）</p>
<p>3、系统修饰键：ctrl、alt、shift、meta</p>
<ul>
<li>配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。</li>
<li>配合keydown使用：正常触发事件。</li>
</ul>
<p>4、也可以使用keyCode去指定具体的按键（不推荐）</p>
<p>5、Vue.config.keyCodes.自定义键名 = 键码 可以去定制按键别名。</p>
<h3 id="创建项目">创建项目</h3>
<h4 id="第一种使用-vue-cli-vue脚手架">第一种：使用 vue cli Vue脚手架</h4>
<p>第一步（仅第一次执行）：全局安装@vue/cli</p>
<pre><code>npm install -g @vue/cli
</code></pre>
<p>The recommended way to start a Vite-powered Vue project</p>
<p>第二步：切换到你要创建项目的目录，然后使用命令创建项目。</p>
<pre><code>npm create vue@latest
</code></pre>
<p>第三步：启动项目</p>
<pre><code>  cd vue-demo12
  npm install
  npm run serve
</code></pre>
<p>备注：</p>
<ul>
<li>
<p>如果出现下载缓慢配置npm淘宝镜像：</p>
<pre><code>npm config set registry https://registry.npm.taobao.org
</code></pre>
</li>
</ul>
<h4 id="第二种">第二种：</h4>
<pre><code>npm init vue@latest
</code></pre>
<p>这一条指令将会安装并执行create-vue,它是Vue官方的项目脚手架工具。你将会看到一些诸如TypeScript和测试支持之类的可选项功能提示。</p>
<pre><code>Vue.js - The Progressive JavaScript Framework

√ Project name: ... vue-demo
√ Add TypeScript? ... No / Yes
√ Add JSX Support? ... No / Yes
√ Add Vue Router for Single Page Application development? ... No / Yes
√ Add Pinia for state management? ... No / Yes
√ Add Vitest for Unit Testing? ... No / Yes
√ Add an End-to-End Testing Solution? » No
√ Add ESLint for code quality? ... No / Yes

Scaffolding project in C:\Users\sunliguo\vue-test\vue-demo...

Done. Now run:

  cd vue-demo
  npm install
  npm run dev
</code></pre>
<h4 id="开发环境">开发环境</h4>
<p>vscode + volar</p>
<h3 id="vuejs的m-v-vm思想">Vue.js的M-V-VM思想</h3>
<p>MVVM是Model-View-ViewModel的缩写，它是一种基于前端开发的架构模式，是一种代码分工思想来的 。</p>
<p>Model指代的是vue对象的data属性里面的数据。这里的数据要显示到页面中。</p>
<p>View指代的是vue中数据要显示的HTML页面，在vue中，也称之为“视图模板”。</p>
<p>ViewModel指代的是我们编写代码的vm对象了，他是vue.js的核心，负责连接View和Model，保证视图和数据的一致性，所以前面代码中，data里面的数据被显示中p标签中就是vm对象自动完成的。vm对象会时刻的监控View和Model的变化，并保持双方数据一致性！！！</p>
<h2 id="5-vue项目目录结构">5 Vue项目目录结构</h2>
<pre><code>.vscode			--vscode工具的配置文件
node_modules 	---Vue项目的运行依赖文件夹
public 			--- 资源文件夹（浏览器图标）
src				---	源码文件夹
.gitignore		---git忽略文件
index.html		--- html文件
package.json	---	信息描述文件
README.md		---	注释文件
vite.config.js	---	Vue配置文件
</code></pre>
<h2 id="6-模板语法">6 模板语法</h2>
<p>“插值”是指，使用{{变量}}的方法讲数据插入到HTML文档中。</p>
<p>插值分为文本插值、HTML插值等。</p>
<ul>
<li>文本插值 {{变量}} v-text</li>
<li>HTML插值 v-html</li>
</ul>
<p>双花括号仅拥用输出文本内容，如果要输出html代码，则要使用v-html来输出。</p>
<p>v-html必须在html标签里面作为属性写出来，而且只能写在普通双标签中，单标签元素或者表单都不行。</p>
<pre><code class="language-vue">&lt;script &gt;
export default {
  data() {
    return {
      msg: &quot;神奇的语法&quot;,
      number:10,
      message:&quot;大家好&quot;,
      rawHtml :&quot;&lt;a href='http://blog.sunliguo.com'&gt;sunliguo&lt;/a&gt;&quot;
    };
  },
};
&lt;/script&gt;

&lt;template&gt;
  &lt;h3&gt;模板语法&lt;/h3&gt;
  &lt;p&gt;{{ msg }}&lt;/p&gt;
  &lt;p&gt;{{number+1}}&lt;/p&gt;
  &lt;p&gt;{{message.split(&quot;&quot;).reverse().join(&quot;&quot;)}}&lt;/p&gt;
  &lt;p v-html=&quot;rawHtml&quot;&gt;&lt;/p&gt;
&lt;/template&gt;

</code></pre>
<pre><code class="language-html"> &lt;div id=&quot;app&quot;&gt;
        &lt;p&gt;{{title}}&lt;/p&gt;
        &lt;p v-text=&quot;title&quot;&gt;&lt;/p&gt;
        &lt;p&gt;{{content}}&lt;/p&gt;
        &lt;p&gt;{{ htmlContent}}&lt;/p&gt;
        &lt;p v-text=&quot;htmlContent&quot;&gt;&lt;/p&gt;
        &lt;p v-html=&quot;htmlContent&quot;&gt;&lt;/p&gt;
 
    &lt;/div&gt;
    &lt;script&gt;
        const vm = new Vue({
            el: '#app',
            data() {
                return {
                    title: '这是标题内容',
                    content: &quot;这是内容文本&quot;,
                    htmlContent:'这是一个&lt;span&gt;span&lt;/span&gt;标签'
                }
            },
        }
        )
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="使用javascript表达式">使用JavaScript表达式</h3>
<h1 id="二-vue组件化编程">二、Vue组件化编程</h1>
<h2 id="22-常用指令">2.2、常用指令</h2>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th>简写</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>v-bind</td>
<td>单向绑定解析表达式</td>
<td>v-bind:id=&quot;data&quot;</td>
<td>:id=&quot;data&quot;</td>
<td>绑定id属性，值为data</td>
</tr>
<tr>
<td>v-model</td>
<td>双向数据绑定</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>v-on</td>
<td>绑定事件监听</td>
<td>v-on:click=&quot;showInfo&quot;</td>
<td>@click=&quot;showInfo&quot;</td>
<td>事件监听</td>
</tr>
<tr>
<td>v-for</td>
<td>遍历数组/对象/字符串</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>v-if</td>
<td>条件渲染</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>v-else</td>
<td>条件渲染</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>v-show</td>
<td>动态控制节点是否展示</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>v-text</td>
<td>向其所在节点渲染文本内容</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>v-html</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>v-cloak</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>v-once</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="v-text-更新元素的文本内容">v-text 更新元素的文本内容</h4>
<ul>
<li>
<p>期望的绑定值的类型：string</p>
</li>
<li>
<p>实例</p>
<ul>
<li>
<pre><code>&lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt;
&lt;!--等同于--&gt;
&lt;span&gt;{{msg}}&lt;/span&gt;
</code></pre>
</li>
<li></li>
</ul>
</li>
</ul>
<h2 id="7-属性绑定-v-bind">7 属性绑定 v-bind</h2>
<p>v-bind 动态绑定一个或多个attribute，也可以是组件的prop。</p>
<p>双大括号不能在 HTML attributes 中使用。想要响应式地绑定一个 attribute，应该使用 <a href="https://cn.vuejs.org/api/built-in-directives.html#v-bind"><code>v-bind</code> 指令</a>：</p>
<pre><code class="language-html">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-vue">&lt;script &gt;
export default {
  data() {
    return {
      msg: &quot;active&quot;,
      dynamicID: &quot;appid&quot;,      
    };
  },
};
&lt;/script&gt;

&lt;template&gt;
  &lt;div v-bind:id=&quot;dynamicID&quot;&gt;测试&lt;/div&gt;
&lt;/template&gt;

</code></pre>
<ul>
<li>
<p>示例：</p>
</li>
<li>
<pre><code class="language-vue">&lt;!-- 绑定 attribute --&gt;
&lt;img v-bind:src=&quot;imageSrc&quot; /&gt;

&lt;!-- 动态 attribute 名 --&gt;
&lt;button v-bind:[key]=&quot;value&quot;&gt;&lt;/button&gt;

&lt;!-- 缩写 --&gt;
&lt;img :src=&quot;imageSrc&quot; /&gt;

&lt;!-- 缩写形式的动态 attribute 名 (3.4+)，扩展为 :src=&quot;src&quot; --&gt;
&lt;img :src /&gt;

&lt;!-- 动态 attribute 名的缩写 --&gt;
&lt;button :[key]=&quot;value&quot;&gt;&lt;/button&gt;

&lt;!-- 内联字符串拼接 --&gt;
&lt;img :src=&quot;'/path/to/images/' + fileName&quot; /&gt;

&lt;!-- class 绑定 --&gt;
&lt;div :class=&quot;{ red: isRed }&quot;&gt;&lt;/div&gt;
&lt;div :class=&quot;[classA, classB]&quot;&gt;&lt;/div&gt;
&lt;div :class=&quot;[classA, { classB: isB, classC: isC }]&quot;&gt;&lt;/div&gt;

&lt;!-- style 绑定 --&gt;
&lt;div :style=&quot;{ fontSize: size + 'px' }&quot;&gt;&lt;/div&gt;
&lt;div :style=&quot;[styleObjectA, styleObjectB]&quot;&gt;&lt;/div&gt;

&lt;!-- 绑定对象形式的 attribute --&gt;
&lt;div v-bind=&quot;{ id: someProp, 'other-attr': otherProp }&quot;&gt;&lt;/div&gt;

&lt;!-- prop 绑定。“prop” 必须在子组件中已声明。 --&gt;
&lt;MyComponent :prop=&quot;someThing&quot; /&gt;

&lt;!-- 传递子父组件共有的 prop --&gt;
&lt;MyComponent v-bind=&quot;$props&quot; /&gt;

&lt;!-- XLink --&gt;
&lt;svg&gt;&lt;a :xlink:special=&quot;foo&quot;&gt;&lt;/a&gt;&lt;/svg&gt;
</code></pre>
</li>
</ul>
<p>v-bind指令只是将元素的id attribute与组件的dynamicld属性保持一致。如果绑定的值是null或者undefined，那么该attribute将会从渲染的元素上移除。</p>
<blockquote>
<p>温馨提示：</p>
<p>v-bind: 可以简写为：</p>
</blockquote>
<h2 id="8-条件渲染-v-if">8 条件渲染 v-if</h2>
<pre><code class="language-vue">&lt;template&gt;
    &lt;h3&gt;条件渲染&lt;/h3&gt;
    &lt;div v-if=&quot;flag&quot;&gt;你能看见我吗？&lt;/div&gt;
    &lt;div v-else&gt;那你还是看看我吧&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default{
    data(){
        return {
            flag:false,
        }
    }
}
&lt;/script&gt;
</code></pre>
<p>v-show</p>
<h2 id="9-列表渲染v-for">9 列表渲染	v-for</h2>
<p>利用v-for 指令，可以基于一个数组渲染一个列表。</p>
<p>v-for = &quot;item in items&quot;</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;h3&gt;列表渲染&lt;/h3&gt;
  &lt;p v-for=&quot;(item,index) in names&quot; :key=&quot;index&quot;&gt;{{ item }}&lt;/p&gt;
  &lt;div v-for=&quot;item in result&quot;&gt;
    &lt;p&gt;{{ item.title }}&lt;/p&gt;
    &lt;img :src=&quot;item.avator&quot; /&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  data() {
    return {
      names: [&quot;百战程序员&quot;, &quot;尚学堂&quot;, &quot;IT&quot;],
      result: [
        {
          id: 2261677,
          title: &quot;鄂尔多斯|&quot;,
          avator: &quot;http://www&quot;,
        },
        {
          id: 2261566,
          title: &quot;成都|&quot;,
          avator: &quot;http://www&quot;,
        },
        {
          id: 2261662,
          title: &quot;川西|&quot;,
          avator: &quot;http://www&quot;,
        },
      ],
    };
  },
};
&lt;/script&gt;
</code></pre>
<h2 id="10-通过key管理状态">10 通过key管理状态</h2>
<h3 id="维护状态">维护状态</h3>
<p>当Vue正在更新使用v-for渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的<strong>顺序</strong>改变，Vue就不会移动DOM元素来匹配数据项的顺序，而是就地更新每个元素，并确保他们在原本指定的索引位置上渲染。</p>
<p>为了给Vue一个提示，以便它能耿总每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一的key attribute：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;h3&gt;key属性添加到v-for中&lt;/h3&gt;
  &lt;p v-for=&quot;(name, index) of names&quot; v-bind:key=&quot;index&quot;&gt;{{ name }}&lt;/p&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  data() {
    return { names: [&quot;百战程序员&quot;, &quot;尚学堂&quot;, &quot;IT&quot;] };
  },
};
&lt;/script&gt;
</code></pre>
<h2 id="11-事件处理">11 事件处理</h2>
<p>Vue.js的事件绑定格式是&quot;v-on:&quot;或者”@“。事件处理方法需要在methods中定义。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div ref=&quot;container&quot; class=&quot;container&quot;&gt;{{ content }}&lt;/div&gt;
  &lt;input type=&quot;text&quot; ref=&quot;username&quot;&gt;
  &lt;button @click=&quot;getElementHandle&quot;&gt;获取元素&lt;/button&gt;

&lt;/template&gt;
&lt;script&gt;
/**
 *内容改变：{{模板语法}}
属性改变：v-bind: 指令
事件： v-on:click
如果没有特别的需求，不要操作DOM
 */
export default {
  data() {
    return {
      content: &quot;内容&quot;,
    };
  },
  methods:{
    getElementHandle(){
        //innerHTML:原生js的属性
        //console.log(this.$refs.container.innerHTML='哈哈哈')
        console.log(this.$refs.username.value)
    }
  }
};
&lt;/script&gt;
</code></pre>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div ref=&quot;container&quot; class=&quot;container&quot;&gt;{{ content }}&lt;/div&gt;
  &lt;input type=&quot;text&quot; ref=&quot;username&quot;&gt;
  &lt;br&gt;
  &lt;button v-on:click=&quot;counter += 1&quot;&gt;点击：counter={{ counter }}&lt;/button&gt;
  &lt;button @click=&quot;getElementHandle&quot;&gt;获取元素&lt;/button&gt;
  &lt;button @click=&quot;clickHandle&quot;&gt;按钮&lt;/button&gt;
  &lt;p&gt;{{ message }}&lt;/p&gt;
&lt;/template&gt;
&lt;script&gt;
/**
 *内容改变：{{模板语法}}
属性改变：v-bind: 指令
事件： v-on:click
如果没有特别的需求，不要操作DOM
 */
export default {
  data() {
    return {
      content: &quot;内容&quot;,
      counter: 1,
      message: '消息通知'
    };
  },
  methods: {
    getElementHandle() {
      //innerHTML:原生js的属性
      //console.log(this.$refs.container.innerHTML='哈哈哈')
      console.log(this.$refs.username.value)
    },
    clickHandle(event) {
      // 在事件中，读取data中的属性，是需要通过this.属性
      this.message = '消息撤回了';
      //event 是原生的DOM event
      console.log(event);
      event.target.innerHTML = '点击之后';
    }
  }
};
&lt;/script&gt;
</code></pre>
<h2 id="12-事件传参">12 事件传参</h2>
<p>内联处理器中的参数</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;button @click=&quot;say('hi')&quot;&gt;say&lt;/button&gt;
  &lt;button @click=&quot;say('what')&quot;&gt;say what&lt;/button&gt;
  &lt;ul&gt;
    &lt;li @click=&quot;clickHandle2(item)&quot; v-for=&quot;(item,idnex) in names&quot; :key=&quot;index&quot;&gt;{{item}}&lt;/li&gt;
  &lt;/ul&gt;
&lt;/template&gt;
&lt;script&gt;
/**
 *内容改变：{{模板语法}}
属性改变：v-bind: 指令
事件： v-on:click
如果没有特别的需求，不要操作DOM
 */
export default {
  data() {
    return {
      content: &quot;内容&quot;,
      counter: 1,
      message: '消息通知',
      names:['iwen','ime','frank']
    };
  },
  methods: {

    say(data){
      console.log(data)
    },
    clickHandle2(data){
      console.log(data)
    }
  }
};
&lt;/script&gt;
</code></pre>
<h4 id="在内联事件处理器中访问事件参数">在内联事件处理器中访问事件参数</h4>
<p>有时我们需要在内联事件处理器中访问原生 DOM 事件。你可以向该处理器方法传入一个特殊的 <code>$event</code> 变量，或者使用内联箭头函数</p>
<pre><code class="language-vue">&lt;template&gt;
&lt;switch @change=&quot;onChange(124,$event)&quot;&gt;开关&lt;/switch&gt;
&lt;/template&gt;
&lt;script&gt;
	function onChange(a,e) {
		console.log(e);
		console.log(a)
		isLoading.value = e.detail.value
	}
&lt;/script&gt;

</code></pre>
<h2 id="13事件修饰符">13事件修饰符</h2>
<p>Vue为v-on提供了事件修饰符，常用的有以下几个：</p>
<ul>
<li>
<p>.stop</p>
</li>
<li>
<p>.prevent</p>
</li>
<li>
<p>.once       # 限制事件绑定次数为1次</p>
</li>
<li>
<p>.enter</p>
</li>
<li>
<p>.number    #限制表单输入为数字</p>
</li>
<li>
<p>.trim</p>
</li>
</ul>
<h4 id="阻止默认事件-prevent">阻止默认事件 .prevent</h4>
<pre><code class="language-vue">&lt;template&gt;
&lt;h3&gt;事件修饰符&lt;/h3&gt;
&lt;a @click.prevent=&quot;clcikHandle&quot; href=&quot;https://itbaizhan.com&quot;&gt;百战程序员&lt;/a&gt;
&lt;/template&gt;
&lt;script&gt;

export default{
    data(){
        return {
        }
    },
    methods:{
        clcikHandle(e){
            //阻止默认事件
            // e.preventDefault();
            console.log('点击了');
        }
    }
}
&lt;/script&gt;
</code></pre>
<h4 id="阻止冒泡事件">阻止冒泡事件</h4>
<pre><code class="language-vue">&lt;template&gt;
&lt;h3&gt;事件修饰符&lt;/h3&gt;

&lt;div @click=&quot;clickDiv&quot;&gt;
    &lt;p @click.stop=&quot;clickP&quot;&gt;测试冒泡&lt;/p&gt;
&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;

export default{
    data(){
        return {
        }
    },
    methods:{
        clickDiv(){
            console.log('点击了div')
        },
        clickP(e){
            //阻止冒泡
            // e.stopPropagation();
            console.log('点击了p')
        }
    }
}
&lt;/script&gt;
</code></pre>
<h2 id="14-数组变化侦测">14 数组变化侦测</h2>
<h4 id="变更方法">变更方法</h4>
<p>变更方法，顾名思义，就是会对调用他们的原数组进行变更。</p>
<p>Vue能够侦听响应式数组的变更方法，并在它们被调用时触发相关的更新。这些变更方法包括：</p>
<ul>
<li>push()</li>
<li>pop()</li>
<li>shift()</li>
<li>unshift()</li>
<li>splice()</li>
<li>sort()</li>
<li>reverse()</li>
</ul>
<pre><code class="language-vue">&lt;template&gt;
&lt;h3&gt;数组侦听&lt;/h3&gt;
&lt;button @click=&quot;addListHandle&quot;&gt;添加数据&lt;/button&gt;
&lt;ul&gt;
    &lt;li v-for=&quot;(name,index) in names&quot; :key=&quot;index&quot;&gt;{{ name }}&lt;/li&gt;
&lt;/ul&gt;
&lt;/template&gt;
&lt;script&gt;
export default{
    data(){
        return {
            names:['iwen','ime','frank']
        }
    },
    methods:{
        //引起UI自动更新
        addListHandle(){
            this.names.push(&quot;sakura&quot;)
        }
    }

}
&lt;/script&gt;
</code></pre>
<h4 id="替换一个数组">替换一个数组</h4>
<p>filter(),concat()和slice()，不会更改原数组，而总是返回一个新数组。当遇到的是非变更方法时，我门需要将就的数组替换为新的。</p>
<pre><code class="language-vue">&lt;template&gt;
&lt;h3&gt;数组侦听&lt;/h3&gt;
&lt;button @click=&quot;addListHandle&quot;&gt;添加数据&lt;/button&gt;
&lt;ul&gt;
    &lt;li v-for=&quot;(name,index) in names&quot; :key=&quot;index&quot;&gt;{{ name }}&lt;/li&gt;
&lt;/ul&gt;
&lt;/template&gt;
&lt;script&gt;
export default{
    data(){
        return {
            names:['iwen','ime','frank']
        }
    },
    methods:{
        
        addListHandle(){
            //引起UI自动更新
            // this.names.push(&quot;sakura&quot;)
            //不会引起UI自动更新
            this.names.concat(['sakura'])

            console.log(this.names)
            this.names = this.names.concat(['sakura'])
        }
    }

}
&lt;/script&gt;
</code></pre>
<h2 id="15-计算属性">15 计算属性</h2>
<p>当有些数据需要随着其他数据变动而变动时，就需要使用computed计算属性。在事件处理方法中，this指向的Vue实例的计算属性结果被缓存起来，只有依赖的响应式属性变化时，才会重新计算，返回最终结果。</p>
<pre><code class="language-vue">&lt;template&gt;
    &lt;h3&gt;{{itbaizhan.name}}&lt;/h3&gt;
    &lt;p&gt;{{itbaizhan.content.length &gt; 0 ?&quot;Yes&quot;:&quot;No&quot;}}&lt;/p&gt;
    &lt;p&gt;{{itbaizhanContent}}&lt;/p&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
    data(){
        return {
            itbaizhan:{
                name:&quot;百战程序员&quot;,
                content:['前端',&quot;Java&quot;,'Python']
            }
        }
    },
    //计算属性
    computed:{
        itbaizhanContent(){
            return this.itbaizhan.content.length &gt; 0 ?&quot;Yes&quot;:&quot;No&quot;
        }
    }
}
&lt;/script&gt;
</code></pre>
<h4 id="计算属性传参">计算属性传参</h4>
<pre><code class="language-vue">
&lt;div id=&quot;app&quot;&gt;
        &lt;h1&gt;{{titDes(&quot;web前端&quot;)}}&lt;/h1&gt;
    &lt;/div&gt;
    &lt;script&gt;
        new Vue({
            el:&quot;#app&quot;,
            data:{
                title:'新视觉培训',
                desc :'手动阀手动阀'
            },
            computed:{
                titDes(){
                    return function(e){
                        return '新视觉培训'+e;
                    }
                }
            }
        })
        &lt;/script&gt;
</code></pre>
<h2 id="16-class-绑定">16 Class 绑定</h2>
<p>数据绑定的一个常见需求场景是操纵元素的CSS class列表。</p>
<p>Vue专门为class的v-bind用法提供了特殊的功能增强。处理字符串外，表达式的值也可以是对象或数组。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;p :class=&quot;myClass&quot;&gt;Class样式&lt;/p&gt;
  &lt;p v-bind:class=&quot;myClass&quot;&gt;Class样式&lt;/p&gt;
  &lt;p :class=&quot;{ active: isActive, 'text-danger': hasError }&quot;&gt;Class样式&lt;/p&gt;
  &lt;p :class=&quot;classObject&quot;&gt;Class样式绑定2&lt;/p&gt;
  &lt;p :class=&quot;[arrActive, arrHasError]&quot;&gt;Class样式绑定3&lt;/p&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  data() {
    return {
      myClass: &quot;demo&quot;,
      isActive: false,
      hasError: true,
      classObject: {
        active: true,
        &quot;text-danger&quot;: true,
      },
      arrActive: &quot;active&quot;,
      arrHasError: &quot;text-danger&quot;,
    };
  },
};
&lt;/script&gt;
&lt;style &gt;
.active {
  font-size: 30px;
}
.text-danger {
  color: red;
}
&lt;/style&gt;
</code></pre>
<h2 id="17-style绑定">17 style绑定</h2>
<pre><code class="language-vue">&lt;template&gt;
    &lt;p :style=&quot;{class:'red'}&quot;&gt;style绑定1&lt;/p&gt;
    &lt;p :style=&quot;{class:activeColor}&quot;&gt;style绑定2&lt;/p&gt;
    &lt;p :style=&quot;styleObject&quot;&gt;style绑定3&lt;/p&gt;

    
&lt;/template&gt;
&lt;script&gt;
export default {
    data(){
        return {
            activeColor:'green',
            fontSize:30,
            styleObject:{
                color:'red',
                fontSize:'30px'
            }

        }
    }
}
&lt;/script&gt;
</code></pre>
<h2 id="18-侦听器-watch">18 侦听器 watch</h2>
<p>监视属性watch:</p>
<p>1、当被监视的属性变化时，回调函数自动调用，进行相关操作</p>
<p>2、监视的属性必须存在，才能进行监视</p>
<p>3、监视的两种写法：</p>
<ul>
<li>new Vue时传入watch配置</li>
<li>通过vm.$watch监视</li>
</ul>
<p>我们使用wach选项在每次响应式属性发生变化时触发一个函数。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;h3&gt;侦听器&lt;/h3&gt;
  &lt;p&gt;{{ message }}&lt;/p&gt;
  &lt;button @click=&quot;updateHandle&quot;&gt;修改数据&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  data() {
    return {
      message: &quot;Hello&quot;,
    };
  },
  methods: {
    updateHandle() {
      this.message = &quot;world&quot;;
    },
  },
  watch: {
    //newValue 改变之后的数据
    //oldValue 改变之前的数据
    //函数名必须与侦听的数据对象保持一致
    message(newValue, oldValue) {
      console.log(newValue);
      console.log(oldValue);
    },
  },
};
&lt;/script&gt;
</code></pre>
<h3 id="computed和watch之间的区别">computed和watch之间的区别</h3>
<p>1、computed能完成的功能，watch都可以完成。</p>
<p>2、watch能完成的功能，computed不一定能完成。例如：watch可以进行异步操作。</p>
<p>两个重要的小原则：</p>
<p>1、所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm或组件实例对象。</p>
<p>2、所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等），最好写成箭头函数，这样this的指向才是vm或组件实例对象。</p>
<h2 id="19表单输入绑定v-model">19表单输入绑定v-model</h2>
<pre><code class="language-vue">&lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;
</code></pre>
<pre><code class="language-vue">&lt;template&gt;
  &lt;h3&gt;表单数据绑定&lt;/h3&gt;
  &lt;form&gt;
    &lt;input type=&quot;text &quot; v-model=&quot;message&quot; /&gt;
    &lt;p&gt;{{ message }}&lt;/p&gt;
    &lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot; /&gt;
    &lt;label for=&quot;checkbox&quot;&gt;{{ checked }}&lt;/label&gt;
  &lt;/form&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  data() {
    return {
      message: &quot;&quot;,
      checked: true,
    };
  },
};
&lt;/script&gt;

</code></pre>
<h2 id="20-模板引用-ref">20 模板引用 $ref</h2>
<p>虽然Vue的声明性渲染模型为你抽象了大部分对DOM的直接操作，但在某些情况下，我们仍然需要直接访问的底层DOM元素。要实现这一点，我们可以使用特殊的ref attribute。</p>
<p>模板引用也就是指向模板中一个 DOM 元素的 ref。 我们需要通过这个特殊的 ref attribute来实现模板引用：</p>
<pre><code class="language-vue">&lt;p ref=&quot;pElementRef&quot; &gt;
    hello
&lt;/p&gt;
</code></pre>
<p>此元素将作为this.<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>f</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>p</mi><mi>E</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>R</mi><mi>e</mi><mi>f</mi><mi mathvariant="normal">暴</mi><mi mathvariant="normal">露</mi><mi mathvariant="normal">在</mi><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">refs.pElementRef暴露在 this.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mord">.</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord cjk_fallback">暴</span><span class="mord cjk_fallback">露</span><span class="mord cjk_fallback">在</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord">.</span></span></span></span>refs上。然而，你只能在组件挂载之后访问它。</p>
<p>要在挂载之后执行代码，我们可以使用mouted选项：</p>
<pre><code class="language-vue">export default{
	mounted(){
	//此时组件已经挂载
	}
}
</code></pre>
<p>挂载结束后引用都会被暴露在<font color=red>this.$refs</font>之上。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div ref=&quot;container&quot; class=&quot;container&quot;&gt;{{ content }}&lt;/div&gt;
  &lt;input type=&quot;text&quot; ref=&quot;username&quot;&gt;
  &lt;button @click=&quot;getElementHandle&quot;&gt;获取元素&lt;/button&gt;

&lt;/template&gt;
&lt;script&gt;
/**
 *内容改变：{{模板语法}}
属性改变：v-bind: 指令
事件： v-on:click
如果没有特别的需求，不要操作DOM
 */
export default {
  data() {
    return {
      content: &quot;内容&quot;,
    };
  },
  methods:{
    getElementHandle(){
        //innerHTML:原生js的属性
        //console.log(this.$refs.container.innerHTML='哈哈哈')
        console.log(this.$refs.username.value)
    }
  }
};
&lt;/script&gt;
</code></pre>
<h3 id="ref属性">ref属性</h3>
<ul>
<li>被用来给元素或子组件注册引用信息（id的替代者）</li>
<li>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li>
<li>使用方式：
<ul>
<li>打标识<h1 ref="xxx">....</h1> 或<school ref="xxx"></school></li>
<li>获取：this.$refs.xxx</li>
</ul>
</li>
</ul>
<h2 id="21-组件组成">21、组件组成</h2>
<p>关于组件名：</p>
<ul>
<li>
<p>一个单词组成：</p>
<ul>
<li>首字母小写：school</li>
<li>首字母大写：School</li>
</ul>
</li>
<li>
<p>多个单词组成：</p>
<ul>
<li>kebab-case命名：my-school</li>
<li>CamelCase命名：MySchool（需要Vue脚手架支持）</li>
</ul>
<p>备注：</p>
<p>1、组件名尽可能回避HTML中已有的元素名称。</p>
<p>2、可以使用name配置项值指定组件在开发者工具中呈现的名字。</p>
<p>一个简写方式：</p>
<p>const shcool = Vue.extend(options) 可简写为：const school = options</p>
</li>
</ul>
<p>组件最大的优势就是可复用性。</p>
<p>当使用构建步骤时，我们一般会将Vue组件定义在一个.vue文件中，这被叫做单文件组件（简称SFC）</p>
<h4 id="组件组成结构">组件组成结构</h4>
<pre><code class="language-vue">&lt;template&gt;
	&lt;div&gt;承载标签&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {

}
&lt;/script&gt;
&lt;style scoped&gt;
&lt;/style&gt;
</code></pre>
<h4 id="子组件mycomponent">子组件：mycomponent</h4>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;container&quot;&gt;组件基础组成&lt;/div&gt;
&lt;/template&gt;
&lt;script &gt;
export default {
  data() {
    return &quot;&quot;;
  },
};
&lt;/script&gt;

&lt;!--scoped 让当前样式只在当前组件生效--&gt;
&lt;style scoped&gt;
.container {
  font-size: 20px;
}
&lt;/style&gt;

</code></pre>
<p>App.vue</p>
<pre><code class="language-vue">&lt;template&gt;
    &lt;!-- 第三步：显示组件 --&gt;
    &lt;MyComponent/&gt;
&lt;/template&gt;
&lt;script&gt;
//第一步：引入组件
import MyComponent from &quot;./components/mycomponent&quot;

export default{
    //第二步：注入组件
    components:{
        MyComponent,
    }
}
&lt;/script&gt;

</code></pre>
<p>使用组件3个步骤：</p>
<p>1、在父组件中引入子组件</p>
<pre><code class="language-vue">import MyComponent from &quot;./components/mycomponent&quot;
</code></pre>
<p>2、注入组件</p>
<pre><code class="language-vue">components:{
        MyComponent,
    }
</code></pre>
<p>3、显示组件</p>
<pre><code class="language-vue">&lt;template&gt;
    &lt;!-- 第三步：显示组件 --&gt;
    &lt;MyComponent/&gt;
&lt;/template&gt;
</code></pre>
<h4 id="组件声明">组件声明</h4>
<pre><code class="language-vue">    &lt;script&gt;
        //组件声明
        Vue.component(&quot;组件名&quot;,{
            data(){ //组件内部的数据

            },
            methods:{  //组件内部的操作方法

            },
            temlate:&quot;&quot;, //组件的HTML代码
        });
    &lt;/script&gt;
</code></pre>
<h2 id="222-组件嵌套关系">2.22 组件嵌套关系</h2>
<p>通常一个应用会以一棵嵌套的组件树的形式来组织。</p>
<p>真正的Vue应用往往是有嵌套组件创建的。</p>
<p>父组件可以在模板中渲染另一个组件作为子组件。要使用子组件间，我们需要先导入它：</p>
<pre><code class="language-javascript">import ChildComp from './ChildComp.vue'

export default {
  components: {
    ChildComp
  }
}
</code></pre>
<p>我们还需要使用components选项注册组件。这里我们使用对象属性的简写形式在ChildComp键下中注册ChildComp组件。</p>
<p>然后我们就可以在模板中使用组件。</p>
<pre><code>&lt;ChildComp/&gt;
</code></pre>
<h2 id="223-组件传递数据_props">2.23 组件传递数据_Props</h2>
<p>组件与组件之间不是完全独立的。</p>
<p>传递数据的解决方案是Props。 一个组件需要显式声明它所接受的 props，这样 Vue 才能知道外部传入的哪些是 props 。</p>
<p>子组件可以通过props从父组件接收动态数据。</p>
<p>在使用 <code>&lt;script setup&gt;</code> 的单文件组件中，props 可以使用 <code>defineProps()</code> 宏来声明：</p>
<pre><code class="language-vue">&lt;script setup&gt;
const props = defineProps(['foo'])
console.log(props.foo)
&lt;/script&gt;
</code></pre>
<p>在没有使用 <code>&lt;script setup&gt;</code> 的组件中，prop 可以使用 <a href="https://cn.vuejs.org/api/options-state.html#props"><code>props</code></a> 选项来声明：</p>
<pre><code class="language-javascript">export default {
  props: ['foo'],
  setup(props) {
    // setup() 接收 props 作为第一个参数
    console.log(props.foo)
  }
}
</code></pre>
<p>注意传递给 <code>defineProps()</code> 的参数和提供给 <code>props</code> 选项的值是相同的，两种声明方式背后其实使用的都是 prop 选项。</p>
<p>除了使用字符串数组来声明 prop 外，还可以使用对象的形式：</p>
<pre><code>// 使用 &lt;script setup&gt;
defineProps({
  title: String,
  likes: Number
})
</code></pre>
<pre><code>// 非 &lt;script setup&gt;
export default {
  props: {
    title: String,
    likes: Number
  }
}
</code></pre>
<p>首先，子组件中需要声明它所接收的props：</p>
<pre><code class="language-vue">&lt;script&gt;
//在子组件中
export default{
//简单声明接收
	props:['name','age','sex'],
	//接收的同时对数据进行类型限制
	props:{
			name:String,
			age:Number,
			sex:String,
	},
	props:{
		name:{
				type:String,
				required:true,
		},
		age:{
				type:Number,
				default:99,
		},
		sex:{
			type:String,
			require:true,
		}
		}
	}
&lt;/script&gt;
</code></pre>
<p>一旦声明，msg prop 就会暴露在this上，并可以在子组件的模板中使用。</p>
<p>父组件可以像声明HTML attributes一样传递props。若要传递动态值，也可以使用v-bind 语法：</p>
<pre><code class="language-vue">&lt;ChildComp :msg=&quot;greeting&quot;/&gt;
</code></pre>
<p>父组件：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;p&gt;
    {{ title }}
  &lt;/p&gt;
  &lt;myComponent :title=&quot;title&quot; :age=&quot;age&quot;/&gt;
&lt;/template&gt;

&lt;script&gt;
 //引入子组件
import myComponent from &quot;./components/myComponents.vue&quot;

export default {
  name: 'App',
  data() {
    return {
      title: '我是一个标题',
      age:20,
    }
  },
  components: {
    myComponent,
  }
}
&lt;/script&gt;
</code></pre>
<p>子组件：</p>
<pre><code class="language-vue">&lt;template&gt;
    &lt;h3&gt;prop传递数据&lt;/h3&gt;
    &lt;p&gt;{{ title }}&lt;/p&gt;
    &lt;p&gt;{{ age }}&lt;/p&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
    name: &quot;myComponent&quot;,
    props: {
        title: {
            type: String,
            default: ''
        },
        age: {
            type: Number,
            default: 2
        }

    }
}
&lt;/script&gt;
&lt;style scoped&gt;&lt;/style&gt;
</code></pre>
<p>例二：</p>
<p>父组件</p>
<pre><code class="language-vue">&lt;template&gt;
    &lt;h1&gt;Home页面&lt;/h1&gt;
    &lt;!--父组件要发送数据给子组件，通过组件的属性传递。属性名就是将来的变量名，
    传递数据如果时一个变量，则需要在左边加上冒号
    --&gt;
    &lt;Menu :htotal=&quot;total&quot; title=&quot;来自父组件的数据&quot;&gt; &lt;/Menu&gt;
    &lt;button @click=&quot;total++&quot;&gt;{{total}}&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
import Menu from '../components/Menu.vue'

export default {
    name: &quot;home&quot;,
    data(){
        return {
            total:0
        }
    },
    components: {
        Menu,
    }
}
&lt;/script&gt;
&lt;style scoped&gt;
list-style-type:none;
&lt;/style&gt;
</code></pre>
<p>子组件：</p>
<pre><code class="language-vue">&lt;template&gt;
    &lt;div&gt;
        &lt;p&gt;来自父组件的数据：total= {{ htotal }}&lt;/p&gt;
        &lt;p&gt;来自父组件的数据：title= {{ title }}&lt;/p&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;a href=&quot;&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;&quot;&gt;商品&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;&quot;&gt;论坛&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;&quot;&gt;注册&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
    name: &quot;Menu&quot;,
    //来自父组件的数据，全部通过props来接收，2种写法：json写法，数组写法
    // props:['htotal','title']
    props: {
        htotal: Number,   //来自父组件的数据
        title: String,
    }
}

&lt;/script&gt;
&lt;style scoped&gt;
div {
    border: 1px solid red;
}

ul {
    list-style-type: none;
}

li {
    display: inline;
    margin-right: 10px;
}

li a {
    text-decoration: none;
}
&lt;/style&gt;

</code></pre>
<h3 id="vue3-中的例子组合式api">Vue3 中的例子组合式api：</h3>
<p>子组件中：</p>
<pre><code class="language-vue">&lt;script setup&gt;
	// 子组件声明
	// const props = defineProps(['username', 'avatar'])
	// console.log(props)
	const props = defineProps({
		username:{
			type:String,
			default:'匿名'
		},
		avatar:{
			type:String,
			default:'../../static/logo.png'
		}
	})
	
&lt;/script&gt;
</code></pre>
<p>在子组件中使用computed属性</p>
<pre><code class="language-vue">&lt;script setup&gt;
    import {computed} from &quot;vue&quot;
    const porps = defineProps(['username','avatar'])
    const myname = computed(()=&gt;props.username+&quot;@&quot;)
&lt;/script&gt;

</code></pre>
<blockquote>
<h2 id="注意事项">注意事项</h2>
<p><code>props</code>传递数据，只能从父级传递到子级，不能反其道而行。</p>
</blockquote>
<blockquote>
<p>功能：让组件接收外部传过来的数据。</p>
<ul>
<li>传递数据：<Demo name="xxx"/></li>
<li>接收数据：</li>
<li>props:['name']</li>
<li>props:{ name:Number}</li>
<li>props:{name:{type:String,required:true}}</li>
</ul>
<p>备注：props是只读的，Vue底层会检测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</p>
<p>温馨提示：</p>
<p>​				数据类型为数组或对象的时候，默认值需要返回工厂模式</p>
</blockquote>
<h2 id="224-自定义事件组件交互-emit">2.24、自定义事件组件交互 $emit</h2>
<figure data-type="image" tabindex="1"><img src="Vue%E7%AC%94%E8%AE%B0.assets/7c3f59a18f8c477bb72e87661916fc04_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="1.png" loading="lazy"></figure>
<p>子组件还可以向父组件触发事件：</p>
<pre><code class="language-vue">export default{
        // 声明触发的事件
        emits:['response'],
        created(){
            //带参数触发
            this.$emit(&quot;resonse&quot;,&quot;hello from child&quot;)
        }
}
</code></pre>
<p>this.$emit()的第一个参数是事件的名称。其他所有参数都将传递给事件监听器。</p>
<p>父组件：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;

  &lt;myComponent :title=&quot;title&quot; :age=&quot;age&quot; /&gt;
  &lt;p&gt;{{ message }}&lt;/p&gt;
  &lt;myComponent2 @onEvent=&quot;getDataHandle&quot; /&gt;
&lt;/template&gt;

&lt;script&gt;
import myComponent from &quot;./components/myComponents.vue&quot;
import myComponent2 from &quot;./components/myComponents2.vue&quot;

export default {
  name: 'App',
  data() {
    return {
      title: '我是一个标题',
      age: 20,
      message:&quot;&quot;
    }
  },

  methods:
  {
    getDataHandle(data) {
      console.log(data);
      this.message = data;
    }
  },
  components: {
    // myComponent,
    myComponent2,
  }
}
&lt;/script&gt;
</code></pre>
<p>子组件：</p>
<pre><code class="language-vue">&lt;template&gt;
    &lt;h3&gt;自定义事件传递数据&lt;/h3&gt;
    &lt;button @click=&quot;sendClickHandle&quot;&gt;点击传递&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
    name: &quot;myComponent2&quot;,
    props: {

    },
    data(){
        return {
            message:'我是MyComponent数据',
        }
    },
    methods:{
        sendClickHandle(){
            //参数1：字符串
            //参数2：传递的数据
            this.$emit(&quot;onEvent&quot;,this.message)
        }
    }
}
&lt;/script&gt;
</code></pre>
<h3 id="封装子组件父组件向子组件传值">封装子组件（父组件向子组件传值）</h3>
<p>1、父组件想要向子组件传值时，那么需要在子组件引入的地方绑定一个属性，属性值就是要传的数据，并且要在父组件中引入子组件。</p>
<p>2、子组件使用props属性接收父组件传递过来的值。</p>
<h3 id="vue3中子组件向父组件传递事件和值">Vue3中子组件向父组件传递事件和值</h3>
<p>在组件的模板表达式中，可以直接使用 $emit 方法触发自定义事件 (例如：在 v-on 的处理函数中)：</p>
<pre><code class="language-vue">&lt;!-- MyComponent --&gt;
&lt;button @click=&quot;$emit('someEvent')&quot;&gt;click me&lt;/button&gt;
</code></pre>
<p>父组件可以通过 <code>v-on</code> (缩写为 <code>@</code>) 来监听事件：</p>
<pre><code class="language-vue">&lt;MyComponent @some-event=&quot;callback&quot; /&gt;
</code></pre>
<p>例二、</p>
<p>父组件：</p>
<pre><code class="language-vue">&lt;template&gt;
	&lt;view&gt;
        父组件
    	&lt;xxm-child @add=&quot;onAdd&quot;&gt;&lt;/xxm-child&gt;
    &lt;/view&gt;
&lt;/template&gt;
&lt;script setup&gt;
    const onAdd = function(e){
        console.log(e)
    }
&lt;/script&gt;
</code></pre>
<p>子组件：</p>
<pre><code class="language-vue">&lt;template&gt;
&lt;view&gt;
    子组件
    &lt;button @click=&quot;$emit('add',Math.random())&quot;&gt;按钮&lt;/button&gt;
    &lt;/button&gt;
    &lt;/view&gt;
&lt;/template&gt;
</code></pre>
<p>子组件第二种写法：</p>
<pre><code class="language-vue">
&lt;template&gt;
&lt;view&gt;
    子组件
    &lt;button @click=&quot;onClick&quot;&gt;按钮&lt;/button&gt;
    &lt;/button&gt;
    &lt;/view&gt;
&lt;/template&gt;
&lt;script setup&gt;
	const emit = defineEmits(['add']);
    function onClick(){
        emit(&quot;add&quot;,Math.random());
    }
&lt;/script&gt;
</code></pre>
<h1 id="三-使用vue脚手架">三、使用Vue脚手架</h1>
<h2 id="全局事件总线globaleventbus">全局事件总线(GlobalEventBus)</h2>
<p>1、一种组件间通信的方式，适用于任意组件间通信</p>
<p>2、安装全局事件总线：</p>
<pre><code class="language-vue">new Vue({
  render: h =&gt; h(App),
  beforeCreate(){
    //安装全局事件总线 $bus就是当前应用的vm
    Vue.prototype.$bus = this
  },
  mounted(){
    console.log(Vue.prototype)
  }
}).$mount('#app')
</code></pre>
<p>3、使用事件总线：</p>
<ul>
<li>
<p>接收数据</p>
<ul>
<li>
<p>A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身。</p>
<ul>
<li>
<pre><code class="language-vue">methods:{

},
mounted(){
this.$bus.$on('xxx',demo)
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>提供数据：this.<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>u</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">bus.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord">.</span></span></span></span>emit('xxxx'，数据)</p>
</li>
</ul>
<p>4、最好在beforeDestory钩子中，用$off去解绑当前组件中用到的事件。</p>
<h1 id="局部注册组件">局部注册组件</h1>
<pre><code class="language-vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;script src=&quot;js/vue-2.7.14.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        父组件
{{name}}
        &lt;Demo&gt;&lt;/Demo&gt;
    &lt;/div&gt;
    &lt;script&gt;
        //创建子组件
        const Demo = {
            template: `
            &lt;div&gt;
                &lt;h1&gt;{{msg}}&lt;/h1&gt;
                &lt;input type=&quot;text&quot; v-model=&quot;msg&quot;/&gt;
                &lt;input type=&quot;button&quot; @click=&quot;showMsg&quot; value=&quot;点我呀&quot;&gt;
            &lt;/div&gt;
                `,
            methods: {
                showMsg() {
                    alert(this.msg)
                }
            },
            data: function () {
                return {
                    msg: &quot;哈哈哈哈&quot;
                }
            }
        }
        var vm = new Vue({
            el: &quot;#app&quot;,
            data: {
                name:'武沛齐'
            },
            components: {
                Demo,
            }
        })
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<h1 id="全局注册组件">全局注册组件</h1>
<pre><code class="language-vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;script src=&quot;js/vue-2.7.14.js&quot;&gt;&lt;/script&gt;

&lt;/head&gt;

&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        父组件{{name}}
        &lt;Demo&gt;&lt;/Demo&gt;
    &lt;/div&gt;
    &lt;script&gt;
        //创建子组件
        Vue.component('Demo',
            {
                template: `
&lt;div&gt;
    &lt;h1&gt;{{msg}}&lt;/h1&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;msg&quot;/&gt;
    &lt;input type=&quot;button&quot; @click=&quot;showMsg&quot; value=&quot;点我呀&quot;&gt;
&lt;/div&gt;
    `,
                methods: {
                    showMsg() {
                        alert(this.msg)
                    }
                },
                data: function () {
                    return {
                        msg: &quot;哈哈哈哈&quot;
                    }
                }
            })

        var vm = new Vue({
            el: &quot;#app&quot;,
            data: {
                name: '武沛齐'
            },
            components:{
            }
        })
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<h2 id="组件生命周期">组件生命周期</h2>
<p>创建时：beforeCreate,created</p>
<p>渲染时：beforeMount,mounted</p>
<p>更新时：beforeUpdate，updated</p>
<p>卸载时：beforeUnmount，unmounted</p>
<figure data-type="image" tabindex="2"><img src="F:%5Cgithub%5Clearning-vue%5C%E7%AC%94%E8%AE%B0%5CVue%E7%AC%94%E8%AE%B0.assets%5Cfac3eb0428254a8fa204489c58ea5764.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="四-vue中的ajax">四、Vue中的ajax</h1>
<h2 id="41-解决开发环境ajax跨域问题">4.1 解决开发环境Ajax跨域问题</h2>
<h3 id="axios网络请求">Axios网络请求</h3>
<h4 id="安装">安装</h4>
<pre><code>npm install --save axios
</code></pre>
<h4 id="引入">引入</h4>
<p>组件中引入：import axios from &quot;axios&quot;</p>
<p>post请求</p>
<blockquote>
<p>post请求的参数需要额外的处理</p>
<p>安装依赖：npm install --save querystring</p>
<p>转换格式：qs.stringify({})</p>
</blockquote>
<h2 id="42-github用户搜索案例">4.2 github用户搜索案例</h2>
<h2 id="43-vue项目中常用的2个ajax库">4.3 vue项目中常用的2个Ajax库</h2>
<h2 id="44-slot插槽">4.4 slot插槽</h2>
<p>在某些场景中，我们可能想要为组件传递一些模板片段，让自组件在它们的组件中渲染这些片段。</p>
<blockquote>
<p>插槽</p>
</blockquote>
<ul>
<li>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于父组件====&gt;子组件</li>
<li>分类：默认插槽、具名插槽、作用域插槽</li>
</ul>
<h4 id="举例">举例</h4>
<p>父组件中使用子组件<FancyButton>组件：</p>
<pre><code>&lt;FancyButton&gt;
  Click me! &lt;!-- 插槽内容 --&gt;
&lt;/FancyButton&gt;
</code></pre>
<p>而 <code>&lt;FancyButton&gt;</code> 的模板是这样的：</p>
<pre><code class="language-vue">&lt;button class=&quot;fancy-btn&quot;&gt;
  &lt;slot&gt;&lt;/slot&gt; &lt;!-- 插槽出口 --&gt;
&lt;/button&gt;
</code></pre>
<p><code>&lt;slot&gt;</code> 元素是一个<strong>插槽出口</strong> (slot outlet)，标示了父元素提供的<strong>插槽内容</strong> (slot content) 将在哪里被渲染。</p>
<figure data-type="image" tabindex="3"><img src="F:%5Cgithub%5Clearning-vue%5C%E7%AC%94%E8%AE%B0%5CVue%E7%AC%94%E8%AE%B0.assets%5Cslots.inBPF2Hb.png" alt="插槽图示" loading="lazy"></figure>
<p>最终渲染出的 DOM 是这样：</p>
<pre><code>&lt;button class=&quot;fancy-btn&quot;&gt;Click me!&lt;/button&gt;
</code></pre>
<h4 id="默认内容">默认内容</h4>
<pre><code>&lt;button type=&quot;submit&quot;&gt;
  &lt;slot&gt;
    Submit &lt;!-- 默认内容 --&gt;
  &lt;/slot&gt;
&lt;/button&gt;
</code></pre>
<h4 id="具名插槽">具名插槽</h4>
<pre><code class="language-vue">&lt;div class=&quot;container&quot;&gt;
  &lt;header&gt;
    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;
  &lt;/header&gt;
  &lt;main&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/main&gt;
  &lt;footer&gt;
    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;
  &lt;/footer&gt;
&lt;/div&gt;
</code></pre>
<p>在父组件中使用 <code>&lt;BaseLayout&gt;</code> 时，我们需要一种方式将多个插槽内容传入到各自目标插槽的出口。此时就需要用到<strong>具名插槽</strong>了：</p>
<p>要为具名插槽传入内容，我们需要使用一个含 <code>v-slot</code> 指令的 <code>&lt;template&gt;</code> 元素，并将目标插槽的名字传给该指令：</p>
<p>template</p>
<pre><code>&lt;BaseLayout&gt;
  &lt;template v-slot:header&gt;
    &lt;!-- header 插槽的内容放这里 --&gt;
  &lt;/template&gt;
&lt;/BaseLayout&gt;
</code></pre>
<p><code>v-slot</code> 有对应的简写 <code>#</code>，因此 <code>&lt;template v-slot:header&gt;</code> 可以简写为 <code>&lt;template #header&gt;</code>。其意思就是“将这部分模板片段传入子组件的 header 插槽中”。</p>
<figure data-type="image" tabindex="4"><img src="F:%5Cgithub%5Clearning-vue%5C%E7%AC%94%E8%AE%B0%5CVue%E7%AC%94%E8%AE%B0.assets%5Cnamed-slots.giG_TKP2.png" alt="具名插槽图示" loading="lazy"></figure>
<p>下面我们给出完整的、向 <code>&lt;BaseLayout&gt;</code> 传递插槽内容的代码，指令均使用的是缩写形式：</p>
<pre><code>&lt;BaseLayout&gt;
  &lt;template #header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
  &lt;/template&gt;

  &lt;template #default&gt;
    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
    &lt;p&gt;And another one.&lt;/p&gt;
  &lt;/template&gt;

  &lt;template #footer&gt;
    &lt;p&gt;Here's some contact info&lt;/p&gt;
  &lt;/template&gt;
&lt;/BaseLayout&gt;
</code></pre>
<h3 id="uni-app中对request的封装">uni-app中对request的封装</h3>
<p>在untils目录中创建文件request.js</p>
<pre><code class="language-javascript">const BASE_URL = &quot;https://tea.qingnian8.com/api/bizhi&quot;

//使用Promise()方法封装了uni-app的uni.request方法
export function request(config = {}) {
	//resolve 成功  reject 失败
	return new Promise((resolve, reject) =&gt; {
		let {
			url,
			method = &quot;GET&quot;,
			header = {},
			data = {}
		} = config;

		url = BASE_URL + url;
		uni.request({
			url,
			data,
			method,
			header,
			//成功后的回调
			success: res =&gt; {
				if (res.data.errCode == 0) {
					resolve(res.data);
				} else if (res.data.errCode === 400) {
					uni.showModal({
						title: &quot;错误提示&quot;,
						content: res.data.errMsg,
						showCancel: false
					})
					reject(res.data.data)
				} else {
					uni.showModal({
						title: res.data.errMsg,
						icon: &quot;none&quot;,
					});
					rejct(res.data.data);
				}
			},
			//失败后的回调
			fail: err =&gt; {
				reject(err);
			}
		})
	})
}
</code></pre>
<p>再在apis.js中封装一层</p>
<pre><code class="language-javascript">import {
	request
} from &quot;@/utils/request.js&quot;
export function apiGetBanner() {
	return request({
		url: &quot;/homeBanner&quot;,
		method: 'GET'
	});
};
</code></pre>
<p>使用</p>
<pre><code class="language-javascript">import {apiGetSetupScore} from '@/api/apis.js'
//确认评分
const submitScore = async () =&gt; {
    console.log(userScore.value);
    console.log(userScore);

    let {classid,_id:wallId} = currentInfo.value;

    let res = await apiGetSetupScore({
        classid,
        wallId,
        userScore:userScore.value
    });
    if (res.errCode === 0){
        uni.showToast({
            title:&quot;评分成功&quot;,
            icon:'none'
        });
        picList.value[currentIndex.value].userScore = userScore.value;
        uni.setStorageSync(&quot;storageClissList&quot;,picList.value);
        clickScoreClose();
    }
    console.log(res);
};
</code></pre>
<h1 id="五-vuex">五、vuex</h1>
<h2 id="51-理解vuex">5.1 理解vuex</h2>
<h3 id="511-vuex是什么">5.1.1 vuex是什么</h3>
<p>1、概念：专门在Vue中实现集中式状态（数据）管理的一个Vue插件，对Vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。</p>
<h3 id="512-什么时候使用vuex">5.1.2 什么时候使用Vuex</h3>
<ul>
<li>多个组件依赖于同一状态</li>
<li>来自不同组件的行为需要变更同一状态</li>
</ul>
<h3 id="513-搭建vuex环境">5.1.3 搭建vuex环境</h3>
<ul>
<li>
<p>创建文件 src/store/index.js</p>
<ul>
<li>
<pre><code class="language-vue">//该文件用于创建Vuex中最为核心的store

//引入Vuex
import Vuex from 'vuex'
//引入Vue
import Vue from 'vue'

//应用Vuex插件
Vue.use(Vuex)

//响应组件中的动作
const actions = {

}
//操作数据
const mutations = {

}
//用于存储数据
const sate = {

}

//创建store
const store = new Vuex.Store({
    actions,
    mutations,
    sate
})

//暴露store
export default store
</code></pre>
</li>
<li>
<p>在main.js中创建vm时传入store配置项</p>
<ul>
<li>
<pre><code>//引入sotre
import store from './store'

//创建vm
new Vue({
el:&quot;#app&quot;,
render:h=&gt;h(App),
store
})
</code></pre>
</li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="六-vue-router">六、vue-router</h1>
<h2 id="61基本使用">6.1基本使用</h2>
<ul>
<li>
<p>安装vue-router，命令：npm i vue-router</p>
</li>
<li>
<p>应用插件 Vue.use(VueRouter)</p>
</li>
<li>
<p>编写router配置项</p>
<ul>
<li>
<pre><code>//该文件专门用来创建整个应用的路由器
import VueRouter from 'vue-router'

//引入组件
import About from '../components/About'
import  Home from '../components/Home'

//创建一个路由器
const router = new VueRouter({
    routes:[
        {
            path:'/about',
            component:About,
        },
        {
            path:'/home',
            component:Home,
        },
    ]
})

//暴露router
export default router
</code></pre>
</li>
</ul>
</li>
<li>
<p>实现切换（active-class可配置高亮样式）</p>
<ul>
<li><router-link active-class="active" to='/about'>About</router-link></li>
<li>指定展示位置 <router-view></router-view></li>
</ul>
</li>
</ul>
<h2 id="62-几个注意点">6.2 几个注意点</h2>
<ul>
<li>路由组件通常存放在pages文件夹，一般组件存放在components文件夹</li>
<li>通过切换，’隐藏‘了路由组件，默认是被销毁掉的，需要的时候再去挂载。</li>
<li>每个组件都有自己的$route属性，里面存储着自己的路由信息</li>
<li>整个应用只有一个router，可以通过组件的$router属性获取到。</li>
</ul>
<h3 id="63-多级路由">6.3 多级路由</h3>
<p>1、配置路由规则，使用children配置项：</p>
<pre><code>routes:[
        {
            path:'/about',
            component:About,
        },
        {
            path:'/home',
            component:Home,
            children:[   //通过children配置子级路由
                {
                    path:'news', //此处一定不要写 /news
                    component:News
                },
                {
                    path:'message',
                    component:Message
                },

            ]
        },

</code></pre>
<p>2、跳转（要写完整路径）</p>
<pre><code>
&lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;
</code></pre>
<h3 id="64-路由传参-query参数">6.4 路由传参  query参数</h3>
<p>1、传递参数</p>
<pre><code>  &lt;!-- 跳转路由并携带query参数 to字符串写法 --&gt;
        &lt;!-- &lt;router-link :to=&quot;`/home/message/detail?id=${m.id}&amp;title=${m.title}`&quot;&gt;{{ m.title }}&lt;/router-link&gt; --&gt;
        
        &lt;!-- 跳转路由并携带query参数 to对象写法 --&gt;
        &lt;router-link :to=&quot;{
            path:'/home/message/detail',
            query:{
                id:m.id,
                title:m.title
            }
        }&quot;&gt;
            {{ m.title }}
        &lt;/router-link&gt;
</code></pre>
<p>2、接收参数：</p>
<pre><code>$route.query.id
$route.query.title
</code></pre>
<h3 id="vue中ref和reative区别">Vue中ref和reative区别？</h3>
<p>在 Vue 中，<code>ref</code> 和 <code>reactive</code> 都是用于创建响应式数据的工具，但它们之间存在一些关键的区别。</p>
<ol>
<li><strong>数据类型和应用场景</strong>：
<ul>
<li><code>ref</code> 主要用于包装 JavaScript 的基本类型数据（如字符串、数字、布尔值等），以及对象。当 <code>ref</code> 用于包装对象时，其内部实际上会通过 <code>reactive</code> 将其转换为代理对象。</li>
<li><code>reactive</code> 则主要用于包装 JavaScript 的对象和数组等复杂类型的数据。如果你尝试使用 <code>reactive</code> 来包装一个基本类型的数据，Vue 会提示你错误，除非你将其包裹在一个对象中。</li>
</ul>
</li>
<li><strong>使用方式和访问方式</strong>：
<ul>
<li>使用 <code>ref</code> 创建的响应式数据在模板中可以通过直接引用变量名访问，但在 JavaScript 代码中需要通过 <code>.value</code> 属性来访问其实际值。例如，<code>const count = ref(0);</code> 在模板中可以直接使用 <code>{{ count }}</code>，但在方法中需要使用 <code>count.value</code>。</li>
<li>使用 <code>reactive</code> 创建的响应式对象则可以直接访问其属性或调用其方法，无需额外的 <code>.value</code> 属性。</li>
</ul>
</li>
<li><strong>响应式实现机制</strong>：
<ul>
<li><code>ref</code> 是通过 <code>Object.defineProperty()</code> 的 <code>get</code> 和 <code>set</code> 方法来实现响应式的。</li>
<li><code>reactive</code> 则是通过 ES6 的 <code>Proxy</code> 对象来实现响应式的，并通过 <code>Reflect</code> 操作源对象内部的数据。</li>
</ul>
</li>
<li><strong>设计理念</strong>：
<ul>
<li><code>ref</code> 的设计主要是为了解决单一元素/数据的响应式问题。</li>
<li><code>reactive</code> 的设计则是为了解决 JavaScript 对象和数组等复杂数据结构的响应式问题。</li>
</ul>
</li>
</ol>
<p>总的来说，<code>ref</code> 和 <code>reactive</code> 在 Vue 中各有其适用场景和优势。对于基本类型的数据，通常使用 <code>ref</code>；而对于复杂的数据结构，如对象和数组，则更倾向于使用 <code>reactive</code>。同时，它们的实现机制和设计理念也反映了 Vue 对于不同类型数据的处理方式。</p>
<h1 id=""></h1>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://yuzhupeng.top/myblogs/post/qian-duan-xiang-mu-kuang-jia-mu-lu/">
                  <h3 class="post-title">
                    前端项目框架 目录
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
