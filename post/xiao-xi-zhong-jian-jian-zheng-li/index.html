<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>消息中间件  整理 | fishyue</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://yuzhupeng.top/myblogs//favicon.ico?v=1755503043926">
<link rel="stylesheet" href="https://yuzhupeng.top/myblogs//styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="第01章_消息中间件
1. 消息中间件简介
1.1 概述
中间件（Middleware）用于分布式系统中，它是脱离于具体设计目标，而具备提供普遍独立功能需求的模块。
消息中间件，利用可靠的消息传递机制进行系统和系统之间的通讯，它通过提供消息..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://yuzhupeng.top/myblogs/">
        <img src="https://yuzhupeng.top/myblogs//images/avatar.png?v=1755503043926" class="site-logo">
        <h1 class="site-title">fishyue</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/myblogs" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/myblogs/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/myblogs/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/myblogs/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/yuzhupeng" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      由奢入俭难，由俭入奢易
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/yuzhupeng" target="_blank">Fishyue</a> | <a class="rss" href="https://yuzhupeng.top/myblogs//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">消息中间件  整理</h2>
            <div class="post-date">2025-08-05</div>
            
            <div class="post-content" v-pre>
              <h1 id="第01章_消息中间件">第01章_消息中间件</h1>
<h2 id="1-消息中间件简介">1. 消息中间件简介</h2>
<h3 id="11-概述">1.1 概述</h3>
<p>中间件（Middleware）用于分布式系统中，它是脱离于具体设计目标，而具备提供普遍独立功能需求的模块。</p>
<p>消息中间件，利用可靠的消息传递机制进行系统和系统之间的通讯，它通过提供消息传递和消息分派机制，可以在分布式系统环境下扩展进程间的通讯。MQ(message queue)是一个FIFO的队列，其中存放的内容是message，MQ是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ是一种非常常见的上下游<code>逻辑解耦+物理解耦</code>的消息通信服务。使用了MQ之后，消息发送上游只需要依赖MQ，不用依赖其他服务。</p>
<h3 id="12-mq的作用">1.2 MQ的作用</h3>
<p><strong>流量削峰</strong></p>
<p>例如，订单系统最多能每秒处理一万个订单，如果在高峰期某一秒有十万次下单，则订单系统无法承受。我们可以使用消息队列做缓冲，将订单消息都保存在消息队列中，而订单系统依旧根据自己的能力每秒取一万个订单消息进行处理。这样，我们就把一秒内下的十万个订单分散成一段时间来处理，虽然用户可能会在下单十几秒后才能收到下单成功的响应，但是总比下单失败的体验要好。这就是MQ削峰填谷的作用。</p>
<p><strong>数据缓冲</strong></p>
<p>例如日志中心的实现方式，通常就是使用Kafka消息队列作数据缓冲，让日志采集服务先将消息写入消息队列，然后日志处理服务再订阅消费。</p>
<p><strong>应用解耦</strong></p>
<p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果串行调用库存系统、物流系统、支付系统，那么任何一个子系统出了故障，都会造成下单操作异常。我们可以在用户创建订单后，发送一个订单消息到消息队列，然后响应给用户。这样，各个子系统通过订阅消息队列的方式来进行各自的业务处理，即使某个子系统故障，也不会影响其他子系统，实现了应用解耦。</p>
<p><strong>异步处理</strong></p>
<p>有些服务间调用是异步的，例如A调用B，B需要花费很长时间执行，但是A需要知道B什么时候可以执行完。使用消息队列，可以很方便解决这个问题，当B处理完成后，会发送一条消息给MQ，MQ会将此消息转发给A服务。这样A服务可以继续执行自己的业务，还能及时得到异步处理成功的消息。</p>
<blockquote>
<p>总结：MQ的核心作用就是<strong>削峰（缓冲）、解耦、异步</strong>。</p>
</blockquote>
<h3 id="13-mq的分类">1.3 MQ的分类</h3>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th>ActiveMQ</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
<th>Kafka</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>开发语言</strong></td>
<td>Java</td>
<td>Erlang</td>
<td>Java</td>
<td>Scala和Java</td>
</tr>
<tr>
<td style="text-align:left"><strong>消息协议</strong></td>
<td>JMS</td>
<td>AMQP</td>
<td>类似JMS</td>
<td>类似JMS</td>
</tr>
<tr>
<td style="text-align:left"><strong>单机吞吐量</strong></td>
<td>万级</td>
<td>十万级不到</td>
<td>十万级以上</td>
<td>接近百万级</td>
</tr>
<tr>
<td style="text-align:left"><strong>消息延时</strong></td>
<td>ms级</td>
<td>us级</td>
<td>ms级</td>
<td>ms级以内</td>
</tr>
<tr>
<td style="text-align:left"><strong>消费模式</strong></td>
<td>默认push，也支持pull</td>
<td>默认push，也支持pull</td>
<td>pull</td>
<td>pull</td>
</tr>
</tbody>
</table>
<p>其他特点：</p>
<ul>
<li>ActiveMQ是早期使用较多的MQ，但现在<strong>官方社区对ActiveMQ的维护越来越少</strong>。</li>
<li>RabbitMQ适用于<strong>数据量不大的场景</strong>，且它基于Erlang语言开发，所以难以进行二次开发。</li>
<li>RocketMQ在设计时参考了Kafka并做出了一些改进，消息可以做到零丢失，适用于<strong>金融互联网领域</strong>等可靠性要求较高的场景。</li>
<li>Kafka吞吐量极高，在<strong>大数据领域和日志领域</strong>应用广泛。缺点是Kafka的功能较为单一，而且单机不支持过多Topic（单机Topic达到百级，吞吐量会大幅度下降）；而RocketMQ就对这一点做了优化（单机Topic即使达到千级，吞吐量也只会有小幅度下降）。</li>
</ul>
<blockquote>
<p>说明：消费者的消费模式有push模式和pull模式。push模式下，MQ会将消息推送给消费者，所以消息延时低、实时性高；pull模式下，消费者主动从MQ中拉取消息，所以消费者可以按照自己的能力来进行消费，不至于被大流量压垮。</p>
</blockquote>
<h2 id="2-rabbitmq简介">2. RabbitMQ简介</h2>
<p>官网地址 https://www.rabbitmq.com/</p>
<h3 id="21-三大核心概念">2.1 三大核心概念</h3>
<ul>
<li>生产者：发送消息的一方</li>
<li>消息队列：存储消息的容器</li>
<li>消费者：接收消息的一方</li>
</ul>
<h3 id="22-rabbitmq工作模型">2.2 RabbitMQ工作模型</h3>
<figure data-type="image" tabindex="1"><img src="images/Snipaste20231217122744.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>Broker</strong>：消息服务器，即RabbitMQ Server</li>
<li><strong>Virtual host</strong>：虚拟主机，即一个虚拟分组，类似于网络中的namespace概念。当多个不同的用户使用同一个RabbitMQ Server时，可以划分出多个Virtual host，每个用户在自己的Virtual host创建exchange或queue等。这样做可以使分类更清晰，且相互隔离。</li>
<li><strong>Connection</strong>：连接RabbitMQ服务器的TCP长连接</li>
<li><strong>Channel</strong>：信道（Channel）是生产者、消费者与 RabbitMQ 通信的渠道，发送和接收消息都是通过信道进行的。信道是建立在 TCP 连接上的虚拟连接，每条 TCP 连接上的信道数量没有限制。就是说 RabbitMQ 在一条 TCP 连接上建立成百上千个信道来达到多个线程处理，这个 TCP 被多个线程共享，每个信道在 RabbitMQ 都有唯一的 ID，保证了信道私有性，每个信道对应一个线程使用。<strong>Channel是轻量级的，能大幅减少操作系统建立TCP连接的开销</strong>。</li>
<li><strong>Exchange</strong>：交换机负责从生产者接收消息，并根据交换机类型分发到对应的消息队列中，起到一个路由的作用</li>
<li><strong>Routing Key</strong>：交换机根据路由键来决定消息分发到哪个队列，路由键就相当于消息的目的地址</li>
<li><strong>Binding</strong>：绑定是队列和交换机的一个关联关系</li>
<li><strong>Queue</strong>：队列，即存储消息的容器</li>
</ul>
<h3 id="23-rabbitmq的工作模式">2.3 RabbitMQ的工作模式</h3>
<p>RabbitMQ主要有以下几种工作模式：</p>
<ul>
<li>work queues（工作队列模式）：多个消费者共同消费同一个队列中的消息（<strong>轮询分发消息</strong>的方式）。一般对于任务较多的场景，可以使用work queues模式提高任务处理的速度。</li>
<li>publish/subscribe（发布订阅模式）：生产者将消息发给交换机（Fanout类型），由交换机将消息转发到绑定此交换机的每个队列，<strong>每个绑定此交换机的队列都将接收到消息</strong>。</li>
<li>routing（路由模式）：生产者将消息发给交换机（Direct类型），由交换机根据routingKey来<strong>转发消息到指定的队列</strong>。</li>
<li>topics（主题模式）：生产者将消息发给交换机（Topic类型），由交换机根据routingKey来转发消息到指定的队列，注意，队列绑定交换机时设置的绑定key可以<strong>带有通配符</strong>。</li>
<li>header：生产者将消息发给交换机（Headers类型），交换机基于消息属性中的headers进行匹配。</li>
</ul>
<h3 id="24-amqp协议">2.4 AMQP协议</h3>
<p>AMQP，即Advanced Message Queuing Protocol，是一个提供统一消息服务的应用层标准<strong>高级消息队列协议</strong>，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受不同开发语言等条件的限制。</p>
<p>RabbitMQ就是AMQP协议的<code>Erlang</code>实现。AMQP的模型架构和RabbitMQ的模型架构是一样的，生产者将消息发送给交换机，交换机和队列绑定。</p>
<blockquote>
<p>说明：RabbitMQ中的交换机、交换机类型、队列、绑定、路由键等都是遵循的AMQP协议中相应的概念。</p>
</blockquote>
<p><strong>AMQP模型的三大组件</strong>：</p>
<ul>
<li><strong>交换机(Exchange)</strong>：消息代理服务器中用于把消息路由到队列的组件。</li>
<li><strong>队列(Queue)</strong>：用来存储消息的数据结构。</li>
<li><strong>绑定(Binding)</strong>：队列和交换机的一个关联关系。</li>
</ul>
<h2 id="3-docker安装rabbitmq">3. Docker安装RabbitMQ</h2>
<p><strong>1、下载rabbitmq镜像</strong></p>
<pre><code class="language-shell">docker pull rabbitmq:management
</code></pre>
<p><strong>2、创建一个数据卷，专门用于持久化RabbitMQ的所有数据</strong></p>
<pre><code class="language-shell">mkdir -p /docker/rabbitmq
</code></pre>
<p><strong>3、启动容器实例，并创建用户</strong></p>
<pre><code class="language-shell">docker run -d --name rabbitmq \
-p 15672:15672 -p 5672:5672 \
--restart=always \
-v /docker/rabbitmq:/var/lib/rabbitmq \
-e RABBITMQ_DEFAULT_USER=admin \
-e RABBITMQ_DEFAULT_PASS=abc666 \
rabbitmq:management
</code></pre>
<p>说明：</p>
<ul>
<li>15672端口：RabbitMQ的web管理页面端口</li>
<li>5672端口：RabbitMQ的消息接收端口</li>
<li>RABBITMQ_DEFAULT_USER环境变量：指定RabbitMQ的用户名</li>
<li>RABBITMQ_DEFAULT_PASS环境变量：指定RabbitMQ的密码</li>
</ul>
<h2 id="4-springboot整合rabbitmq">4. SpringBoot整合RabbitMQ</h2>
<p><strong>引入依赖</strong>：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;
    &lt;artifactId&gt;spring-rabbit-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>配置文件(RabbitMQ单机)</strong>：</p>
<pre><code class="language-properties">spring.rabbitmq.host=192.168.231.101
spring.rabbitmq.port=5672
spring.rabbitmq.username=admin
spring.rabbitmq.password=abc666
spring.rabbitmq.virtual-host=/
</code></pre>
<p><strong>配置文件(RabbitMQ集群)</strong>：</p>
<pre><code class="language-properties">spring.rabbitmq.addresses=192.168.231.101:5672,192.168.231.102:5672,192.168.231.103:5672
spring.rabbitmq.username=admin
spring.rabbitmq.password=abc666
spring.rabbitmq.virtual-host=/
</code></pre>
<h1 id="第02章_常用api">第02章_常用API</h1>
<h2 id="1-exchange">1. Exchange</h2>
<h3 id="11-exchange">1.1 Exchange</h3>
<p>org.springframework.amqp.core.Exchange接口代表交换机。RabbitMQ有四种交换机类型，我们以其中之一DirectExchange为例查看交换机的常用参数。</p>
<pre><code class="language-java">// DirectExchange的构造器
DirectExchange(String name, boolean durable, boolean autoDelete, Map&lt;String, Object&gt; arguments)
</code></pre>
<ul>
<li>name: 交换机的名称</li>
<li>durable: 是否持久化到硬盘，true表示RabbitMQ服务器重启后该交换机仍然存在。一般都设置为true。</li>
<li>autoDelete: 是否自动删除，true表示如果曾经有队列/交换机绑定到该交换机，后来所有与之绑定的队列/交换机全都与之解绑了，则自动删除该交换机。一般都设置为false。</li>
<li>arguments: 交换机的属性参数</li>
</ul>
<blockquote>
<p>说明：事实上一般交换机的属性参数arguments只有一个<code>alternate-exchange</code>，即设置对应的备用交换机。设置该参数后，如果发送到该交换机的消息无法被路由，则会将其转发到所设置的备用交换机。</p>
</blockquote>
<h3 id="12-exchangebuilder">1.2 ExchangeBuilder</h3>
<p>通常我们使用ExchangeBuilder的建造者模式来创建交换机。ExchangeBuilder类的常用API：</p>
<ul>
<li><code>static ExchangeBuilder fanoutExchange(String name)</code>：创建一个扇出交换机</li>
<li><code>static ExchangeBuilder directExchange(String name)</code>：创建一个直接交换机</li>
<li><code>static ExchangeBuilder topicExchange(String name)</code>：创建一个主题交换机</li>
<li><code>static ExchangeBuilder headersExchange(String name)</code>：创建一个头部交换机</li>
<li><code>ExchangeBuilder durable(boolean isDurable)</code>：设置该交换机是否持久化。如果不设置，<strong>默认是持久化的</strong>。</li>
<li><code>ExchangeBuilder autoDelete()</code>：设置该交换机为自动删除的。如果不设置，<strong>默认是不自动删除的</strong>。</li>
<li><code>ExchangeBuilder withArguments(Map&lt;String, Object&gt; arguments)</code>：设置交换机的属性参数</li>
<li><code>ExchangeBuilder withArgument(String key, Object value)</code>：设置交换机的单个属性参数</li>
<li><code>T build()</code>：构建出交换机</li>
</ul>
<p><strong>设置具体属性参数的API</strong></p>
<ul>
<li><code>ExchangeBuilder alternate(String exchange)</code>：设置备用交换机，等价于设置属性参数<code>alternate-exchange</code></li>
</ul>
<h2 id="2-queue">2. Queue</h2>
<h3 id="21-queue">2.1 Queue</h3>
<p>org.springframework.amqp.core.Queue类代表队列，其构造器为</p>
<pre><code class="language-java">Queue(String name, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)
</code></pre>
<ul>
<li>name: 队列的名称</li>
<li>durable: 是否持久化到硬盘，true表示RabbitMQ服务器重启后该队列仍然存在。一般都设置为true。</li>
<li>exclusive: 是否独占，true表示只有第一个连接它的消费者能消费其消息，其他消费者都无法连接该队列，并且当第一个连接它的消费者断开连接后，该队列就直接自动删除。一般都设置为false。</li>
<li>autoDelete: 是否自动删除，true表示如果曾经有消费者连接到该交换机，后来所有与之连接的消费者都断开连接了，则自动删除该队列。一般都设置为false。</li>
<li>arguments: 队列的属性参数</li>
</ul>
<h3 id="22-queuebuilder">2.2 QueueBuilder</h3>
<p>通常我们使用QueueBuilder的建造者模式来创建队列。QueueBuilder的常用API：</p>
<ul>
<li><code>static QueueBuilder durable(String name)</code>：创建一个持久化的队列</li>
<li><code>static QueueBuilder nonDurable(String name)</code>：创建一个非持久化的队列</li>
<li><code>QueueBuilder exclusive()</code>：设置该队列为独占的。如果不设置，<strong>默认是非独占的</strong>。</li>
<li><code>QueueBuilder autoDelete()</code>：设置该队列为自动删除的。如果不设置，<strong>默认是不自动删除的</strong>。</li>
<li><code>QueueBuilder withArguments(Map&lt;String, Object&gt; arguments)</code>：设置队列的属性参数</li>
<li><code>QueueBuilder withArgument(String key, Object value)</code>：设置队列的单个属性参数</li>
<li><code>Queue build()</code>：构建出队列</li>
</ul>
<p><strong>设置具体属性参数的API(常用)</strong></p>
<ul>
<li><code>QueueBuilder ttl(int ttl)</code>：设置队列中消息的TTL(即存活时间，单位ms)。等价于设置属性参数<code>x-message-ttl</code></li>
<li><code>QueueBuilder deadLetterExchange(String dlx)</code>：设置队列对应的死信交换机。等价于设置属性参数<code>x-dead-letter-exchange</code></li>
<li><code>QueueBuilder deadLetterRoutingKey(String dlrk)</code>：设置死信对应的路由key。等价于设置属性参数<code>x-dead-letter-routing-key</code></li>
<li><code>QueueBuilder maxLength(int count)</code>：设置队列的最大长度。等价于设置属性参数<code>x-max-length</code></li>
</ul>
<p><strong>设置具体属性参数的API(不常用)</strong></p>
<ul>
<li><code>QueueBuilder maxPriority(int maxPriority)</code>：设置队列的最大优先级(范围是0-255)。等价于设置属性参数<code>x-max-priority</code>。详细参考优先级队列相关章节。</li>
<li><code>QueueBuilder lazy()</code>：设置队列模式为lazy。等价于设置属性参数<code>x-queue-mode</code>的值为<code>&quot;lazy&quot;</code>。详细参考惰性队列相关章节。</li>
<li><code>QueueBuilder expires(int expires)</code>：当队列在指定时间内(单位ms)未被访问时，会自动删除。等价于设置属性参数<code>x-expires</code></li>
<li><code>QueueBuilder overflow(Overflow overflow)</code>：设置队列的溢出行为，参数只能是以下两种
<ul>
<li><code>QueueBuilder.Overflow.dropHead</code>：这是<strong>默认的策略</strong>，队列满时丢弃队首消息，队尾加入新消息。等价于设置属性参数<code>x-overflow</code>的值为<code>&quot;drop-head&quot;</code></li>
<li><code>QueueBuilder.Overflow.rejectPublish</code>：队列满时直接拒绝新消息，即丢弃新消息。等价于设置属性参数<code>x-overflow</code>的值为<code>&quot;reject-publish&quot;</code></li>
</ul>
</li>
<li><code>QueueBuilder singleActiveConsumer()</code>：设置该队列只能有一个消费者来连接。等价于设置属性参数<code>x-single-active-consumer</code>的值为true</li>
<li><code>QueueBuilder maxLengthBytes(int bytes)</code>：设置队列的最大容量(单位是字节)。等价于设置属性参数<code>x-max-length-bytes</code></li>
</ul>
<h2 id="3-binding">3. Binding</h2>
<h3 id="31-binding">3.1 Binding</h3>
<p>org.springframework.amqp.core.Binding类代表交换机和队列之间的绑定关系。</p>
<h3 id="32-bindingbuilder">3.2 BindingBuilder</h3>
<p>通常我们使用BindingBuilder的建造者模式来创建绑定关系。创建绑定关系的常用写法：</p>
<pre><code class="language-java">// 绑定队列到fanout交换机
return BindingBuilder.bind(queue).to(fanoutExchange);
// 绑定队列到direct交换机
return BindingBuilder.bind(queue).to(directExchange).with(&quot;routingKey&quot;);
// 绑定队列到topic交换机
return BindingBuilder.bind(queue).to(topicExchange).with(&quot;routingKey&quot;);
// 绑定队列到headers交换机
return BindingBuilder.bind(queue).to(headersExchange)
        .whereAll(Map&lt;String, Object&gt; headerValues).match();
</code></pre>
<h2 id="4-message">4. Message</h2>
<h3 id="41-message">4.1 Message</h3>
<p>org.springframework.amqp.core.Message类代表消息。Message的常用API：</p>
<ul>
<li><code>Message(byte[] body)</code>：构造器，设置消息体</li>
<li><code>Message(byte[] body, MessageProperties messageProperties)</code>：构造器，设置消息体和消息属性</li>
<li><code>byte[] getBody()</code>：获取消息体</li>
<li><code>MessageProperties getMessageProperties()</code>：获取消息属性</li>
</ul>
<h3 id="42-messagebuilder">4.2 MessageBuilder</h3>
<p>通常我们使用MessageBuilder的建造者模式来创建消息。MessageBuilder的常用API：</p>
<ul>
<li><code>static MessageBuilder withBody(byte[] body)</code>：设置消息体，即消息的内容</li>
<li><code>MessageBuilder andProperties(MessageProperties properties)</code>：设置消息的属性</li>
<li><code>Message build()</code>：构建出消息</li>
</ul>
<h3 id="43-messageproperties">4.3 MessageProperties</h3>
<p>MessageProperties代表消息属性，它的常用成员变量如下（有对应的getter和setter方法）：</p>
<ul>
<li><code>Map&lt;String, Object&gt; headers;</code> 消息头</li>
<li><code>String expiration;</code> 消息的存活时间，单位ms</li>
<li><code>long deliveryTag;</code> 消息的投递序号</li>
</ul>
<p>常用API：</p>
<ul>
<li><code>void setDelay(Integer delay)</code>：给消息头中设置<code>x-delay</code>属性（单位ms），用于配合延迟队列插件使用</li>
</ul>
<h1 id="第03章_交换机">第03章_交换机</h1>
<h2 id="1-交换机简介">1. 交换机简介</h2>
<p>RabbitMQ消息传递模型的核心思想是: <strong>生产者生产的消息不会直接发送到队列，而是只能将消息发送到交换机(Exchange)</strong>。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。</p>
<p>交换机工作的内容非常简单：一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息，是应该把这些消息放到特定队列、还是把它们放到许多队列中、还是应该丢弃它们，这就由交换机的类型来决定。</p>
<p><strong>Exchange有四种类型</strong>：</p>
<ul>
<li>扇出(fanout)</li>
<li>直接(direct)</li>
<li>主题(topic)</li>
<li>头部(headers)</li>
</ul>
<blockquote>
<p>说明：binding指的是exchange和queue之间的绑定关系。<strong>在绑定时</strong>，direct和topic类型的交换机都需要设置队列的routingKey；而headers类型的交换机需要设置匹配的消息头属性；fanout类型的交换机什么都不需要设置。</p>
</blockquote>
<h2 id="2-fanout-exchange">2. Fanout Exchange</h2>
<h3 id="21-fanout介绍">2.1 Fanout介绍</h3>
<p>Fanout类型的交换机，会将消息<strong>广播</strong>发送到它绑定的所有队列中，所以其routingKey无需设置。这种交换机表示的就是<strong>发布订阅模式</strong>。</p>
<h3 id="22-fanout实战">2.2 Fanout实战</h3>
<h4 id="1-配置类">1、配置类</h4>
<pre><code class="language-java">@Configuration
public class RabbitConfig {
    @Bean // 定义交换机
    public FanoutExchange fanoutExchange() {
        return ExchangeBuilder.fanoutExchange(&quot;exchange.fanout&quot;).build();
    }

    @Bean // 定义队列A
    public Queue queueA() {
        return QueueBuilder.durable(&quot;queue.a&quot;).build();
    }
    @Bean // 定义队列B
    public Queue queueB() {
        return QueueBuilder.durable(&quot;queue.b&quot;).build();
    }

    @Bean // 绑定交换机和队列A
    public Binding bindingA(FanoutExchange fanoutExchange, Queue queueA) {
        return BindingBuilder.bind(queueA).to(fanoutExchange);
    }
    @Bean // 绑定交换机和队列B
    public Binding bindingB(FanoutExchange fanoutExchange, Queue queueB) {
        return BindingBuilder.bind(queueB).to(fanoutExchange);
    }
}
</code></pre>
<h4 id="2-消息生产者">2、消息生产者</h4>
<p>使用RabbitTemplate来发送消息：</p>
<ul>
<li><code>void convertAndSend(String exchange, String routingKey, Object object)</code></li>
</ul>
<pre><code class="language-java">@RestController
public class MessageProducer {
    @Autowired
    private RabbitTemplate template;

    @GetMapping(&quot;/send&quot;)
    public void sendMsg() {
        Message msg = new Message(&quot;hello world&quot;.getBytes());
        template.convertAndSend(&quot;exchange.fanout&quot;, &quot;&quot;, msg);
    }
}
</code></pre>
<h4 id="3-消息消费者">3、消息消费者</h4>
<p>使用@RabbitListener注解来监听队列中的消息</p>
<pre><code class="language-java">@Component
public class MessageConsumer {
    @RabbitListener(queues = {&quot;queue.a&quot;, &quot;queue.b&quot;})
    public void receiveMsg(Message msg) {
        byte[] body = msg.getBody();
        String str = new String(body);
        System.out.println(&quot;收到消息：&quot; + str);
    }
}
</code></pre>
<h2 id="3-direct-exchange">3. Direct Exchange</h2>
<h3 id="31-direct介绍">3.1 Direct介绍</h3>
<p>Direct类型的交换机，会将收到的消息只发送给它绑定的相应<strong>精确routingKey的队列中</strong>去。</p>
<ul>
<li>交换机与同一个队列绑定时，也可以设置多个routingKey</li>
<li>交换机与不同的队列绑定时，也可以设置相同的routingKey</li>
</ul>
<blockquote>
<p>注意：如果根据某个消息的routingKey路由不到对应的queue，那么该消息就会被直接丢弃。</p>
</blockquote>
<h3 id="32-direct实战">3.2 Direct实战</h3>
<blockquote>
<p>需求：我们创建一个direct类型的交换机，将warning信息发给a队列，将error信息发送给a和b队列。</p>
</blockquote>
<h4 id="1-配置类-2">1、配置类</h4>
<pre><code class="language-java">@Configuration
public class RabbitConfig {
    @Bean
    public DirectExchange directExchange() {
        return ExchangeBuilder.directExchange(&quot;exchange.direct&quot;).build();
    }

    @Bean
    public Queue queueA() {
        return QueueBuilder.durable(&quot;queue.a&quot;).build();
    }
    @Bean
    public Queue queueB() {
        return QueueBuilder.durable(&quot;queue.b&quot;).build();
    }

    @Bean
    public Binding bindingA1(DirectExchange directExchange, Queue queueA) {
        return BindingBuilder.bind(queueA).to(directExchange)
                .with(&quot;warning&quot;);
    }
    @Bean
    public Binding bindingA2(DirectExchange directExchange, Queue queueA) {
        return BindingBuilder.bind(queueA).to(directExchange)
                .with(&quot;error&quot;);
    }
    @Bean
    public Binding bindingB(DirectExchange directExchange, Queue queueB) {
        return BindingBuilder.bind(queueB).to(directExchange)
                .with(&quot;error&quot;);
    }
}
</code></pre>
<h4 id="2-消息生产者-2">2、消息生产者</h4>
<pre><code class="language-java">@RestController
public class MessageProducer {
    @Autowired
    private RabbitTemplate template;

    @GetMapping(&quot;/warn&quot;)
    public void sendWarning() {
        Message msg = MessageBuilder.withBody(&quot;hello warning&quot;.getBytes()).build();
        template.convertAndSend(&quot;exchange.direct&quot;, &quot;warning&quot;, msg);
    }
    @GetMapping(&quot;/err&quot;)
    public void sendError() {
        Message msg = MessageBuilder.withBody(&quot;hello error&quot;.getBytes()).build();
        template.convertAndSend(&quot;exchange.direct&quot;, &quot;error&quot;, msg);
    }
}
</code></pre>
<h4 id="3-消息消费者-2">3、消息消费者</h4>
<pre><code class="language-java">@Component
public class MessageConsumer {
    @RabbitListener(queues = &quot;queue.a&quot;)
    public void receiveA(Message msg) {
        byte[] body = msg.getBody();
        String str = new String(body);
        System.out.println(&quot;收到A中的消息：&quot; + str);
    }

    @RabbitListener(queues = &quot;queue.b&quot;)
    public void receiveB(Message msg) {
        byte[] body = msg.getBody();
        String str = new String(body);
        System.out.println(&quot;收到B中的消息：&quot; + str);
    }
}
</code></pre>
<h2 id="4-topic-exchange">4. Topic Exchange</h2>
<h3 id="41-topic介绍">4.1 Topic介绍</h3>
<p>Topic类型的交换机是Direct类型的增强，同样会将收到的消息只发送给它绑定的相应routingKey的队列中去，但其routingKey可以使用通配符匹配。</p>
<p>Topic交换机的routingKey必须满足一定的要求，它必须是<strong>一个单词列表，以点号分隔开</strong>。且这个单词列表最多不能超过255个字节。注意，可以使用两个特殊的替换符：</p>
<ul>
<li><code>*</code>可以匹配任意一个单词</li>
<li><code>#</code>可以匹配任意0个或多个单词</li>
</ul>
<p>例如，topic交换机与队列a通过<code>routingKey=&quot;*.orange.*&quot;</code>绑定，与队列b通过<code>routingKey=&quot;*.*.rabbit&quot;</code>和<code>routingKey=&quot;lazy.#&quot;</code>绑定，那么</p>
<ul>
<li>a.orange.rabbit则会路由到a和b</li>
<li>lazy.abc会路由到b</li>
<li>lazy.abc.rabbit会路由到b</li>
</ul>
<blockquote>
<p>注意：如果根据某个消息的routingKey路由不到对应的queue，那么该消息就会被直接丢弃。</p>
</blockquote>
<h3 id="42-topic实战">4.2 Topic实战</h3>
<h4 id="1-配置类-3">1、配置类</h4>
<pre><code class="language-java">@Configuration
public class RabbitConfig {
    @Bean
    public TopicExchange topicExchange() {
        return ExchangeBuilder.topicExchange(&quot;exchange.topic&quot;).build();
    }

    @Bean
    public Queue queueA() {
        return QueueBuilder.durable(&quot;queue.a&quot;).build();
    }
    @Bean
    public Queue queueB() {
        return QueueBuilder.durable(&quot;queue.b&quot;).build();
    }

    @Bean
    public Binding bindingA(TopicExchange topicExchange, Queue queueA) {
        return BindingBuilder.bind(queueA).to(topicExchange)
                .with(&quot;*.orange.*&quot;);
    }
    @Bean
    public Binding bindingB1(TopicExchange topicExchange, Queue queueB) {
        return BindingBuilder.bind(queueB).to(topicExchange)
                .with(&quot;*.*.rabbit&quot;);
    }
    @Bean
    public Binding bindingB2(TopicExchange topicExchange, Queue queueB) {
        return BindingBuilder.bind(queueB).to(topicExchange)
                .with(&quot;lazy.#&quot;);
    }
}
</code></pre>
<h4 id="2-消息生产者-3">2、消息生产者</h4>
<pre><code class="language-java">@RestController
public class MessageProducer {
    @Autowired
    private RabbitTemplate template;

    @GetMapping(&quot;/test1&quot;)
    public void test1() {
        Message msg = new Message(&quot;test1 haha&quot;.getBytes());
        template.convertAndSend(&quot;exchange.topic&quot;, &quot;a.orange.rabbit&quot;, msg);
    }
    @GetMapping(&quot;/test2&quot;)
    public void test2() {
        Message msg = new Message(&quot;test2 haha&quot;.getBytes());
        template.convertAndSend(&quot;exchange.topic&quot;, &quot;lazy.abc&quot;, msg);
    }
    @GetMapping(&quot;/test3&quot;)
    public void test3() {
        Message msg = new Message(&quot;test3 haha&quot;.getBytes());
        template.convertAndSend(&quot;exchange.topic&quot;, &quot;lazy.abc.rabbit&quot;, msg);
    }
}
</code></pre>
<h4 id="3-消息消费者-3">3、消息消费者</h4>
<pre><code class="language-java">@Component
public class MessageConsumer {
    @RabbitListener(queues = &quot;queue.a&quot;)
    public void receiveA(Message msg) {
        byte[] body = msg.getBody();
        String str = new String(body);
        System.out.println(&quot;收到A中的消息：&quot; + str);
    }

    @RabbitListener(queues = &quot;queue.b&quot;)
    public void receiveB(Message msg) {
        byte[] body = msg.getBody();
        String str = new String(body);
        System.out.println(&quot;收到B中的消息：&quot; + str);
    }
}
</code></pre>
<h2 id="5-headers-exchange">5. Headers Exchange</h2>
<h3 id="51-headers介绍">5.1 Headers介绍</h3>
<p>Headers类型的交换机，基于消息属性中的headers进行匹配，所以其routingKey并没有作用。</p>
<blockquote>
<p>说明：Headers类型的交换机性能很差，而且很不实用，实际生产中不推荐使用。</p>
</blockquote>
<h3 id="52-headers实战">5.2 Headers实战</h3>
<h4 id="1-配置类-4">1、配置类</h4>
<pre><code class="language-java">@Configuration
public class RabbitConfig {
    @Bean
    public HeadersExchange headersExchange() {
        return ExchangeBuilder.headersExchange(&quot;exchange.headers&quot;).build();
    }

    @Bean
    public Queue queueA() {
        return QueueBuilder.durable(&quot;queue.a&quot;).build();
    }
    @Bean
    public Queue queueB() {
        return QueueBuilder.durable(&quot;queue.b&quot;).build();
    }

    @Bean // 绑定时指定需要匹配的消息头属性，而不是设置routingKey
    public Binding bindingA(HeadersExchange headersExchange, Queue queueA) {
        Map&lt;String, Object&gt; headerValues = new HashMap&lt;&gt;();
        headerValues.put(&quot;type&quot;, &quot;m&quot;);
        headerValues.put(&quot;status&quot;, 1);
        return BindingBuilder.bind(queueA).to(headersExchange)
                .whereAll(headerValues).match();
    }
    @Bean // 绑定时指定需要匹配的消息头属性，而不是设置routingKey
    public Binding bindingB(HeadersExchange headersExchange, Queue queueB) {
        Map&lt;String, Object&gt; headerValues = new HashMap&lt;&gt;();
        headerValues.put(&quot;type&quot;, &quot;s&quot;);
        headerValues.put(&quot;status&quot;, 0);
        return BindingBuilder.bind(queueB).to(headersExchange)
                .whereAll(headerValues).match();
    }
}
</code></pre>
<h4 id="2-消息生产者-4">2、消息生产者</h4>
<pre><code class="language-java">@RestController
public class MessageProducer {
    @Autowired
    private RabbitTemplate template;

    @GetMapping(&quot;/test1&quot;)
    public void test1() {
        // 定义消息属性
        MessageProperties messageProperties = new MessageProperties();
        Map&lt;String, Object&gt; headers = new HashMap&lt;&gt;();
        headers.put(&quot;type&quot;, &quot;m&quot;);
        headers.put(&quot;status&quot;, 1);
        // 设置消息头
        messageProperties.setHeaders(headers);
        // 添加消息属性
        Message msg = MessageBuilder.withBody(&quot;test1 haha666&quot;.getBytes())
                .andProperties(messageProperties).build();
        // 发送消息（头部交换机无需路由键）
        template.convertAndSend(&quot;exchange.headers&quot;, &quot;&quot;, msg);
    }
    @GetMapping(&quot;/test2&quot;)
    public void test2() {
        // 定义消息属性
        MessageProperties messageProperties = new MessageProperties();
        Map&lt;String, Object&gt; headers = new HashMap&lt;&gt;();
        headers.put(&quot;type&quot;, &quot;s&quot;);
        headers.put(&quot;status&quot;, 0);
        // 设置消息头
        messageProperties.setHeaders(headers);
        // 添加消息属性
        Message msg = MessageBuilder.withBody(&quot;test2 haha888&quot;.getBytes())
                .andProperties(messageProperties).build();
        // 发送消息（头部交换机无需路由键）
        template.convertAndSend(&quot;exchange.headers&quot;, &quot;&quot;, msg);
    }
}
</code></pre>
<h4 id="3-消息消费者-4">3、消息消费者</h4>
<pre><code class="language-java">@Component
public class MessageConsumer {
    @RabbitListener(queues = &quot;queue.a&quot;)
    public void receiveA(Message msg) {
        byte[] body = msg.getBody();
        String str = new String(body);
        System.out.println(&quot;收到A中的消息：&quot; + str);
    }

    @RabbitListener(queues = &quot;queue.b&quot;)
    public void receiveB(Message msg) {
        byte[] body = msg.getBody();
        String str = new String(body);
        System.out.println(&quot;收到B中的消息：&quot; + str);
    }
}
</code></pre>
<h1 id="第04章_消息的可靠性投递">第04章_消息的可靠性投递</h1>
<h2 id="1-简介">1. 简介</h2>
<p>消息的可靠性投递，指的就是要保证消息投递过程中每一个环节都要成功。所以要保证可靠性，必然会牺牲一点性能。保证消息的完全可靠投递，有以下四个环节：</p>
<ol>
<li>保证消息从生产者正确投递到交换机。一般使用消息的Confirm模式来保证该环节的可靠性。</li>
<li>保证消息从交换机正确路由到队列。一般使用消息的Returns模式，或者使用备用交换机，来保证该环节的可靠性。</li>
<li>保证消息的持久存储。一般让交换机、队列、消息都进行持久化，就能保证该环节的可靠性。</li>
<li>保证消息从队列中正确被消费者消费。一般使用消息的手动确认，就能保证该环节的可靠性。</li>
</ol>
<h2 id="2-环节一confirm模式">2. 环节一：Confirm模式</h2>
<h3 id="21-简介">2.1 简介</h3>
<p>在环节一中，我们要保证消息从生产者成功投递到交换机。所以可以使用消息的Confirm模式，<strong>当消息成功或失败投递到交换机，都会给生产者一个响应，告知其投递结果</strong>。其底层实现，实际上是在生产者和交换机中设有一个缓存，每次消息都先发送到缓存中，然后再由缓存发送给交换机，并通知生产者投递到交换机的成功与否。</p>
<p>使用消息的Confirm模式，首先<strong>需要在配置文件中添加</strong>：</p>
<pre><code class="language-properties">spring.rabbitmq.publisher-confirm-type=correlated
</code></pre>
<ul>
<li><code>none</code>表示禁用Confirm模式，是默认值</li>
<li><code>correlated</code>表示开启Confirm模式</li>
</ul>
<p>其次，需要写一个类来实现<code>RabbitTemplate.ConfirmCallback</code>接口，重写其<code>confirm()</code>方法，该方法就是当消息成功/失败投递到交换机时生产者的回调方法。</p>
<h3 id="22-配置类">2.2 配置类</h3>
<pre><code class="language-java">@Configuration
public class RabbitConfig {
    public static final String EXCHANGE_NAME = &quot;confirm.exchange&quot;; // 交换机
    public static final String QUEUE_NAME = &quot;confirm.queue&quot;; // 队列
    public static final String ROUTING_KEY = &quot;key1&quot;; // 路由key

    @Bean // 声明交换机
    public DirectExchange confirmExchange() {
        return ExchangeBuilder.directExchange(EXCHANGE_NAME).build();
    }

    @Bean // 声明队列
    public Queue confirmQueue() {
        return QueueBuilder.durable(QUEUE_NAME).build();
    }

    @Bean // 绑定
    public Binding binding(Queue confirmQueue, DirectExchange confirmExchange) {
        return BindingBuilder.bind(confirmQueue).to(confirmExchange)
                .with(ROUTING_KEY);
    }
}
</code></pre>
<h3 id="23-生产者的回调接口核心">2.3 生产者的回调接口(核心)</h3>
<p>RabbitTemplate类中有一个内部的ConfirmCallback接口，为我们提供了confirm回调方法，当交换机成功或失败收到消息时，都会触发其回调方法：</p>
<pre><code class="language-java">@Slf4j
@Component
public class MyCallBack implements RabbitTemplate.ConfirmCallback {
    @Autowired
    private RabbitTemplate rabbitTemplate;

    @PostConstruct // 该注解标注的方法会在构造器执行之后执行
    public void init() {
        // 由于该类实现的是RabbitTemplate类内部的接口，所以需要将该类注入进去
        rabbitTemplate.setConfirmCallback(this);
    }

    /**
     * 当交换机成功或失败收到消息，都会触发该回调方法
     * @param correlationData 保存消息的id及相关信息
     * @param b 交换机成功收到消息，则为true，否则为false
     * @param s 交换机未收到消息的原因(若成功收到消息，则为null)
     */
    @Override
    public void confirm(CorrelationData correlationData, boolean b, String s) {
        String id = correlationData != null ? correlationData.getId() : &quot;&quot;;
        if (b) {
            log.info(&quot;交换机成功收到id={}的消息&quot;, id);
        } else {
            log.info(&quot;交换机未能收到id={}的消息，错误原因:{}&quot;, id, s);
        }
    }
}
</code></pre>
<h3 id="24-生产者">2.4 生产者</h3>
<p>在生产者中，我们模拟三种情况：成功发送消息、交换机名称错误、队列路由key错误。</p>
<pre><code class="language-java">@Slf4j
@RestController
public class SendMsgController {
    @Autowired
    private RabbitTemplate rabbitTemplate;

    // 成功发送消息
    @GetMapping(&quot;/sendMessage1/{message}&quot;)
    public void sendMessage1(@PathVariable(&quot;message&quot;) String message) {
        // 保存消息的相关数据，有参构构造器可以传入自定义的消息id
        CorrelationData correlationData = new CorrelationData(&quot;1&quot;);
        rabbitTemplate.convertAndSend(RabbitConfig.EXCHANGE_NAME,
                RabbitConfig.ROUTING_KEY, message, correlationData);
        log.info(&quot;发送消息：{}&quot;, message);
    }

    // 失败发送消息(交换机名称错误)
    @GetMapping(&quot;/sendMessage2/{message}&quot;)
    public void sendMessage2(@PathVariable(&quot;message&quot;) String message) {
        CorrelationData correlationData = new CorrelationData(&quot;2&quot;);
        rabbitTemplate.convertAndSend(&quot;error&quot;,
                RabbitConfig.ROUTING_KEY, message, correlationData);
        log.info(&quot;发送消息：{}&quot;, message);
    }

    // 失败发送消息(队列路由key错误)
    @GetMapping(&quot;/sendMessage3/{message}&quot;)
    public void sendMessage3(@PathVariable(&quot;message&quot;) String message) {
        CorrelationData correlationData = new CorrelationData(&quot;3&quot;);
        rabbitTemplate.convertAndSend(RabbitConfig.EXCHANGE_NAME,
                &quot;error&quot;, message, correlationData);
        log.info(&quot;发送消息：{}&quot;, message);
    }
}
</code></pre>
<h3 id="25-消费者">2.5 消费者</h3>
<pre><code class="language-java">@Slf4j
@Component
public class Consumer {
    @RabbitListener(queues = RabbitConfig.QUEUE_NAME)
    public void receiveMessage(Message message) {
        String msg = new String(message.getBody());
        log.info(&quot;接收消息：{}&quot;, msg);
    }
}
</code></pre>
<h3 id="26-测试">2.6 测试</h3>
<p>（1）访问<code>http://localhost:8080/sendMessage1/wsy111</code>，控制台打印如下：</p>
<pre><code>... 发送消息：wsy111
... 交换机成功收到id=1的消息
... 接收消息：wsy111
</code></pre>
<p>交换机成功收到消息，触发回调，符合预期！</p>
<p>（2）访问<code>http://localhost:8080/sendMessage2/wsy222</code>，控制台打印如下：</p>
<pre><code>... 发送消息：wsy222
... Shutdown Signal: channel error; protocol method: #method&lt;channel.close&gt;(reply-code=404, reply-text=NOT_FOUND - no exchange 'error' in vhost '/', class-id=60, method-id=40)
... 交换机未能收到id=2的消息，错误原因:channel error; protocol method: #method&lt;channel.close&gt;(reply-code=404, reply-text=NOT_FOUND - no exchange 'error' in vhost '/', class-id=60, method-id=40)
</code></pre>
<p>交换机未能收到消息，触发回调，符合预期！</p>
<p>（3）访问<code>http://localhost:8080/sendMessage3/wsy333</code>，控制台打印如下：</p>
<pre><code>... 发送消息：wsy333
... 交换机成功收到id=3的消息
</code></pre>
<p>交换机成功收到消息，触发回调，同样符合预期。但是，由于routingKey错误，导致没有队列能接收这个消息，所以这条消息直接被丢弃了，但事实上这种消息传送失败的情况也应该回馈给生产者。所以我们需要在环节二也保证可靠性。</p>
<h2 id="3-环节二returns模式">3. 环节二：Returns模式</h2>
<h3 id="31-简介">3.1 简介</h3>
<p>在环节二中，我们需要保证消息从交换机成功路由到队列。为了保证该环节的可靠性，一种方式是采用消息的Returns模式，即<strong>当消息无法路由到队列时会触发生产者的回调</strong>。</p>
<p>使用消息的Returns模式，<strong>首先需要在配置文件中添加</strong>：</p>
<pre><code class="language-properties">spring.rabbitmq.publisher-returns=true
</code></pre>
<p>其次，需要写一个类来实现<code>RabbitTemplate.ReturnsCallback</code>接口，重写其<code>returnedMessage()</code>方法，该方法就是当消息无法路由到队列时生产者的回调方法。</p>
<blockquote>
<p>注意：Confirm模式中，消息无论成功或失败投递到Exchange，都会触发回调；而Returns模式中，只有消息无法路由到队列时，才会触发回调（成功路由到队列则不会触发回调）。</p>
</blockquote>
<h3 id="32-生产者的回调接口核心">3.2 生产者的回调接口(核心)</h3>
<p>配置类、生产者、消费者的代码和环节一中的代码一样。我们只需修改生产者的回调接口，额外实现RabbitTemplate内部的ReturnsCallback接口即可：</p>
<pre><code class="language-java">@Slf4j
@Component
public class MyCallBack implements RabbitTemplate.ConfirmCallback, RabbitTemplate.ReturnsCallback {
    @Autowired
    private RabbitTemplate rabbitTemplate;

    @PostConstruct // 该注解标注的方法会在构造器执行之后执行
    public void init() {
        // 由于该类实现的是RabbitTemplate类内部的接口，所以需要将该类注入进去
        rabbitTemplate.setConfirmCallback(this);
        rabbitTemplate.setReturnsCallback(this);
    }

    @Override // 交换机成功或失败收到消息的回调方法
    public void confirm(CorrelationData correlationData, boolean b, String s) {
        String id = correlationData != null ? correlationData.getId() : &quot;&quot;;
        if (b) {
            log.info(&quot;交换机成功收到id={}的消息&quot;, id);
        } else {
            log.info(&quot;交换机未能收到id={}的消息，错误原因:{}&quot;, id, s);
        }
    }

    @Override // 当消息无法路由到队列时的回调方法
    public void returnedMessage(ReturnedMessage message) {
        log.error(&quot;消息：{}，被交换机{}退回，退回原因：{}，路由key：{}&quot;,
                new String(message.getMessage().getBody()),
                message.getExchange(),
                message.getReplyText(),
                message.getRoutingKey());
    }
}
</code></pre>
<h3 id="33-测试">3.3 测试</h3>
<p>访问<code>http://localhost:8080/sendMessage3/wsy333</code>，控制台打印如下：</p>
<pre><code>... 发送消息：wsy333
... 消息：wsy333，被交换机confirm.exchange退回，退回原因：NO_ROUTE，路由key：error
... 交换机成功收到id=3的消息
</code></pre>
<p>交换机成功收到消息，触发<code>confirm()</code>回调，同时由于routingKey错误、消息无法路由，触发<code>returnedMessage()</code>回调，符合预期！</p>
<h2 id="4-环节二备用交换机">4. 环节二：备用交换机</h2>
<h3 id="41-简介">4.1 简介</h3>
<p>对于无法路由的消息，固然可以采用Returns模式来交给生产者处理，但这样会增加生产者的复杂性。更好的方案是使用<strong>备用交换机</strong>，即把所有无法路由的消息，都转发给一个备用交换机，由备用交换机来做相应的处理。通常<strong>备用交换机的类型是Fanout</strong>，这样就能把消息投递到所有与其绑定的队列中(这样就解决了routingKey错误导致的无法路由)，通常会建立一个备用队列专门处理这些消息，以及一个警告队列专门进行监测和警告。</p>
<blockquote>
<p>注意：同时使用消息Returns模式和备用交换机时，<strong>备用交换机优先级高</strong>。</p>
</blockquote>
<p>代码架构图如下：</p>
<figure data-type="image" tabindex="2"><img src="images/20231005141801.png" alt="" loading="lazy"></figure>
<blockquote>
<p>为了简便，我们省略交换机处的Confirm模式，只演示无法路由的消息该如何处理。</p>
</blockquote>
<h3 id="42-配置类">4.2 配置类</h3>
<pre><code class="language-java">@Configuration
public class RabbitConfig {
    public static final String CONFIRM_EXCHANGE = &quot;confirm.exchange&quot;; // 确认交换机
    public static final String CONFIRM_QUEUE = &quot;confirm.queue&quot;; // 确认队列
    public static final String ROUTING_KEY = &quot;key1&quot;; // 路由key
    public static final String BACKUP_EXCHANGE = &quot;backup.exchange&quot;; // 备用交换机
    public static final String BACKUP_QUEUE = &quot;backup.queue&quot;; // 备用队列
    public static final String WARNING_QUEUE = &quot;warning.queue&quot;; // 警告队列

    @Bean // 确认交换机
    public DirectExchange confirmExchange() {
        // 无法路由的消息，将转发给备用交换机
        return ExchangeBuilder.directExchange(CONFIRM_EXCHANGE)
                .alternate(BACKUP_EXCHANGE).build();
    }

    @Bean // 确认队列
    public Queue confirmQueue() {
        return QueueBuilder.durable(CONFIRM_QUEUE).build();
    }

    @Bean // 绑定确认交换机和确认队列
    public Binding bindingConfirm(Queue confirmQueue, DirectExchange confirmExchange) {
        return BindingBuilder.bind(confirmQueue).to(confirmExchange)
                .with(ROUTING_KEY);
    }

    @Bean // 备用交换机
    public FanoutExchange backupExchange() {
        return ExchangeBuilder.fanoutExchange(BACKUP_EXCHANGE).build();
    }

    @Bean // 备用队列
    public Queue backupQueue() {
        return QueueBuilder.durable(BACKUP_QUEUE).build();
    }

    @Bean // 警告队列
    public Queue warningQueue() {
        return QueueBuilder.durable(WARNING_QUEUE).build();
    }

    @Bean // 绑定备用队列和备用交换机
    public Binding bindingBackup(Queue backupQueue, FanoutExchange backupExchange) {
        return BindingBuilder.bind(backupQueue).to(backupExchange);
    }

    @Bean // 绑定警告队列和备用交换机
    public Binding bindingWarning(Queue warningQueue, FanoutExchange backupExchange) {
        return BindingBuilder.bind(warningQueue).to(backupExchange);
    }
}
</code></pre>
<h3 id="43-消费者">4.3 消费者</h3>
<p>ConfirmConsumer：</p>
<pre><code class="language-java">@Slf4j
@Component
public class ConfirmConsumer {
    @RabbitListener(queues = RabbitConfig.CONFIRM_QUEUE)
    public void receiveConfirmMessage(Message message) {
        String msg = new String(message.getBody());
        log.info(&quot;接收confirm消息：{}&quot;, msg);
    }
}
</code></pre>
<p>WarningConsumer：</p>
<pre><code class="language-java">@Slf4j
@Component
public class WarningConsumer {
    @RabbitListener(queues = RabbitConfig.WARNING_QUEUE)
    public void receiveWarningMessage(Message message) {
        String msg = new String(message.getBody());
        log.warn(&quot;发现不可路由的消息：{}&quot;, msg);
    }
}
</code></pre>
<h3 id="44-生产者">4.4 生产者</h3>
<pre><code class="language-java">@Slf4j
@RestController
public class SendMsgController {
    @Autowired
    private RabbitTemplate rabbitTemplate;

    // 正确路由的消息
    @GetMapping(&quot;/sendConfirm/{message}&quot;)
    public void sendConfirm(@PathVariable(&quot;message&quot;) String message) {
        rabbitTemplate.convertAndSend(RabbitConfig.CONFIRM_EXCHANGE,
                RabbitConfig.ROUTING_KEY, message);
        log.info(&quot;发送消息：{}&quot;, message);
    }

    // 错误路由的消息
    @GetMapping(&quot;/sendWarning/{message}&quot;)
    public void sendWarning(@PathVariable(&quot;message&quot;) String message) {
        rabbitTemplate.convertAndSend(RabbitConfig.CONFIRM_EXCHANGE,
                &quot;error&quot;, message);
        log.info(&quot;发送消息：{}&quot;, message);
    }
}
</code></pre>
<h3 id="45-测试">4.5 测试</h3>
<p>（1）访问<code>http://localhost:8080/sendConfirm/wsy111</code>，控制台打印如下</p>
<pre><code>... 发送消息：wsy111
... 接收confirm消息：wsy111
</code></pre>
<p>（2）访问<code>http://localhost:8080/sendWarning/wsy222</code>，控制台打印如下</p>
<pre><code>... 发送消息：wsy222
... 发现不可路由的消息：wsy222
</code></pre>
<h2 id="5-环节三持久化">5. 环节三：持久化</h2>
<p>要保证消息的持久存储，一般让交换机、队列、消息都进行持久化，就能保证该环节的可靠性。</p>
<ul>
<li>交换机的持久化：使用ExchangeBuilder创建出的交换机，默认都是持久化的。</li>
<li>队列的持久化：使用QueueBuilder的<code>durable(String name)</code>方法创建出的队列是持久化的。</li>
<li>消息的持久化：使用RabbitTemplate的<code>convertAndSend()</code>方法发送消息时，消息默认就是持久化的。因为该方法会将消息转换为一个Message对象，为其设置MessageProperties，注意到MessageProperties类中有一个属性deliveryMode进行了显式默认赋值，这个默认值就表示该消息是持久化的。</li>
</ul>
<h2 id="6-环节四消息手动确认">6. 环节四：消息手动确认</h2>
<h3 id="61-简介">6.1 简介</h3>
<p>RabbitMQ使用了<strong>消息确认机制</strong>，即消费者在接收到消息后，会给MQ发送确认消息，而MQ一旦收到确认就会把该消息从队列中删除。</p>
<p>RabbitMQ默认采用<strong>消息自动确认</strong>，即消费者收到消息后，就会自动给MQ发送确认消息。</p>
<p>但我们建议开启<strong>消息手动确认</strong>，即当消费者处理完毕消息后，在合适的时机手动返回ACK通知MQ删除消息，这样就能<strong>保证消息从队列中正确被消费者消费后才会删除</strong>。使用消息手动确认模式，需要在配置文件中配置：</p>
<pre><code class="language-properties">spring.rabbitmq.listener.simple.acknowledge-mode=manual
</code></pre>
<h3 id="62-消息手动确认的api">6.2 消息手动确认的API</h3>
<p>使用com.rabbitmq.client.Channel接口的以下API可以进行手动的消息确认：</p>
<ul>
<li><code>void basicAck(long deliveryTag, boolean multiple)</code>：肯定确认，第一个参数是消息的投递序号，第二个参数表示是否使用累计确认机制</li>
<li><code>void basicNack(long deliveryTag, boolean multiple, boolean requeue)</code>：否定确认，第三个参数表示消息是否重新入队</li>
<li><code>void basicReject(long deliveryTag, boolean requeue)</code>：否定确认，与<code>basicNack()</code>的唯一区别是它无法累积确认</li>
</ul>
<h3 id="63-累积确认机制">6.3 累积确认机制</h3>
<p>对于参数multiple：</p>
<ul>
<li>设置为true，表示使用累积确认机制，即批量确认当前投递序号及之前的所有消息。这种方式效率更高，但可能会丢失之前的消息。</li>
<li>设置为false，表示不使用累积确认机制，即只确认当前投递序号的消息。这种方式更加安全，不容易丢失消息，<strong>推荐使用这种方式</strong>。</li>
</ul>
<h3 id="64-消息的重新入队机制">6.4 消息的重新入队机制</h3>
<p>对于参数requeue：</p>
<ul>
<li>设置为true，表示当收到消息的否定确认时，会将该消息重新加入队列的队尾</li>
<li>设置为false，表示当收到消息的否定确认时，该消息就直接变为死信</li>
</ul>
<blockquote>
<p>注意：在RabbitMQ默认的消息自动确认模式中，被拒绝的消息就采用自动重新入队的机制。</p>
</blockquote>
<h3 id="65-代码示例">6.5 代码示例</h3>
<pre><code class="language-java">@Component
@Slf4j
public class RabbitConsumer {
    @RabbitListener(queues = &quot;normal.queue&quot;)
    public void receive(Message msg, Channel channel) throws IOException {
        // 1. 获取消息的投递序号（消息的唯一标识）
        long deliveryTag = msg.getMessageProperties().getDeliveryTag();
        try {
            // 2. 核心业务操作
            log.info(&quot;消息内容：{}&quot;, new String(msg.getBody()));
            // 3. 核心业务操作成功，返回ACK
            channel.basicAck(deliveryTag, false);
        } catch (Exception e) {
            // 4. 核心业务操作异常，返回NACK
            channel.basicNack(deliveryTag, false, true);
        }
    }
}
</code></pre>
<h1 id="第05章_死信队列">第05章_死信队列</h1>
<h2 id="1-死信的概念">1. 死信的概念</h2>
<p>死信，指的就是无法被消费的消息。当producer将消息投递到broker中，consumer可能由于特定的原因<strong>导致某些消息无法被消费</strong>，这样的消息就称为死信，我们需要将死信放入<strong>死信队列</strong>中进行统一处理。</p>
<p><strong>应用场景</strong>：例如为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。</p>
<p><strong>产生死信的情况</strong>：</p>
<ul>
<li>消息TTL过期(TTL即Time To Live，生存时间)</li>
<li>队列达到最大长度（即队列已满）</li>
<li>消息被拒绝(否定确认)，即<code>channel.basicReject()</code>或<code>channel.basicNack()</code>，并且没有重新入队(<code>requeue=false</code>)</li>
</ul>
<h2 id="2-消息ttl过期-案例演示">2. 消息TTL过期-案例演示</h2>
<p>案例架构图如下：</p>
<figure data-type="image" tabindex="3"><img src="images/20231002210502.png" alt="" loading="lazy"></figure>
<h4 id="1-配置类-5">1、配置类</h4>
<pre><code class="language-java">@Configuration
public class RabbitConfig {
    @Bean // 普通交换机
    public DirectExchange normalExchange() {
        return ExchangeBuilder.directExchange(&quot;normal.exchange&quot;).build();
    }
    @Bean // 普通队列
    public Queue normalQueue() {
        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();
        // 1. 设置对应的死信交换机
        arguments.put(&quot;x-dead-letter-exchange&quot;, &quot;dead.exchange&quot;);
        // 2. 设置死信的routingKey
        arguments.put(&quot;x-dead-letter-routing-key&quot;, &quot;lisi&quot;);
        return QueueBuilder.durable(&quot;normal.queue&quot;)
                .withArguments(arguments).build();
    }
    @Bean // 绑定普通交换机和普通队列
    public Binding normalBinding(DirectExchange normalExchange, Queue normalQueue) {
        return BindingBuilder.bind(normalQueue).to(normalExchange).with(&quot;zhangsan&quot;);
    }

    @Bean // 死信交换机
    public DirectExchange deadExchange() {
        return ExchangeBuilder.directExchange(&quot;dead.exchange&quot;).build();
    }
    @Bean // 死信队列
    public Queue deadQueue() {
        return QueueBuilder.durable(&quot;dead.queue&quot;).build();
    }
    @Bean // 绑定死信交换机和死信队列
    public Binding deadBinding(DirectExchange deadExchange, Queue deadQueue) {
        return BindingBuilder.bind(deadQueue).to(deadExchange).with(&quot;lisi&quot;);
    }
}
</code></pre>
<h4 id="2-生产者">2、生产者</h4>
<pre><code class="language-java">@RestController
public class Producer {
    @Autowired
    private RabbitTemplate template;

    @GetMapping(&quot;/send&quot;)
    public void send() {
        MessageProperties messageProperties = new MessageProperties();
        messageProperties.setExpiration(&quot;15000&quot;); // 设置TTL，单位ms
        Message msg = MessageBuilder.withBody(&quot;hello&quot;.getBytes())
                .andProperties(messageProperties).build();
        template.convertAndSend(&quot;normal.exchange&quot;, &quot;zhangsan&quot;, msg);
    }
}
</code></pre>
<h4 id="3-消费者c2">3、消费者C2</h4>
<p>由于没有消费者C1来消费普通队列，所以普通队列中的消息最终会变为死信，最终被消费者C2消费</p>
<pre><code class="language-java">@Component
public class Consumer2 {
    @RabbitListener(queues = &quot;dead.queue&quot;)
    public void receive(Message msg) {
        System.out.println(&quot;收到死信消息：&quot; + new String(msg.getBody()));
    }
}
</code></pre>
<h2 id="3-队列达到最大长度-案例演示">3. 队列达到最大长度-案例演示</h2>
<h4 id="1-配置类-6">1、配置类</h4>
<p>基本与上一个案例相同，只需在设置普通队列时多添加一个参数来限制最大长度：</p>
<pre><code class="language-java">arguments.put(&quot;x-max-length&quot;, 6); // 设置普通队列的最大长度为6
</code></pre>
<blockquote>
<p>注意：当队列满时再收到消息，会<strong>将队首的消息弹出、变为死信</strong>，然后新消息再入队。</p>
</blockquote>
<h4 id="2-生产者-2">2、生产者</h4>
<pre><code class="language-java">@RestController
public class Producer {
    @Autowired
    private RabbitTemplate template;

    @GetMapping(&quot;/send&quot;)
    public void send() {
        for (int i = 0; i &lt; 10; i++) {
            String str = &quot;hello&quot; + i;
            Message msg = MessageBuilder.withBody(str.getBytes()).build();
            template.convertAndSend(&quot;normal.exchange&quot;, &quot;zhangsan&quot;, msg);
        }
    }
}
</code></pre>
<h4 id="3-消费者c2-2">3、消费者C2</h4>
<p>与上一个案例相同。注意，在测试时，要先进入Web管理界面将上一个案例创建的交换机、队列删除。</p>
<h2 id="4-消息被拒-案例演示">4. 消息被拒-案例演示</h2>
<h4 id="1-配置类-7">1、配置类</h4>
<p>基本与上一个案例相同，只需删除普通队列的最大长度设置。</p>
<h4 id="2-生产者-3">2、生产者</h4>
<p>与上一个案例相同</p>
<h4 id="3-消费者c2-3">3、消费者C2</h4>
<p>与上一个案例相同</p>
<h4 id="4-消费者c1">4、消费者C1</h4>
<p>首先需要在配置文件中添加如下配置，开启消息手动确认模式：</p>
<pre><code class="language-properties">spring.rabbitmq.listener.simple.acknowledge-mode=manual
</code></pre>
<pre><code class="language-java">@Component
public class Consumer1 {
    @RabbitListener(queues = &quot;normal.queue&quot;)
    public void receive(Message msg, Channel channel) throws IOException {
        String str = new String(msg.getBody());
        // 获取消息的投递序号
        long deliveryTag = msg.getMessageProperties().getDeliveryTag();
        // 拒收内容为hello4的消息
        if (&quot;hello4&quot;.equals(str)) {
            // 第2个参数表示是否重新入队
            channel.basicReject(deliveryTag, false);
        } else {
            System.out.println(&quot;收到普通消息：&quot; + str);
            // 第2个参数表示是否累积确认
            channel.basicAck(deliveryTag, false);
        }
    }
}
</code></pre>
<p>注意，在测试时，要先进入Web管理界面将上一个案例创建的交换机、队列删除。</p>
<h1 id="第06章_延迟队列">第06章_延迟队列</h1>
<h2 id="1-延迟队列简介">1. 延迟队列简介</h2>
<h3 id="11-延迟队列概念">1.1 延迟队列概念</h3>
<p>延迟队列用于存放需要在指定时间被处理的消息（延迟消息）。例如，让订单在十分钟之内未支付则自动取消，就可以使用延迟队列来实现。</p>
<p>AMQP协议以及RabbitMQ本身没有直接支持延迟队列的功能，但是我们可以通过基于TTL的死信机制来实现延迟队列。也就是给消息设置TTL、或给队列设置TTL，这样该队列就是一个延迟队列，当队列中的消息达到超时时间后，就变成死信，转发给死信交换机处理。</p>
<h3 id="12-ttl">1.2 TTL</h3>
<p>TTL是一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的<strong>最大存活时间</strong>，单位是<strong>毫秒</strong>。</p>
<p>如果一条消息设置了 TTL 属性或者进入了设置 TTL 属性的队列，那么这条消息如果在 TTL 设置的时间内没有被消费，则会成为死信。如果同时配置了队列的TTL和消息的TTL，那么<strong>较小的那个值将会被使用</strong>。</p>
<p><strong>队列设置TTL的方式</strong>：</p>
<pre><code class="language-java">@Bean 
public Queue normalQueue() {
    // 用于设置队列的相关参数
    Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();
    // 设置TTL，单位ms
    arguments.put(&quot;x-message-ttl&quot;, 15000);
    return QueueBuilder.durable(&quot;队列名称&quot;).withArguments(arguments).build();
}
</code></pre>
<p><strong>消息设置TTL的方式</strong>：</p>
<pre><code class="language-java">MessageProperties messageProperties = new MessageProperties();
messageProperties.setExpiration(&quot;15000&quot;); // 设置TTL，单位ms
Message msg = MessageBuilder.withBody(&quot;hello&quot;.getBytes())
        .andProperties(messageProperties).build();
</code></pre>
<blockquote>
<p>注意：如果不设置TTL，则表示消息永远不会过期。如果将TTL设置为0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会过期。</p>
</blockquote>
<h2 id="2-基于死信实现延迟队列">2. 基于死信实现延迟队列</h2>
<h3 id="21-代码架构图">2.1 代码架构图</h3>
<figure data-type="image" tabindex="4"><img src="images/20231004172834.png" alt="" loading="lazy"></figure>
<p>如上，三个普通队列QA、QB、QC，其中QA和QB的TTL分别设置为10秒和40秒，而QC不设置TTL、用于存放自定义TTL的消息。当消息变为死信后，转发到死信队列QD进行统一处理。</p>
<h3 id="22-配置类-2">2.2 配置类</h3>
<pre><code class="language-java">@Configuration
public class RabbitConfig {
    public static final String NORMAL_EXCHANGE = &quot;X&quot;; // 普通交换机
    public static final String DEAD_EXCHANGE = &quot;Y&quot;; // 死信交换机
    public static final String NORMAL_QUEUE_A = &quot;QA&quot;; // 普通队列A
    public static final String NORMAL_QUEUE_B = &quot;QB&quot;; // 普通队列B
    public static final String NORMAL_QUEUE_C = &quot;QC&quot;; // 普通队列C
    public static final String DEAD_QUEUE_D = &quot;QD&quot;; // 死信队列D

    @Bean // 声明普通交换机
    public DirectExchange normalExchange() {
        return ExchangeBuilder.directExchange(NORMAL_EXCHANGE).build();
    }

    @Bean // 声明死信交换机
    public DirectExchange deadExchange() {
        return ExchangeBuilder.directExchange(DEAD_EXCHANGE).build();
    }

    @Bean // 声明普通队列A
    public Queue normalQueueA() {
        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();
        // 1. 设置对应的死信交换机
        arguments.put(&quot;x-dead-letter-exchange&quot;, DEAD_EXCHANGE);
        // 2. 设置死信的routingKey
        arguments.put(&quot;x-dead-letter-routing-key&quot;, &quot;YD&quot;);
        // 3. 设置TTL
        arguments.put(&quot;x-message-ttl&quot;, 10 * 1000);
        return QueueBuilder.durable(NORMAL_QUEUE_A).withArguments(arguments).build();
    }

    @Bean // 声明普通队列B
    public Queue normalQueueB() {
        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();
        arguments.put(&quot;x-dead-letter-exchange&quot;, DEAD_EXCHANGE);
        arguments.put(&quot;x-dead-letter-routing-key&quot;, &quot;YD&quot;);
        arguments.put(&quot;x-message-ttl&quot;, 40 * 1000);
        return QueueBuilder.durable(NORMAL_QUEUE_B).withArguments(arguments).build();
    }

    @Bean // 声明普通队列C
    public Queue normalQueueC() {
        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();
        arguments.put(&quot;x-dead-letter-exchange&quot;, DEAD_EXCHANGE);
        arguments.put(&quot;x-dead-letter-routing-key&quot;, &quot;YD&quot;);
        return QueueBuilder.durable(NORMAL_QUEUE_C).withArguments(arguments).build();
    }

    @Bean // 声明死信队列D
    public Queue deadQueueD() {
        return QueueBuilder.durable(DEAD_QUEUE_D).build();
    }

    @Bean // 绑定X和QA
    public Binding bindingXA(Queue normalQueueA, DirectExchange normalExchange) {
        return BindingBuilder.bind(normalQueueA).to(normalExchange)
                .with(&quot;XA&quot;);
    }

    @Bean // 绑定X和QB
    public Binding bindingXB(Queue normalQueueB, DirectExchange normalExchange) {
        return BindingBuilder.bind(normalQueueB).to(normalExchange)
                .with(&quot;XB&quot;);
    }

    @Bean // 绑定X和QC
    public Binding bindingXC(Queue normalQueueC, DirectExchange normalExchange) {
        return BindingBuilder.bind(normalQueueC).to(normalExchange)
                .with(&quot;XC&quot;);
    }

    @Bean // 绑定Y和QD
    public Binding bindingYD(Queue deadQueueD, DirectExchange deadExchange) {
        return BindingBuilder.bind(deadQueueD).to(deadExchange)
                .with(&quot;YD&quot;);
    }
}
</code></pre>
<h3 id="23-生产者">2.3 生产者</h3>
<pre><code class="language-java">@Slf4j
@RestController
@RequestMapping(&quot;/ttl&quot;)
public class SendMsgController {
    @Autowired
    private RabbitTemplate rabbitTemplate;

    // 不带TTL的消息，发送到设置了TTL的队列中
    @GetMapping(&quot;/sendMsg/{message}&quot;)
    public void sendMsg(@PathVariable(&quot;message&quot;) String message) {
        log.info(&quot;当前时间：{}, 发送消息：{}&quot;, new Date(), message);
        // 发消息
        rabbitTemplate.convertAndSend(&quot;X&quot;, &quot;XA&quot;,
                &quot;TTL:10s, Message:&quot; + message);
        rabbitTemplate.convertAndSend(&quot;X&quot;, &quot;XB&quot;,
                &quot;TTL:40s, Message:&quot; + message);
    }

    // 带有TTL的消息，发送到QC队列中
    @GetMapping(&quot;/sendMsgTTL/{message}/{ttl}&quot;)
    public void sendMsgTTL(@PathVariable(&quot;message&quot;) String message,
                           @PathVariable(&quot;ttl&quot;) String ttl) {
        log.info(&quot;当前时间：{}, 发送消息：{}, TTL：{}ms&quot;, new Date(), message, ttl);
        
        String str = &quot;TTL:&quot; + ttl + &quot;ms, Message:&quot; + message;
        MessageProperties properties = new MessageProperties();
        properties.setExpiration(ttl); // 设置消息的TTL
        Message msg = MessageBuilder.withBody(str.getBytes())
                .andProperties(properties).build();

        rabbitTemplate.convertAndSend(&quot;X&quot;, &quot;XC&quot;, msg);
    }
}
</code></pre>
<h3 id="24-消费者">2.4 消费者</h3>
<pre><code class="language-java">@Slf4j
@Component
public class Consumer {
    @RabbitListener(queues = &quot;QD&quot;)
    public void receiveQD(Message message) {
        String msg = new String(message.getBody());
        log.info(&quot;当前时间：{}, 收到消息：{}&quot;, new Date(), msg);
    }
}
</code></pre>
<h3 id="25-测试">2.5 测试</h3>
<p><strong>（1）测试QA和QB</strong></p>
<p><code>http://localhost:8080/ttl/sendMsg/wsy666</code>发送消息，控制台打印如下</p>
<pre><code>... 当前时间：Wed Oct 04 17:41:16 CST 2023, 发送消息：wsy666
... 当前时间：Wed Oct 04 17:41:27 CST 2023, 收到消息：TTL:10s, Message:wsy666
... 当前时间：Wed Oct 04 17:41:57 CST 2023, 收到消息：TTL:40s, Message:wsy666
</code></pre>
<p>结果符合预期！第一条消息在 10s 后变成了死信，然后被消费掉，第二条消息在 40s 之后变成了死信，然后被消费掉。</p>
<p><strong>（2）测试QC</strong></p>
<p><code>http://localhost:8080/ttl/sendMsgTTL/wsy777/20000</code></p>
<p><code>http://localhost:8080/ttl/sendMsgTTL/wsy888/2000</code></p>
<p>发送两条消息，控制台打印如下</p>
<pre><code>... 当前时间：Wed Oct 04 17:47:18 CST 2023, 发送消息：wsy777, TTL：20000ms
... 当前时间：Wed Oct 04 17:47:26 CST 2023, 发送消息：wsy888, TTL：2000ms
... 当前时间：Wed Oct 04 17:47:38 CST 2023, 收到消息：TTL:20000ms, Message:wsy777
... 当前时间：Wed Oct 04 17:47:38 CST 2023, 收到消息：TTL:2000ms, Message:wsy888
</code></pre>
<p>我们注意到，第二条消息TTL为2秒，却没有按时变成死信。这是<strong>因为RabbitMQ只会检查队首消息是否过期</strong>，如果过期则变为死信丢弃，然后检查新的队首消息。因此，如果第一个消息的TTL很长，而第二个消息的TTL很短，如上所示，第二个消息并不会优先被丢弃，而是等到第一个消息被丢弃后，才会立即丢弃。</p>
<p>这就是基于死信实现的延迟队列的缺点（当然，如果是基于队列的TTL，而不是基于消息的TTL，就不会有这一问题），以下我们也可以使用延迟队列插件来解决这一问题！</p>
<h2 id="3-基于插件实现延迟队列">3. 基于插件实现延迟队列</h2>
<h3 id="31-rabbitmq延迟队列插件的安装">3.1 RabbitMQ延迟队列插件的安装</h3>
<p>基于死信实现的延迟队列，本质上就是在一个队列中根据其中消息的TTL，来实现延迟。而基于插件实现的延迟队列，直接在交换机处就实现延迟，然后再发送给队列，让消费者进行消费即可，流程上简单得多。</p>
<p>我们用Docker方式安装RabbitMQ延迟队列插件：</p>
<p><strong>（1）下载插件</strong></p>
<ul>
<li>登录官网 https://www.rabbitmq.com/community-plugins.html</li>
<li>下载插件rabbitmq_delayed_message_exchange-3.9.0.ez</li>
<li>然后上传到服务器的/opt目录下</li>
</ul>
<p><strong>（2）将插件上传到Docker容器实例内部</strong></p>
<p>首先<code>docker ps</code>查看运行中的rabbitmq实例的容器id，然后执行以下命令将插件拷贝到容器内的/plugins目录下：</p>
<pre><code class="language-shell">docker cp /opt/rabbitmq_delayed_message_exchange-3.9.0.ez 5b9a3d9726ef:/plugins
</code></pre>
<p><strong>（3）启用插件</strong></p>
<p>进入rabbitmq实例容器内部的/plugins目录下，启用插件：</p>
<pre><code class="language-shell">docker exec -it 5b9a3d9726ef /bin/bash
cd /plugins
rabbitmq-plugins enable rabbitmq_delayed_message_exchange
</code></pre>
<p>此时插件已启用，退出容器并重启容器实例即可：</p>
<pre><code class="language-shell">exit
docker restart 5b9a3d9726ef
</code></pre>
<p><strong>（4）Web端管理界面查看</strong></p>
<p>登录RabbitMQ的Web端管理界面，在Exchanges中Add a new exchange，发现Type里多了一个类型x-delayed-message，说明插件启用成功。</p>
<h3 id="32-代码架构图">3.2 代码架构图</h3>
<figure data-type="image" tabindex="5"><img src="images/20231004190410.png" alt="" loading="lazy"></figure>
<h3 id="33-配置类">3.3 配置类</h3>
<p>在我们自定义的交换机中，这是一种新的交换机类型，它支持延迟投递机制：消息不会立即投递到目标队列中，而是存储在mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中。</p>
<pre><code class="language-java">@Configuration
public class RabbitConfig {
    public static final String DELAYED_EXCHANGE = &quot;delayed.exchange&quot;; // 延迟交换机
    public static final String DELAYED_QUEUE = &quot;delayed.queue&quot;; // 队列
    public static final String DELAYED_ROUTINGKEY = &quot;delayed.routingkey&quot;; // 路由key

    @Bean // 声明延迟交换机
    public CustomExchange delayedExchange() {
        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();
        arguments.put(&quot;x-delayed-type&quot;, &quot;direct&quot;);
        /**
         * 1. 交换机的名称
         * 2. 交换机的类型
         * 3. 该交换机是否需要持久化
         * 4. 该交换机是否需要自动删除
         * 5. 其他参数
         */
        return new CustomExchange(DELAYED_EXCHANGE, &quot;x-delayed-message&quot;,
                true, false, arguments);
    }

    @Bean // 声明队列
    public Queue delayedQueue() {
        return new Queue(DELAYED_QUEUE);
    }

    @Bean // 绑定
    public Binding bindingDelayed(Queue delayedQueue, CustomExchange delayedExchange) {
        return BindingBuilder.bind(delayedQueue).to(delayedExchange)
                .with(DELAYED_ROUTINGKEY).noargs();
    }
}
</code></pre>
<h3 id="34-生产者">3.4 生产者</h3>
<p><strong>注意：要给消息属性中设置延迟时间属性，而不是设置TTL</strong></p>
<pre><code class="language-java">@Slf4j
@RestController
public class SendMsgController {
    @Autowired
    private RabbitTemplate rabbitTemplate;

    // 发送带有延迟时间的消息
    @GetMapping(&quot;/sendDelayMsg/{message}/{delayTime}&quot;)
    public void sendDelayMsg(@PathVariable(&quot;message&quot;) String message,
                             @PathVariable(&quot;delayTime&quot;) Integer delayTime) {
        log.info(&quot;当前时间：{}, 发送消息：{}, 延迟时间：{}ms&quot;, new Date(), message, delayTime);
        
        String str = &quot;延迟时间:&quot; + delayTime + &quot;ms, Message:&quot; + message;
        MessageProperties properties = new MessageProperties();
        properties.setDelay(delayTime); // 设置消息的延迟时间，单位ms
        Message msg = MessageBuilder.withBody(str.getBytes())
                .andProperties(properties).build();
        
        rabbitTemplate.convertAndSend(RabbitConfig.DELAYED_EXCHANGE,
                RabbitConfig.DELAYED_ROUTINGKEY, msg);
    }
}
</code></pre>
<h3 id="35-消费者">3.5 消费者</h3>
<pre><code class="language-java">@Slf4j
@Component
public class Consumer {
    @RabbitListener(queues = RabbitConfig.DELAYED_QUEUE)
    public void receiveDelayMessage(Message message) {
        String msg = new String(message.getBody());
        log.info(&quot;当前时间：{}, 收到消息：{}&quot;, new Date(), msg);
    }
}
</code></pre>
<h3 id="36-测试">3.6 测试</h3>
<p><code>http://localhost:8080/sendDelayMsg/wsy111/20000</code></p>
<p><code>http://localhost:8080/sendDelayMsg/wsy222/2000</code></p>
<p>发送两条消息，控制台打印如下</p>
<pre><code>... 当前时间：Wed Oct 04 19:07:31 CST 2023, 发送消息：wsy111, 延迟时间：20000ms
... 当前时间：Wed Oct 04 19:07:42 CST 2023, 发送消息：wsy222, 延迟时间：2000ms
... 当前时间：Wed Oct 04 19:07:44 CST 2023, 收到消息：延迟时间:2000ms, Message:wsy222
... 当前时间：Wed Oct 04 19:07:51 CST 2023, 收到消息：延迟时间:20000ms, Message:wsy111
</code></pre>
<p>第二个消息被先消费掉了，符合预期！</p>
<h1 id="第07章_其他知识">第07章_其他知识</h1>
<h2 id="1-分发消息">1. 分发消息</h2>
<h3 id="11-轮询分发消息">1.1 轮询分发消息</h3>
<p>默认情况下，RabbitMQ采用<strong>轮询分发消息</strong>，即如果有多个消费者订阅（连接）同一个队列，则该队列中的消息会轮流分发给每个消费者，而并不是广播地分发给每个消费者。</p>
<blockquote>
<p>说明：RabbitMQ支持交换机层面的广播，但不支持队列层面的广播，也就是一个队列中的消息无法广播分发给所有订阅它的消费者。</p>
</blockquote>
<p>测试如下：</p>
<h4 id="1-配置类-8">1、配置类</h4>
<pre><code class="language-java">@Configuration
public class RabbitConfig {
    @Bean
    public DirectExchange exchange() {
        return ExchangeBuilder.directExchange(&quot;exchange.each&quot;).build();
    }
    @Bean
    public Queue queue() {
        return QueueBuilder.durable(&quot;queue.each&quot;).build();
    }
    @Bean
    public Binding binding(Queue queue, DirectExchange exchange) {
        return BindingBuilder.bind(queue).to(exchange).with(&quot;each&quot;);
    }
}
</code></pre>
<h4 id="2-生产者-4">2、生产者</h4>
<pre><code class="language-java">@RestController
public class Producer {
    @Autowired
    private RabbitTemplate template;
    
    @GetMapping(&quot;/send&quot;)
    public void send() {
        for (int i = 0; i &lt; 10; i++) {
            String str = &quot;消息&quot; + i;
            template.convertAndSend(&quot;exchange.each&quot;, &quot;each&quot;, str);
        }
    }
}
</code></pre>
<h4 id="3-消费者">3、消费者</h4>
<pre><code class="language-java">@Component
public class Consumer { // 三个消费者监听同一队列
    @RabbitListener(queues = &quot;queue.each&quot;)
    public void consumer1(Message message) {
        String msg = new String(message.getBody());
        System.out.println(&quot;消费者1收到&quot; + msg);
    }
    @RabbitListener(queues = &quot;queue.each&quot;)
    public void consumer2(Message message) {
        String msg = new String(message.getBody());
        System.out.println(&quot;消费者2收到&quot; + msg);
    }
    @RabbitListener(queues = &quot;queue.each&quot;)
    public void consumer3(Message message) {
        String msg = new String(message.getBody());
        System.out.println(&quot;消费者3收到&quot; + msg);
    }
}
</code></pre>
<h4 id="4-测试">4、测试</h4>
<p>访问<code>http://localhost:8080/send</code>，控制台打印如下</p>
<pre><code>消费者3收到消息0
消费者2收到消息1
消费者1收到消息2
消费者3收到消息3
消费者2收到消息4
消费者1收到消息5
消费者3收到消息6
消费者2收到消息7
消费者1收到消息8
消费者3收到消息9
</code></pre>
<h3 id="12-不公平分发消息">1.2 不公平分发消息</h3>
<p>如果多个消费者处理任务的速度差别很大，采用轮询分发消息的方式并不合适，因为会让消费速度快的消费者大部分时间处于空闲状态。为了解决这一问题，可以采用不公平的方式来分发消息，只需在配置文件中设置<strong>预取值</strong>即可：</p>
<pre><code class="language-properties"># 要设置预取值，必须采用消息手动确认模式
spring.rabbitmq.listener.simple.acknowledge-mode=manual
# 设置预取值
spring.rabbitmq.listener.simple.prefetch=1
</code></pre>
<p>prefetch称为预取值，指的就是该信道上未确认消息的最大数量。如上将预取值设置为1，那么效率慢的消费者收到一个消息后，就会迟迟未确认导致该信道缓冲区已占满；而效率快的消费者，就能被分发更多的消息。</p>
<p>我们可以根据消费者服务器的性能，来设置不同的预取值，例如一个消费者设置为2，另一个消费者设置为5。这就表示前者的信道上的未确认消息缓冲区大小为2，后者大小为5。<strong>采用这种方式，消费者的消费模式就是pull模式，这样就可以实现消费者端限流，达到流量削峰的效果</strong>。</p>
<blockquote>
<p>预取值为1是最保守的，当然这将使吞吐量变得很低，特别是在消费者连接等待时间较长的环境中。对于大多数应用来说，稍微高一点的值将是最佳的。</p>
</blockquote>
<h2 id="2-幂等性">2. 幂等性</h2>
<p><strong>幂等性</strong>指的是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。例如网络卡顿，用户对同一笔订单支付了两次，造成了重复扣款，这就说明这个订单支付模块是不具备幂等性的。</p>
<p>而在MQ中，消费者的业务消费接口通常都需要保证<strong>幂等性</strong>，因为MQ可能会存在消息重复的问题。例如消费者在消费完消息后，却在手动返回ACK时宕机，于是这条消息就没有从队列中删除，这样消费者在重启后就会再次消费这条消息。</p>
<h2 id="3-优先级队列">3. 优先级队列</h2>
<h3 id="31-使用场景">3.1 使用场景</h3>
<p>在订单催付中，我们可以采用 RabbitMQ 的优先级队列，如果发现是大客户的订单催付就给一个相对比较高的优先级，否则就是默认优先级。</p>
<h3 id="32-使用方式">3.2 使用方式</h3>
<p>要让队列实现优先级，首先要<strong>将队列设置为优先级队列</strong>，其次消息也需要<strong>设置消息的优先级</strong>。除此之外，只有批量发送消息积压到队列之后，消费者再去消费才会有优先级的效果；如果不批量发消息，那么发一个消息、消费者就消费一个消息，就体现不出优先级。</p>
<blockquote>
<p>注意：优先级范围0-255，数值越大，优先级越高</p>
</blockquote>
<p><strong>定义优先级队列</strong>：</p>
<pre><code class="language-java">@Bean // 定义优先级队列
public Queue priorityQueue() {
    // 使用maxPriority()方法给队列设置最大优先级，范围是0-255
    return QueueBuilder.durable(&quot;queueName&quot;)
            .maxPriority(10) // 表示队列中允许的消息优先级范围是0-10
            .build();
}
</code></pre>
<p><strong>给消息设置优先级</strong>：</p>
<pre><code class="language-java">MessageProperties properties = new MessageProperties();
properties.setPriority(8); // 设置消息的优先级为8
Message message = MessageBuilder.withBody(&quot;hello&quot;.getBytes())
        .andProperties(properties).build();
</code></pre>
<h3 id="33-案例演示">3.3 案例演示</h3>
<p>需求：批量发送10条消息，让第5条消息被优先消费。</p>
<h4 id="1-配置类-9">1、配置类</h4>
<pre><code class="language-java">@Configuration
public class RabbitConfig {
    public static final String EXCHANGE_NAME = &quot;priority.exchange&quot;;
    public static final String QUEUE_NAME = &quot;priority.queue&quot;;
    public static final String ROUTING_KEY = &quot;priority&quot;;

    @Bean // 定义交换机
    public DirectExchange priorityExchange() {
        return ExchangeBuilder.directExchange(EXCHANGE_NAME).build();
    }

    @Bean // 定义优先级队列
    public Queue priorityQueue() {
        // 使用maxPriority()方法给队列设置最大优先级，范围是0-255
        return QueueBuilder.durable(QUEUE_NAME)
                .maxPriority(10) // 表示队列中允许的消息优先级范围是0-10
                .build();
    }

    @Bean // 绑定
    public Binding binding(Queue priorityQueue, DirectExchange priorityExchange) {
        return BindingBuilder.bind(priorityQueue).to(priorityExchange)
                .with(ROUTING_KEY);
    }
}
</code></pre>
<h4 id="2-生产者-5">2、生产者</h4>
<pre><code class="language-java">@Slf4j
@RestController
public class SendMsgController {
    @Autowired
    private RabbitTemplate rabbitTemplate;

    @GetMapping(&quot;/sendPriorityMessage&quot;)
    public void sendPriorityMessage(){
        for (int i = 0; i &lt; 10;i++){
            String str = &quot;info&quot; + i;
            // 给第5条消息优先级设置为10(高优先级)
            if (i == 5){
                MessageProperties properties = new MessageProperties();
                properties.setPriority(10);
                Message message = MessageBuilder.withBody(str.getBytes())
                        .andProperties(properties).build();
                rabbitTemplate.convertAndSend(RabbitConfig.EXCHANGE_NAME,
                        RabbitConfig.ROUTING_KEY, message);
            } else {
                rabbitTemplate.convertAndSend(RabbitConfig.EXCHANGE_NAME,
                        RabbitConfig.ROUTING_KEY, str);
            }
        }
        log.info(&quot;消息发送成功&quot;);
    }
}
</code></pre>
<h4 id="3-消费者-2">3、消费者</h4>
<p>注意，消费者建议写在另一个微服务项目中，这样先启动优先级队列的项目发送消息，消息会被积压在优先级队列中，然后再启动消费者项目，就可以查看到正确的效果，即info5首先被消费。</p>
<pre><code class="language-java">@Slf4j
@Component
public class Consumer {
    @RabbitListener(queues = &quot;priority.queue&quot;)
    public void receiveMessage(Message message) {
        String msg = new String(message.getBody());
        log.info(&quot;接收消息：{}&quot;, msg);
    }
}
</code></pre>
<h2 id="4-惰性队列">4. 惰性队列</h2>
<h3 id="41-队列的两种模式">4.1 队列的两种模式</h3>
<p>队列具备两种模式：default和lazy。</p>
<p>在默认模式default下，当生产者将消息发送到 RabbitMQ 的时候，队列中的消息会<strong>尽可能地存储在内存之中</strong>，这样可以更加快速地将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份。当 RabbitMQ 需要释放内存的时候，才会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。</p>
<p>而lazy模式就表示惰性队列，它<strong>会尽可能地将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中</strong>，它的一个重要的设计目标是能够支持更多的消息存储。当消费者由于各种各样的原因(比如消费者宕机)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。</p>
<h3 id="42-设置惰性队列的方式">4.2 设置惰性队列的方式</h3>
<pre><code class="language-java">@Bean // 定义惰性队列
public Queue lazyQueue() {
    return QueueBuilder.durable(&quot;queueName&quot;)
            .lazy().build();
}
</code></pre>
<blockquote>
<p>注：内存开销对比大致如下，在发送一百万条1KB消息的情况下，default队列占用内存约1.2GB，而惰性队列仅占用内存约1.5MB。</p>
</blockquote>
<h2 id="5-rabbitmq集群">5. RabbitMQ集群</h2>
<p>RabbitMQ集群有两种模式：普通集群模式、镜像集群模式。</p>
<h3 id="51-普通集群模式">5.1 普通集群模式</h3>
<p>普通集群模式，也是默认的集群模式，它只会把交换机、队列、虚拟主机等<strong>元数据信息</strong>在各个节点同步，而具体队列中的消息内容不会在各个节点中同步、只会存储在一个节点中。</p>
<p>当消费者消费消息时，如果连接的节点并不存储queue中的消息内容，那么这个节点会根据queue的元数据信息，找到真正存储消息内容的queue所在的节点，然后将消息数据拉取过来并交给消费者消费。</p>
<p>因此，普通集群模式主要是<strong>提高吞吐量</strong>的，也就是让集群中多个节点来服务某个queue的读写操作。而普通集群模式<strong>无法保证高可用性</strong>，一旦真正存储消息内容的节点宕机了，就无法继续提供服务。</p>
<h3 id="52-镜像集群模式">5.2 镜像集群模式</h3>
<p>镜像集群模式，才是RabbitMQ的<strong>高可用模式</strong>，它会把所有数据完全同步，包括元数据信息和消息数据信息，所以每一个RabbitMQ节点都是一个完整镜像。</p>
<p>我们在创建队列时，只需在管理控制台指定一个策略，就能让该队列成为<strong>镜像队列</strong>。每当我们写消息到这个queue时，它就会自动把消息同步到所有其他节点中（同步的过程中会阻塞，无法对外提供服务，直到同步完毕）。所以，即使一个节点宕机了，也能切换到另一个节点去消费数据，保证了服务的高可用性。</p>
<p>这种模式虽然保证了高可用性，但是占用了更多的空间，而且降低了性能，消息同步到所有节点上会导致很高的网络带宽压力。</p>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://yuzhupeng.top/myblogs/post/saas-duo-zu-hu-shu-ju-quan-xian-she-ji/">
                  <h3 class="post-title">
                    Saas多租户数据权限设计
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
