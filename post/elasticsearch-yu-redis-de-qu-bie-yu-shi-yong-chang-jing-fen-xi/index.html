<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Elasticsearch 与 Redis 的区别与使用场景分析 | fishyue</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://yuzhupeng.top/myblogs//favicon.ico?v=1755503043926">
<link rel="stylesheet" href="https://yuzhupeng.top/myblogs//styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="以下是关于 Elasticsearch 与 Redis 的区别及其使用场景 的 Markdown 结构化输出文章，适合用于文档、博客或技术分享：

Elasticsearch 与 Redis 的区别与使用场景分析
一、概述
Elastics..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://yuzhupeng.top/myblogs/">
        <img src="https://yuzhupeng.top/myblogs//images/avatar.png?v=1755503043926" class="site-logo">
        <h1 class="site-title">fishyue</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/myblogs" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/myblogs/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/myblogs/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/myblogs/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/yuzhupeng" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      由奢入俭难，由俭入奢易
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/yuzhupeng" target="_blank">Fishyue</a> | <a class="rss" href="https://yuzhupeng.top/myblogs//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Elasticsearch 与 Redis 的区别与使用场景分析</h2>
            <div class="post-date">2025-06-25</div>
            
            <div class="post-content" v-pre>
              <p>以下是关于 <strong>Elasticsearch 与 Redis 的区别及其使用场景</strong> 的 Markdown 结构化输出文章，适合用于文档、博客或技术分享：</p>
<hr>
<h1 id="elasticsearch-与-redis-的区别与使用场景分析">Elasticsearch 与 Redis 的区别与使用场景分析</h1>
<h2 id="一-概述">一、概述</h2>
<p>Elasticsearch（简称 ES）和 Redis 是两种广泛应用的数据存储与处理系统，但它们在设计目标、数据结构、查询能力和典型使用场景等方面存在显著差异。</p>
<hr>
<h2 id="二-核心区别对比">二、核心区别对比</h2>
<table>
<thead>
<tr>
<th>对比项</th>
<th>Elasticsearch</th>
<th>Redis</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>核心定位</strong></td>
<td>搜索引擎 / 分布式文档数据库</td>
<td>内存数据库 / 缓存与实时处理系统</td>
</tr>
<tr>
<td><strong>数据存储结构</strong></td>
<td>倒排索引 + JSON 文档</td>
<td>键值对（Key-Value）+ 多种内存数据结构</td>
</tr>
<tr>
<td><strong>数据持久化</strong></td>
<td>支持持久化和副本</td>
<td>支持持久化（RDB / AOF）</td>
</tr>
<tr>
<td><strong>查询能力</strong></td>
<td>强大的全文检索、聚合分析</td>
<td>基础键查询 + 数据结构操作</td>
</tr>
<tr>
<td><strong>访问速度</strong></td>
<td>毫秒级，适合分析</td>
<td>微秒级，适合实时响应</td>
</tr>
<tr>
<td><strong>扩展能力</strong></td>
<td>原生分布式架构，自动分片</td>
<td>支持集群，但复杂度更高</td>
</tr>
<tr>
<td><strong>应用领域</strong></td>
<td>搜索、日志、数据分析</td>
<td>缓存、消息队列、实时统计</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="三-elasticsearch-的典型使用场景">三、Elasticsearch 的典型使用场景</h2>
<h3 id="1-全文搜索引擎">1. 全文搜索引擎</h3>
<ul>
<li><strong>说明</strong>：ES 构建于倒排索引之上，支持分词、模糊查询等功能。</li>
<li><strong>应用示例</strong>：电商平台商品搜索、知识库文档检索。</li>
</ul>
<h3 id="2-日志收集与分析elk-stack">2. 日志收集与分析（ELK Stack）</h3>
<ul>
<li><strong>说明</strong>：与 Logstash、Kibana 组合，构建实时日志监控平台。</li>
<li><strong>应用示例</strong>：系统日志分析、异常检测、运维监控。</li>
</ul>
<h3 id="3-实时数据聚合与-bi-可视化">3. 实时数据聚合与 BI 可视化</h3>
<ul>
<li><strong>说明</strong>：ES 聚合能力强，适合高维度多字段的快速汇总。</li>
<li><strong>应用示例</strong>：用户行为分析、销售报表分析。</li>
</ul>
<h3 id="4-安全事件监控siem">4. 安全事件监控（SIEM）</h3>
<ul>
<li><strong>说明</strong>：存储和分析安全日志、审计日志。</li>
<li><strong>应用示例</strong>：入侵检测系统、网络访问行为分析。</li>
</ul>
<h3 id="5-推荐系统">5. 推荐系统</h3>
<ul>
<li><strong>说明</strong>：通过字段查询、聚合支持实时推荐。</li>
<li><strong>应用示例</strong>：相关推荐、个性化内容推送。</li>
</ul>
<hr>
<h2 id="四-redis-的典型使用场景">四、Redis 的典型使用场景</h2>
<h3 id="1-高性能缓存">1. 高性能缓存</h3>
<ul>
<li><strong>说明</strong>：内存读取快，适合存放热点数据。</li>
<li><strong>应用示例</strong>：页面缓存、数据库查询缓存、用户信息缓存。</li>
</ul>
<h3 id="2-消息队列与发布订阅">2. 消息队列与发布订阅</h3>
<ul>
<li><strong>说明</strong>：支持 List（列表）、Pub/Sub 模型。</li>
<li><strong>应用示例</strong>：任务异步处理、通知推送系统。</li>
</ul>
<h3 id="3-会话管理">3. 会话管理</h3>
<ul>
<li><strong>说明</strong>：用于存储短期状态数据。</li>
<li><strong>应用示例</strong>：登录状态、购物车信息、用户设置。</li>
</ul>
<h3 id="4-实时排行榜与计数器">4. 实时排行榜与计数器</h3>
<ul>
<li><strong>说明</strong>：Sorted Set 数据结构支持排序与权重。</li>
<li><strong>应用示例</strong>：游戏排名、浏览量统计、打分系统。</li>
</ul>
<h3 id="5-分布式锁与协调机制">5. 分布式锁与协调机制</h3>
<ul>
<li><strong>说明</strong>：利用 SETNX、Lua 脚本等实现高性能分布式锁。</li>
<li><strong>应用示例</strong>：库存控制、幂等控制、任务排他执行。</li>
</ul>
<hr>
<h2 id="五-总结">五、总结</h2>
<table>
<thead>
<tr>
<th>应用需求</th>
<th>推荐方案</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>需要强搜索与复杂查询</strong></td>
<td>✅ Elasticsearch</td>
</tr>
<tr>
<td><strong>需要实时缓存与快速访问</strong></td>
<td>✅ Redis</td>
</tr>
<tr>
<td><strong>日志集中管理与可视化分析</strong></td>
<td>✅ Elasticsearch（配合 ELK）</td>
</tr>
<tr>
<td><strong>高并发下的临时数据缓存</strong></td>
<td>✅ Redis</td>
</tr>
<tr>
<td><strong>构建搜索+缓存系统</strong></td>
<td>✅ Elasticsearch + Redis 组合</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="六-参考建议">六、参考建议</h2>
<ul>
<li>二者<strong>不是互斥关系</strong>，在实际项目中常常 <strong>组合使用</strong>，例如：
<ul>
<li>搜索结果由 Elasticsearch 提供；</li>
<li>搜索历史、热门关键词由 Redis 缓存；</li>
<li>用户行为数据进入 Redis 队列再异步写入 ES。</li>
</ul>
</li>
</ul>
<hr>
<p>Elasticsearch（简称 ES）虽然通常被称为搜索引擎，但它本质上是一个<strong>分布式文档数据库</strong>，其<strong>存储性能</strong>之强、<strong>数据结构设计</strong>之复杂，远非传统 RDBMS 所能比拟。下面将从底层结构、存储方式、索引机制等方面详细讲解。</p>
<hr>
<h1 id="elasticsearch-存储性能与数据结构详解">Elasticsearch 存储性能与数据结构详解</h1>
<hr>
<h2 id="一-elasticsearch-的数据基本单位">一、Elasticsearch 的数据基本单位</h2>
<h3 id="1-document文档">1. <strong>Document（文档）</strong></h3>
<ul>
<li>ES 存储的最小单元，实质是一个 <strong>JSON 格式对象</strong>。</li>
<li>类似于关系型数据库中的一行数据（Row）。</li>
<li>示例：</li>
</ul>
<pre><code class="language-json">{
  &quot;user&quot;: &quot;alice&quot;,
  &quot;message&quot;: &quot;Elasticsearch is fast!&quot;,
  &quot;timestamp&quot;: &quot;2025-06-25T09:00:00&quot;
}
</code></pre>
<h3 id="2-index索引">2. <strong>Index（索引）</strong></h3>
<ul>
<li>存放文档的逻辑空间，类似于数据库中的“表”。</li>
<li>一个索引下包含多个文档，具有相同或类似的字段结构。</li>
</ul>
<h3 id="3-shard分片与-replica副本">3. <strong>Shard（分片）与 Replica（副本）</strong></h3>
<ul>
<li>为了提高性能和容错能力，ES 自动将索引划分为若干个 <strong>主分片（Primary Shards）</strong>，每个主分片可以配置多个 <strong>副本分片（Replica Shards）</strong>。</li>
<li>分片是最小的物理存储单位。</li>
</ul>
<hr>
<h2 id="二-底层存储架构lucene">二、底层存储架构（Lucene）</h2>
<p>Elasticsearch 构建在 <strong>Apache Lucene</strong> 之上，Lucene 是一个高效的全文搜索库。其底层结构如下：</p>
<h3 id="1-segment段">1. <strong>Segment（段）</strong></h3>
<ul>
<li>Lucene 将所有文档分批处理并写入称为 <strong>Segment</strong> 的小文件集合中。</li>
<li>每个 Segment 是只读的，多个 Segment 最终会进行合并（Merge）。</li>
<li>文档删除或更新并非真正删除，而是“打上删除标记”（标记为 deleted）。</li>
</ul>
<h3 id="2-inverted-index倒排索引">2. <strong>Inverted Index（倒排索引）</strong></h3>
<ul>
<li>核心数据结构，用于实现全文搜索。</li>
<li>举例说明：
<ul>
<li>三个文档：
<ul>
<li>D1: &quot;Elasticsearch is fast&quot;</li>
<li>D2: &quot;Search is powerful&quot;</li>
<li>D3: &quot;Fast and scalable search&quot;</li>
</ul>
</li>
<li>倒排索引结果如下：</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>Term</th>
<th>Document IDs</th>
</tr>
</thead>
<tbody>
<tr>
<td>elasticsearch</td>
<td>D1</td>
</tr>
<tr>
<td>fast</td>
<td>D1, D3</td>
</tr>
<tr>
<td>search</td>
<td>D2, D3</td>
</tr>
<tr>
<td>powerful</td>
<td>D2</td>
</tr>
</tbody>
</table>
<ul>
<li>ES 查询时首先查找关键词对应的文档 ID，再提取匹配的文档。</li>
</ul>
<h3 id="3-columnar-storage-for-aggregation列式存储">3. <strong>Columnar Storage for Aggregation（列式存储）</strong></h3>
<ul>
<li>ES 为聚合操作（如 avg, sum, terms）提供了类似列式存储的 <strong>Doc Values</strong>。</li>
<li><strong>Doc Values</strong> 是一种反向存储方式，将字段值单独存储，便于快速聚合。</li>
</ul>
<hr>
<h2 id="三-elasticsearch-的数据结构构成">三、Elasticsearch 的数据结构构成</h2>
<table>
<thead>
<tr>
<th>结构层级</th>
<th>含义</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cluster</td>
<td>集群</td>
<td>包含多个节点（Node）</td>
</tr>
<tr>
<td>Node</td>
<td>节点</td>
<td>ES 实例，可存多个分片</td>
</tr>
<tr>
<td>Index</td>
<td>索引</td>
<td>类似于数据库中的表</td>
</tr>
<tr>
<td>Type（已废弃）</td>
<td>文档类型</td>
<td>7.0 之后弃用</td>
</tr>
<tr>
<td>Document</td>
<td>文档</td>
<td>JSON 格式结构化数据</td>
</tr>
<tr>
<td>Field</td>
<td>字段</td>
<td>文档中的键值对</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="四-存储性能优化机制">四、存储性能优化机制</h2>
<h3 id="1-倒排索引优化">1. <strong>倒排索引优化</strong></h3>
<ul>
<li>使用 <strong>分词器（Analyzer）</strong> 提取关键词（Token），构建高效的倒排索引。</li>
<li>支持自定义分词策略（如 IK 中文分词器、edge_ngram 前缀索引等）。</li>
</ul>
<h3 id="2-列式-doc-values">2. <strong>列式 Doc Values</strong></h3>
<ul>
<li>聚合查询、排序、脚本访问等场景中，ES 使用 Doc Values 快速读取字段值，而不遍历倒排索引。</li>
<li>适用于非文本字段（如数字、日期、keyword）。</li>
</ul>
<h3 id="3-segment-merge-策略">3. <strong>Segment Merge 策略</strong></h3>
<ul>
<li>后台合并多个小 Segment 为大 Segment，降低文件句柄消耗、提升检索性能。</li>
<li>采用 <strong>Lucene Tiered Merge Policy</strong>（分层合并策略）。</li>
</ul>
<h3 id="4-压缩与编码">4. <strong>压缩与编码</strong></h3>
<ul>
<li>文本字段：使用 LZ4 或 ZSTD 压缩（节省空间，提升 I/O）。</li>
<li>数值字段：使用 <strong>Packed Ints</strong> 编码（紧凑、节省内存）。</li>
</ul>
<h3 id="5-缓存机制">5. <strong>缓存机制</strong></h3>
<ul>
<li><strong>File System Cache</strong>：依赖操作系统页缓存。</li>
<li><strong>Field Data Cache</strong>：用于文本字段排序。</li>
<li><strong>Query Cache / Request Cache</strong>：缓存热点查询结果，提升并发处理效率。</li>
</ul>
<hr>
<h2 id="五-写入过程详解">五、写入过程详解</h2>
<ol>
<li><strong>数据接收</strong>：文档以 JSON 格式通过 REST API 或客户端 SDK 提交至 ES。</li>
<li><strong>Routing</strong>：通过 <code>_id</code> 或路由值确定写入哪个主分片。</li>
<li><strong>分析与分词</strong>：字段值通过分词器进行分解。</li>
<li><strong>索引构建</strong>：
<ul>
<li>文本字段 → 倒排索引 + 可选 Doc Values；</li>
<li>keyword、数值字段 → Doc Values（用于聚合）；</li>
</ul>
</li>
<li><strong>刷新机制（Refresh）</strong>：
<ul>
<li>每隔默认 1s 将写入内存的 Segment 刷新为可搜索状态。</li>
</ul>
</li>
<li><strong>Flush（持久化）</strong>：
<ul>
<li>将 Segment 文件持久化到磁盘。</li>
</ul>
</li>
<li><strong>副本同步</strong>：主分片写入成功后，异步将数据复制到副本分片。</li>
</ol>
<hr>
<h2 id="六-存储空间示意图逻辑与物理">六、存储空间示意图（逻辑与物理）</h2>
<pre><code class="language-text">Cluster
 └── Node A
     ├── Index: logs-2025-06
     │   ├── Shard 0 (Primary)
     │   │   └── Segment_0 -&gt; .fdt, .fdx, .tii, .tis, .doc
     │   └── Shard 0 (Replica)
     └── Index: products
         ├── Shard 1 (Primary)
         └── Shard 1 (Replica)
</code></pre>
<hr>
<h2 id="七-总结es-存储性能特点">七、总结：ES 存储性能特点</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>倒排索引</td>
<td>高效文本搜索，全文检索核心</td>
</tr>
<tr>
<td>Segment 结构</td>
<td>只写追加 + 合并，适合写多读多</td>
</tr>
<tr>
<td>Doc Values</td>
<td>支持列式访问，聚合与排序高效</td>
</tr>
<tr>
<td>高压缩率</td>
<td>LZ4/ZSTD/Packed Ints 等减少存储空间</td>
</tr>
<tr>
<td>自动分片与副本</td>
<td>高可用，易扩展</td>
</tr>
<tr>
<td>写入延迟优化</td>
<td>异步刷新、缓存层控制，提高吞吐</td>
</tr>
</tbody>
</table>
<hr>
<p>以下是使用 <strong>Elasticsearch 官方客户端</strong> 分别用 <strong>Java（High Level Rest Client / Java API Client）</strong> 和 <strong>.NET（NEST 客户端）</strong> 实现的基本操作示例，涵盖：</p>
<ul>
<li>节点连接（客户端初始化）</li>
<li>索引创建</li>
<li>文档插入</li>
<li>文档查询</li>
</ul>
<hr>
<h2 id="一-java-代码基于-elasticsearch-java-api-client">✅ 一、Java 代码（基于 Elasticsearch Java API Client）</h2>
<blockquote>
<p>支持 ES 7.x 与 8.x（推荐使用新版本 <code>co.elastic.clients.elasticsearch.ElasticsearchClient</code>）</p>
</blockquote>
<h3 id="1-maven-依赖">1. Maven 依赖</h3>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;co.elastic.clients&lt;/groupId&gt;
  &lt;artifactId&gt;elasticsearch-java&lt;/artifactId&gt;
  &lt;version&gt;8.12.0&lt;/version&gt; &lt;!-- 根据实际版本调整 --&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="2-初始化客户端">2. 初始化客户端</h3>
<pre><code class="language-java">import co.elastic.clients.elasticsearch.ElasticsearchClient;
import co.elastic.clients.elasticsearch._types.ElasticsearchException;
import co.elastic.clients.transport.rest_client.RestClientTransport;
import co.elastic.clients.json.jackson.JacksonJsonpMapper;
import org.apache.http.HttpHost;
import org.elasticsearch.client.RestClient;

RestClient restClient = RestClient.builder(
    new HttpHost(&quot;localhost&quot;, 9200)).build();

ElasticsearchClient client = new ElasticsearchClient(
    new RestClientTransport(restClient, new JacksonJsonpMapper()));
</code></pre>
<h3 id="3-创建索引">3. 创建索引</h3>
<pre><code class="language-java">client.indices().create(c -&gt; c
    .index(&quot;test-index&quot;)
    .settings(s -&gt; s.numberOfShards(&quot;1&quot;).numberOfReplicas(&quot;1&quot;))
    .mappings(m -&gt; m
        .properties(&quot;user&quot;, p -&gt; p.text(t -&gt; t.analyzer(&quot;standard&quot;)))
        .properties(&quot;age&quot;, p -&gt; p.integer(i -&gt; i))
        .properties(&quot;message&quot;, p -&gt; p.text(t -&gt; t))
    )
);
</code></pre>
<h3 id="4-插入文档">4. 插入文档</h3>
<pre><code class="language-java">import java.util.Map;

client.index(i -&gt; i
    .index(&quot;test-index&quot;)
    .id(&quot;1&quot;)
    .document(Map.of(
        &quot;user&quot;, &quot;alice&quot;,
        &quot;age&quot;, 30,
        &quot;message&quot;, &quot;Elasticsearch is fast!&quot;
    ))
);
</code></pre>
<h3 id="5-查询文档">5. 查询文档</h3>
<pre><code class="language-java">var response = client.get(g -&gt; g
    .index(&quot;test-index&quot;)
    .id(&quot;1&quot;),
    Map.class
);

System.out.println(&quot;文档内容: &quot; + response.source());
</code></pre>
<hr>
<h2 id="二-net-代码基于-nest-客户端">✅ 二、.NET 代码（基于 NEST 客户端）</h2>
<blockquote>
<p>NEST 是官方推荐的 .NET 高级客户端，适配 Elasticsearch 7.x 和 8.x。</p>
</blockquote>
<h3 id="1-安装-nuget-包">1. 安装 NuGet 包</h3>
<pre><code class="language-bash">dotnet add package NEST --version 7.17.0
</code></pre>
<h3 id="2-初始化客户端-2">2. 初始化客户端</h3>
<pre><code class="language-csharp">using Nest;

var settings = new ConnectionSettings(new Uri(&quot;http://localhost:9200&quot;))
    .DefaultIndex(&quot;test-index&quot;);

var client = new ElasticClient(settings);
</code></pre>
<h3 id="3-创建索引-2">3. 创建索引</h3>
<pre><code class="language-csharp">var createIndexResponse = client.Indices.Create(&quot;test-index&quot;, c =&gt; c
    .Map(m =&gt; m
        .Properties(p =&gt; p
            .Text(t =&gt; t.Name(&quot;user&quot;))
            .Number(n =&gt; n.Name(&quot;age&quot;).Type(NumberType.Integer))
            .Text(t =&gt; t.Name(&quot;message&quot;))
        )
    )
);
</code></pre>
<h3 id="4-插入文档-2">4. 插入文档</h3>
<pre><code class="language-csharp">var doc = new
{
    user = &quot;bob&quot;,
    age = 28,
    message = &quot;NEST is awesome&quot;
};

var indexResponse = client.IndexDocument(doc);
</code></pre>
<h3 id="5-查询文档-2">5. 查询文档</h3>
<pre><code class="language-csharp">var response = client.Get&lt;object&gt;(&quot;1&quot;, g =&gt; g.Index(&quot;test-index&quot;));

Console.WriteLine($&quot;文档内容：{response.Source}&quot;);
</code></pre>
<hr>
<h2 id="三-运行前准备">✅ 三、运行前准备</h2>
<h3 id="启动-elasticsearch">✅ 启动 Elasticsearch</h3>
<ul>
<li>安装并启动 Elasticsearch（建议版本：7.17+ 或 8.x）</li>
<li>确保监听 <code>localhost:9200</code>（可通过 <code>curl http://localhost:9200</code> 验证）</li>
</ul>
<hr>
<h2 id="四-补充说明">✅ 四、补充说明</h2>
<table>
<thead>
<tr>
<th>语言</th>
<th>客户端</th>
<th>适配版本</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>Java</td>
<td><code>elasticsearch-java</code> / <code>HighLevelRestClient</code></td>
<td>7.x / 8.x</td>
<td>官方推荐，强类型</td>
</tr>
<tr>
<td>.NET</td>
<td><code>NEST</code></td>
<td>7.x</td>
<td>查询 DSL 灵活，使用对象映射</td>
</tr>
<tr>
<td>JS</td>
<td><code>@elastic/elasticsearch</code></td>
<td>7.x / 8.x</td>
<td>Node.js 项目常用</td>
</tr>
<tr>
<td>Python</td>
<td><code>elasticsearch</code></td>
<td>7.x / 8.x</td>
<td>简洁，适合脚本任务</td>
</tr>
</tbody>
</table>
<hr>
<p>好的，接下来我们将扩展 Java 和 .NET 客户端的代码示例，涵盖 <strong>分页查询</strong>、<strong>布尔查询</strong>、<strong>聚合查询</strong>、<strong>中文分词自定义配置</strong> 等常见的 Elasticsearch 操作。</p>
<hr>
<h2 id="一-java-代码扩展使用-elasticsearch-java-api-client">✅ 一、Java 代码扩展（使用 Elasticsearch Java API Client）</h2>
<h3 id="1-分页查询search-with-pagination">1. <strong>分页查询（Search with Pagination）</strong></h3>
<p>分页查询是常见的需求，尤其是在处理大量数据时。下面是如何进行分页查询。</p>
<pre><code class="language-java">import co.elastic.clients.elasticsearch.core.SearchRequest;
import co.elastic.clients.elasticsearch.core.SearchResponse;
import co.elastic.clients.elasticsearch.core.search.Hit;
import java.util.List;

SearchRequest searchRequest = new SearchRequest.Builder()
    .index(&quot;test-index&quot;)
    .from(0)    // 起始页（分页的起点）
    .size(10)   // 每页返回的文档数
    .build();

SearchResponse&lt;Map&gt; searchResponse = client.search(searchRequest, Map.class);

List&lt;Hit&lt;Map&gt;&gt; hits = searchResponse.hits().hits();
hits.forEach(hit -&gt; {
    System.out.println(&quot;Document ID: &quot; + hit.id() + &quot;, Content: &quot; + hit.source());
});
</code></pre>
<ul>
<li><code>from(0)</code> 表示查询的起始位置，从第 1 条记录开始。</li>
<li><code>size(10)</code> 表示每页返回 10 条记录。</li>
</ul>
<h3 id="2-布尔查询boolean-query">2. <strong>布尔查询（Boolean Query）</strong></h3>
<p>布尔查询可以结合多个条件来筛选结果，例如 <code>must</code>（必须匹配）、<code>should</code>（可以匹配）、<code>must_not</code>（不能匹配）等。</p>
<pre><code class="language-java">import co.elastic.clients.elasticsearch.core.SearchRequest;
import co.elastic.clients.elasticsearch.core.SearchResponse;
import co.elastic.clients.elasticsearch.query.BoolQuery;
import co.elastic.clients.elasticsearch.query.Query;

SearchRequest searchRequest = new SearchRequest.Builder()
    .index(&quot;test-index&quot;)
    .query(q -&gt; q
        .bool(b -&gt; b
            .must(Query.of(q1 -&gt; q1.term(t -&gt; t.field(&quot;user&quot;).value(&quot;alice&quot;)))) // 必须匹配 &quot;user&quot; 字段值为 &quot;alice&quot;
            .filter(Query.of(q2 -&gt; q2.range(r -&gt; r.field(&quot;age&quot;).gte(&quot;20&quot;))))  // &quot;age&quot; &gt;= 20
            .mustNot(Query.of(q3 -&gt; q3.match(m -&gt; m.field(&quot;message&quot;).query(&quot;error&quot;))))  // &quot;message&quot; 字段不能包含 &quot;error&quot;
    )
    .build();

SearchResponse&lt;Map&gt; searchResponse = client.search(searchRequest, Map.class);
</code></pre>
<ul>
<li><code>must</code>：匹配的条件必须满足（例如匹配 &quot;user&quot; 字段为 &quot;alice&quot;）。</li>
<li><code>filter</code>：过滤条件，通常不参与评分。</li>
<li><code>mustNot</code>：必须不匹配的条件（例如 &quot;message&quot; 字段不能包含 &quot;error&quot;）。</li>
</ul>
<h3 id="3-聚合查询aggregation-query">3. <strong>聚合查询（Aggregation Query）</strong></h3>
<p>聚合查询可用于统计数据（如求和、平均值、最小值、最大值、分组等）。</p>
<pre><code class="language-java">import co.elastic.clients.elasticsearch.core.SearchRequest;
import co.elastic.clients.elasticsearch.core.SearchResponse;
import co.elastic.clients.elasticsearch.aggregation.AvgAggregation;
import co.elastic.clients.elasticsearch.aggregation.Aggregation;
import co.elastic.clients.elasticsearch.aggregation.AggregationResult;

SearchRequest searchRequest = new SearchRequest.Builder()
    .index(&quot;test-index&quot;)
    .aggregations(&quot;avg_age&quot;, a -&gt; a.avg(avg -&gt; avg.field(&quot;age&quot;)))  // 求 &quot;age&quot; 字段的平均值
    .build();

SearchResponse&lt;Map&gt; searchResponse = client.search(searchRequest, Map.class);

AggregationResult avgAge = searchResponse.aggregations().get(&quot;avg_age&quot;);
System.out.println(&quot;Average Age: &quot; + avgAge.value());
</code></pre>
<ul>
<li><code>aggregations(&quot;avg_age&quot;, a -&gt; a.avg(...))</code>：在查询中包含了聚合操作，计算 &quot;age&quot; 字段的平均值。</li>
</ul>
<h3 id="4-中文分词自定义analyzer">4. <strong>中文分词自定义（Analyzer）</strong></h3>
<p>Elasticsearch 支持自定义分词器，特别是中文分词，常用的分词器有 IK 分词器等。</p>
<pre><code class="language-java">client.indices().create(c -&gt; c
    .index(&quot;test-index&quot;)
    .settings(s -&gt; s
        .analysis(a -&gt; a
            .tokenizer(&quot;ik_max_word&quot;, t -&gt; t.type(&quot;ik_max_word&quot;)) // 使用 IK 分词器
        )
    )
    .mappings(m -&gt; m
        .properties(&quot;message&quot;, p -&gt; p.text(t -&gt; t.analyzer(&quot;ik_max_word&quot;)))
    )
);
</code></pre>
<ul>
<li>通过配置分词器 <code>ik_max_word</code>，可以更好地处理中文文本的分词。</li>
</ul>
<hr>
<h2 id="二-net-代码扩展使用-nest-客户端">✅ 二、.NET 代码扩展（使用 NEST 客户端）</h2>
<h3 id="1-分页查询search-with-pagination-2">1. <strong>分页查询（Search with Pagination）</strong></h3>
<pre><code class="language-csharp">var searchResponse = client.Search&lt;object&gt;(s =&gt; s
    .Index(&quot;test-index&quot;)
    .From(0)  // 起始页
    .Size(10) // 每页条数
);

foreach (var hit in searchResponse.Hits)
{
    Console.WriteLine($&quot;Document ID: {hit.Id}, Content: {hit.Source}&quot;);
}
</code></pre>
<ul>
<li><code>From(0)</code> 和 <code>Size(10)</code> 用于控制分页，返回第 1 页的 10 条记录。</li>
</ul>
<h3 id="2-布尔查询boolean-query-2">2. <strong>布尔查询（Boolean Query）</strong></h3>
<pre><code class="language-csharp">var boolSearchResponse = client.Search&lt;object&gt;(s =&gt; s
    .Index(&quot;test-index&quot;)
    .Query(q =&gt; q
        .Bool(b =&gt; b
            .Must(mu =&gt; mu.Term(&quot;user&quot;, &quot;alice&quot;)) // &quot;user&quot; 字段为 &quot;alice&quot;
            .Filter(fi =&gt; fi.Range(r =&gt; r.Field(&quot;age&quot;).GreaterThanOrEquals(20))) // &quot;age&quot; &gt;= 20
            .MustNot(mu =&gt; mu.Match(m =&gt; m.Field(&quot;message&quot;).Query(&quot;error&quot;))) // &quot;message&quot; 字段不包含 &quot;error&quot;
        )
    )
);
</code></pre>
<ul>
<li>使用 <code>Must</code>, <code>Filter</code>, 和 <code>MustNot</code> 组合不同的查询条件。</li>
</ul>
<h3 id="3-聚合查询aggregation-query-2">3. <strong>聚合查询（Aggregation Query）</strong></h3>
<pre><code class="language-csharp">var aggregationResponse = client.Search&lt;object&gt;(s =&gt; s
    .Index(&quot;test-index&quot;)
    .Aggregations(a =&gt; a
        .Average(&quot;avg_age&quot;, avg =&gt; avg.Field(&quot;age&quot;)) // 聚合计算 &quot;age&quot; 字段的平均值
    )
);

Console.WriteLine($&quot;Average Age: {aggregationResponse.Aggregations.Average(&quot;avg_age&quot;).Value}&quot;);
</code></pre>
<ul>
<li><code>Aggregations</code> 用于聚合操作，计算 &quot;age&quot; 字段的平均值。</li>
</ul>
<h3 id="4-中文分词自定义analyzer-2">4. <strong>中文分词自定义（Analyzer）</strong></h3>
<pre><code class="language-csharp">var createIndexResponse = client.Indices.Create(&quot;test-index&quot;, c =&gt; c
    .Settings(s =&gt; s
        .Analysis(a =&gt; a
            .Tokenizers(t =&gt; t
                .Custom(&quot;ik_max_word&quot;, tokenizer =&gt; tokenizer.Type(&quot;ik_max_word&quot;)) // 配置 IK 分词器
            )
            .Analyzers(an =&gt; an
                .Custom(&quot;ik_max_word&quot;, ca =&gt; ca.Tokenizer(&quot;ik_max_word&quot;))
            )
        )
    )
    .Map(m =&gt; m
        .Properties(p =&gt; p
            .Text(t =&gt; t.Name(&quot;message&quot;).Analyzer(&quot;ik_max_word&quot;))
        )
    )
);
</code></pre>
<ul>
<li>配置自定义的中文分词器，如 IK 分词器，用于 <code>message</code> 字段。</li>
</ul>
<hr>
<h2 id="三-总结">✅ 三、总结</h2>
<table>
<thead>
<tr>
<th>操作类型</th>
<th>Java 代码实现</th>
<th>.NET 代码实现</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>分页查询</strong></td>
<td><code>from(0).size(10)</code> 查询指定页数和每页数据量</td>
<td><code>From(0).Size(10)</code></td>
</tr>
<tr>
<td><strong>布尔查询</strong></td>
<td><code>bool()</code> 查询多条件组合</td>
<td><code>Bool()</code> 查询多条件组合</td>
</tr>
<tr>
<td><strong>聚合查询</strong></td>
<td><code>aggregations(&quot;avg_age&quot;, a -&gt; a.avg(...))</code> 聚合某字段数据</td>
<td><code>Aggregations(a =&gt; a.Average(&quot;avg_age&quot;, avg =&gt; avg.Field(&quot;age&quot;)))</code> 聚合数据</td>
</tr>
<tr>
<td><strong>中文分词</strong></td>
<td>配置 <code>ik_max_word</code> 分词器</td>
<td>配置 <code>ik_max_word</code> 分词器</td>
</tr>
</tbody>
</table>
<hr>
<hr>
<h1 id="redis-和-elasticsearch-是否支持存储动态结构">✅ Redis 和 Elasticsearch 是否支持存储动态结构？</h1>
<h2 id="一-什么是动态结构">一、什么是“动态结构”？</h2>
<p>所谓 <strong>动态结构数据</strong>，指的是字段 <strong>不固定</strong>、<strong>不同文档或记录之间字段可能不同</strong>、<strong>结构可在运行时自由变动</strong> 的数据。</p>
<p>例如：</p>
<pre><code class="language-json">// 文档 A
{ &quot;user&quot;: &quot;alice&quot;, &quot;age&quot;: 25 }

// 文档 B
{ &quot;user&quot;: &quot;bob&quot;, &quot;hobbies&quot;: [&quot;reading&quot;, &quot;coding&quot;] }

// 文档 C
{ &quot;ip&quot;: &quot;127.0.0.1&quot;, &quot;location&quot;: &quot;Beijing&quot; }
</code></pre>
<hr>
<h2 id="二-redis-是否支持动态结构">二、Redis 是否支持动态结构？</h2>
<p>✅ <strong>支持，但不具备结构感知能力</strong></p>
<ul>
<li>Redis 是一个 <strong>无模式（schemaless）</strong> 的键值数据库，你可以往一个 Hash、String 或 JSON 对象里动态添加任意字段。</li>
<li>使用方式上没有结构限制，但不会自动识别结构或做类型推断。</li>
</ul>
<h3 id="举例使用-redisjsonredis模块存储动态结构">举例：使用 RedisJSON（Redis模块）存储动态结构</h3>
<pre><code class="language-bash"># Redis JSON 示例（使用 ReJSON 模块）
JSON.SET doc:1 $ '{&quot;user&quot;:&quot;alice&quot;,&quot;age&quot;:25}'
JSON.SET doc:2 $ '{&quot;user&quot;:&quot;bob&quot;,&quot;hobbies&quot;:[&quot;reading&quot;,&quot;coding&quot;]}'
</code></pre>
<ul>
<li>✔️ 字段可以不同，动态增删字段完全支持；</li>
<li>❌ 不能基于字段自动索引或查询（除非你用 RedisSearch 进行配置）。</li>
</ul>
<hr>
<h2 id="三-elasticsearch-是否支持动态结构">三、Elasticsearch 是否支持动态结构？</h2>
<p>✅ <strong>支持动态结构（默认开启），并可控制行为</strong></p>
<h3 id="默认行为">默认行为：</h3>
<ul>
<li>当你向 ES 索引中插入新字段时，<strong>默认会自动识别字段类型并动态添加到映射（mapping）中</strong>。</li>
<li>这种机制被称为：<strong>Dynamic Mapping（动态映射）</strong></li>
</ul>
<h3 id="示例">示例：</h3>
<pre><code class="language-bash">PUT /my-index/_doc/1
{
  &quot;user&quot;: &quot;alice&quot;,
  &quot;age&quot;: 25
}

PUT /my-index/_doc/2
{
  &quot;user&quot;: &quot;bob&quot;,
  &quot;hobbies&quot;: [&quot;reading&quot;, &quot;coding&quot;]
}

PUT /my-index/_doc/3
{
  &quot;ip&quot;: &quot;127.0.0.1&quot;,
  &quot;location&quot;: &quot;Beijing&quot;
}
</code></pre>
<p>🔍 ES 会自动生成如下类型映射：</p>
<pre><code class="language-json">{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;user&quot;: { &quot;type&quot;: &quot;text&quot; },
      &quot;age&quot;: { &quot;type&quot;: &quot;integer&quot; },
      &quot;hobbies&quot;: { &quot;type&quot;: &quot;text&quot; },
      &quot;ip&quot;: { &quot;type&quot;: &quot;ip&quot; },
      &quot;location&quot;: { &quot;type&quot;: &quot;text&quot; }
    }
  }
}
</code></pre>
<hr>
<h2 id="四-动态结构控制选项elasticsearch-专属">四、动态结构控制选项（Elasticsearch 专属）</h2>
<p>你可以在索引的 <code>mappings</code> 中配置 <code>dynamic</code> 属性来控制动态字段行为：</p>
<table>
<thead>
<tr>
<th>配置</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dynamic: true</code>（默认）</td>
<td>自动添加新字段并映射类型</td>
</tr>
<tr>
<td><code>dynamic: false</code></td>
<td>忽略新字段（不添加，不索引）</td>
</tr>
<tr>
<td><code>dynamic: strict</code></td>
<td>如果插入了未声明字段，会抛出错误，禁止任意动态字段添加</td>
</tr>
</tbody>
</table>
<h3 id="示例-2">示例：</h3>
<pre><code class="language-json">PUT /my-index
{
  &quot;mappings&quot;: {
    &quot;dynamic&quot;: &quot;strict&quot;, 
    &quot;properties&quot;: {
      &quot;user&quot;: { &quot;type&quot;: &quot;text&quot; }
    }
  }
}
</code></pre>
<p>此时，如果你写入一个含 <code>age</code> 字段的文档，会触发错误，因为该字段未在映射中定义。</p>
<hr>
<h2 id="五-总结对比">五、总结对比</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>Redis</th>
<th>Elasticsearch</th>
</tr>
</thead>
<tbody>
<tr>
<td>动态结构支持</td>
<td>✅ 完全支持（自由结构、无模式）</td>
<td>✅ 默认支持动态字段（可控制 dynamic 级别）</td>
</tr>
<tr>
<td>类型自动识别与索引</td>
<td>❌ 不自动识别字段类型或索引</td>
<td>✅ 自动识别字段类型并映射入索引</td>
</tr>
<tr>
<td>结构控制能力</td>
<td>❌ 无结构控制（所有数据为黑盒）</td>
<td>✅ 可限制字段变化（dynamic: strict/false）</td>
</tr>
<tr>
<td>查询能力（基于字段）</td>
<td>⚠️ 需 RedisSearch 扩展</td>
<td>✅ 强大查询支持</td>
</tr>
<tr>
<td>适合的应用</td>
<td>灵活存取、实时缓存、结构可变性强</td>
<td>数据查询与分析、结构变化适度的文档系统</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="结论">✅ 结论：</h2>
<ul>
<li>Redis 适合完全动态、变化频繁、不需要结构索引的数据（例如：缓存、会话状态、临时数据）。</li>
<li>Elasticsearch 更适合结构变化不太频繁、<strong>但需要字段级搜索、分析与索引</strong>的半结构化数据（如日志、文档、用户信息等）。</li>
</ul>
<p>如果你有一份经常变化字段结构的数据集，但又需要全文搜索或聚合查询，<strong>可以考虑使用 Elasticsearch 开启 <code>dynamic: true</code> 模式并定期整理 mapping</strong>。</p>
<hr>
<p>Elasticsearch 的 REST API 写入语句：</p>
<hr>
<h2 id="一-结构说明put-my-index_doc1">✅ 一、结构说明：<code>PUT /my-index/_doc/1</code></h2>
<p>这条命令的格式为：</p>
<pre><code>PUT /{索引名}/{类型}/{文档ID}
</code></pre>
<p>在这个例子中：</p>
<table>
<thead>
<tr>
<th>路径部分</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>my-index</code></td>
<td>✅ 索引名。相当于数据库里的一个“表”</td>
</tr>
<tr>
<td><code>_doc</code></td>
<td>✅ 文档类型。ES 7.x 开始默认固定为 <code>_doc</code>（文档类型概念已废弃）</td>
</tr>
<tr>
<td><code>1</code></td>
<td>✅ 文档 ID。唯一标识一个文档。用户可以指定（如这里是 <code>1</code>、<code>2</code>、<code>3</code>），也可以让 ES 自动生成</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="二-示例解释">✅ 二、示例解释</h2>
<pre><code class="language-http">PUT /my-index/_doc/1
{
  &quot;user&quot;: &quot;alice&quot;,
  &quot;age&quot;: 25
}
</code></pre>
<ul>
<li><strong>my-index</strong>：索引名，表示这些文档都属于一个数据集合。</li>
<li><strong>_doc</strong>：类型名（现在是固定写法，已不建议自定义类型）。</li>
<li><strong>1</strong>：文档的 ID（可通过它进行查询或更新）。</li>
<li><strong>正文部分</strong>：是 JSON 格式的数据，ES 会自动识别字段并存储。</li>
</ul>
<hr>
<h2 id="三-插入数据后如何查询">✅ 三、插入数据后，如何查询？</h2>
<h3 id="1-查询某个文档通过-id">1. 查询某个文档（通过 ID）</h3>
<pre><code class="language-http">GET /my-index/_doc/1
</code></pre>
<p><strong>返回示例：</strong></p>
<pre><code class="language-json">{
  &quot;_index&quot;: &quot;my-index&quot;,
  &quot;_id&quot;: &quot;1&quot;,
  &quot;_source&quot;: {
    &quot;user&quot;: &quot;alice&quot;,
    &quot;age&quot;: 25
  }
}
</code></pre>
<hr>
<h3 id="2-查询整个索引返回所有文档">2. 查询整个索引（返回所有文档）</h3>
<pre><code class="language-http">GET /my-index/_search
</code></pre>
<p>你也可以带分页参数：</p>
<pre><code class="language-http">GET /my-index/_search?from=0&amp;size=10
</code></pre>
<p><strong>返回示例：</strong></p>
<pre><code class="language-json">{
  &quot;hits&quot;: {
    &quot;total&quot;: 3,
    &quot;hits&quot;: [
      {
        &quot;_id&quot;: &quot;1&quot;,
        &quot;_source&quot;: { &quot;user&quot;: &quot;alice&quot;, &quot;age&quot;: 25 }
      },
      {
        &quot;_id&quot;: &quot;2&quot;,
        &quot;_source&quot;: { &quot;user&quot;: &quot;bob&quot;, &quot;hobbies&quot;: [&quot;reading&quot;, &quot;coding&quot;] }
      },
      {
        &quot;_id&quot;: &quot;3&quot;,
        &quot;_source&quot;: { &quot;ip&quot;: &quot;127.0.0.1&quot;, &quot;location&quot;: &quot;Beijing&quot; }
      }
    ]
  }
}
</code></pre>
<hr>
<h3 id="3-条件查询匹配字段">3. 条件查询：匹配字段</h3>
<p>例如查找 user 为 bob 的文档：</p>
<pre><code class="language-http">GET /my-index/_search
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;user&quot;: &quot;bob&quot;
    }
  }
}
</code></pre>
<hr>
<h2 id="四-文档-id-的作用">✅ 四、文档 ID 的作用</h2>
<table>
<thead>
<tr>
<th>文档 ID</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>1</code>、<code>2</code>、<code>3</code></td>
<td>是每个文档在该索引下的唯一标识。可以自己指定，也可以让 ES 自动生成（不写 ID 就行）</td>
</tr>
<tr>
<td>指定 ID 的好处</td>
<td>可以通过 <code>GET /index/_doc/{id}</code> 快速定位/更新/删除文档</td>
</tr>
<tr>
<td>自动 ID 的好处</td>
<td>不需要管理 ID，适合批量写入、不关心单个文档 ID 的场景</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="总结">✅ 总结</h2>
<table>
<thead>
<tr>
<th>元素</th>
<th>示例</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>索引</td>
<td><code>my-index</code></td>
<td>类似于表，存储某类数据的集合</td>
</tr>
<tr>
<td>类型</td>
<td><code>_doc</code></td>
<td>ES 7.x 开始固定为 <code>_doc</code>，将废弃</td>
</tr>
<tr>
<td>文档 ID</td>
<td><code>1</code>、<code>2</code>、<code>3</code></td>
<td>每条数据的唯一 ID（手动或自动生成）</td>
</tr>
<tr>
<td>文档内容</td>
<td>JSON 格式的结构化数据</td>
<td>任意结构，字段可变</td>
</tr>
<tr>
<td>查询语句</td>
<td><code>_search</code> + DSL 查询</td>
<td>支持全文、结构化、多条件匹配</td>
</tr>
</tbody>
</table>
<hr>
<p>下面我将分别用 <strong>Java（Elasticsearch Java API Client）</strong> 和 <strong>.NET（NEST 客户端）</strong> 演示如何操作<strong>动态结构的商品数据文档</strong>：</p>
<ul>
<li>✅ 使用动态结构（字段不固定、类型可变）</li>
<li>✅ 插入多样复杂的文档（字段不同、嵌套对象、数组等）</li>
<li>✅ 查询、搜索、解析这些动态文档</li>
<li>✅ 强调如何让 Elasticsearch 接受并存储这种“结构不确定”的商品数据</li>
</ul>
<hr>
<h2 id="一-商品动态结构示例json">✅ 一、商品动态结构示例（JSON）</h2>
<p>我们定义几个商品，每个结构都不同，模拟真实商城场景：</p>
<pre><code class="language-json">// 商品 A
{
  &quot;name&quot;: &quot;iPhone 15&quot;,
  &quot;brand&quot;: &quot;Apple&quot;,
  &quot;price&quot;: 8999,
  &quot;specs&quot;: {
    &quot;color&quot;: &quot;black&quot;,
    &quot;storage&quot;: &quot;256GB&quot;
  },
  &quot;tags&quot;: [&quot;phone&quot;, &quot;ios&quot;, &quot;5G&quot;]
}

// 商品 B
{
  &quot;name&quot;: &quot;ThinkPad X1&quot;,
  &quot;brand&quot;: &quot;Lenovo&quot;,
  &quot;price&quot;: 12999,
  &quot;weight&quot;: 1.2,
  &quot;specs&quot;: {
    &quot;cpu&quot;: &quot;i7&quot;,
    &quot;ram&quot;: &quot;16GB&quot;,
    &quot;ssd&quot;: &quot;512GB&quot;
  },
  &quot;accessories&quot;: [&quot;charger&quot;, &quot;bag&quot;],
  &quot;warranty&quot;: {
    &quot;period&quot;: &quot;2 years&quot;,
    &quot;international&quot;: true
  }
}

// 商品 C
{
  &quot;name&quot;: &quot;游戏键盘&quot;,
  &quot;price&quot;: 499,
  &quot;features&quot;: [&quot;RGB&quot;, &quot;机械轴&quot;, &quot;多媒体按键&quot;]
}
</code></pre>
<hr>
<h2 id="二-java-实现使用-elasticsearch-java-api-client">✅ 二、Java 实现（使用 Elasticsearch Java API Client）</h2>
<h3 id="1-插入动态结构商品">1. 插入动态结构商品</h3>
<p>无需固定模型结构，直接使用 <code>Map&lt;String, Object&gt;</code> 即可支持任意字段。</p>
<pre><code class="language-java">import co.elastic.clients.elasticsearch.ElasticsearchClient;
import co.elastic.clients.transport.rest_client.RestClientTransport;
import org.elasticsearch.client.RestClient;
import java.util.*;

RestClient restClient = RestClient.builder(new HttpHost(&quot;localhost&quot;, 9200)).build();
ElasticsearchClient client = new ElasticsearchClient(
    new RestClientTransport(restClient, new JacksonJsonpMapper()));

// 商品 A
Map&lt;String, Object&gt; productA = Map.of(
    &quot;name&quot;, &quot;iPhone 15&quot;,
    &quot;brand&quot;, &quot;Apple&quot;,
    &quot;price&quot;, 8999,
    &quot;specs&quot;, Map.of(&quot;color&quot;, &quot;black&quot;, &quot;storage&quot;, &quot;256GB&quot;),
    &quot;tags&quot;, List.of(&quot;phone&quot;, &quot;ios&quot;, &quot;5G&quot;)
);

// 商品 B
Map&lt;String, Object&gt; productB = Map.of(
    &quot;name&quot;, &quot;ThinkPad X1&quot;,
    &quot;brand&quot;, &quot;Lenovo&quot;,
    &quot;price&quot;, 12999,
    &quot;weight&quot;, 1.2,
    &quot;specs&quot;, Map.of(&quot;cpu&quot;, &quot;i7&quot;, &quot;ram&quot;, &quot;16GB&quot;, &quot;ssd&quot;, &quot;512GB&quot;),
    &quot;accessories&quot;, List.of(&quot;charger&quot;, &quot;bag&quot;),
    &quot;warranty&quot;, Map.of(&quot;period&quot;, &quot;2 years&quot;, &quot;international&quot;, true)
);

// 商品 C
Map&lt;String, Object&gt; productC = Map.of(
    &quot;name&quot;, &quot;游戏键盘&quot;,
    &quot;price&quot;, 499,
    &quot;features&quot;, List.of(&quot;RGB&quot;, &quot;机械轴&quot;, &quot;多媒体按键&quot;)
);

// 插入
client.index(i -&gt; i.index(&quot;products&quot;).id(&quot;A&quot;).document(productA));
client.index(i -&gt; i.index(&quot;products&quot;).id(&quot;B&quot;).document(productB));
client.index(i -&gt; i.index(&quot;products&quot;).id(&quot;C&quot;).document(productC));
</code></pre>
<h3 id="2-查询所有商品">2. 查询所有商品</h3>
<pre><code class="language-java">var res = client.search(s -&gt; s.index(&quot;products&quot;).query(q -&gt; q.matchAll(m -&gt; m)), Map.class);
res.hits().hits().forEach(hit -&gt; System.out.println(hit.id() + &quot;: &quot; + hit.source()));
</code></pre>
<h3 id="3-查询品牌为-lenovo-的商品">3. 查询品牌为 Lenovo 的商品</h3>
<pre><code class="language-java">var result = client.search(s -&gt; s
    .index(&quot;products&quot;)
    .query(q -&gt; q.match(m -&gt; m.field(&quot;brand&quot;).query(&quot;Lenovo&quot;))),
    Map.class
);
result.hits().hits().forEach(hit -&gt; System.out.println(hit.source()));
</code></pre>
<hr>
<h2 id="三-net-实现使用-nest-客户端">✅ 三、.NET 实现（使用 NEST 客户端）</h2>
<blockquote>
<p>使用匿名对象或 <code>Dictionary&lt;string, object&gt;</code> 实现动态字段</p>
</blockquote>
<h3 id="1-初始化客户端">1. 初始化客户端</h3>
<pre><code class="language-csharp">var settings = new ConnectionSettings(new Uri(&quot;http://localhost:9200&quot;))
    .DefaultIndex(&quot;products&quot;);
var client = new ElasticClient(settings);
</code></pre>
<h3 id="2-插入动态结构商品">2. 插入动态结构商品</h3>
<pre><code class="language-csharp">client.Index(new Dictionary&lt;string, object&gt;
{
    { &quot;name&quot;, &quot;iPhone 15&quot; },
    { &quot;brand&quot;, &quot;Apple&quot; },
    { &quot;price&quot;, 8999 },
    { &quot;specs&quot;, new Dictionary&lt;string, object&gt; {
        { &quot;color&quot;, &quot;black&quot; }, { &quot;storage&quot;, &quot;256GB&quot; }
    }},
    { &quot;tags&quot;, new[] { &quot;phone&quot;, &quot;ios&quot;, &quot;5G&quot; } }
}, i =&gt; i.Id(&quot;A&quot;));

client.Index(new Dictionary&lt;string, object&gt;
{
    { &quot;name&quot;, &quot;ThinkPad X1&quot; },
    { &quot;brand&quot;, &quot;Lenovo&quot; },
    { &quot;price&quot;, 12999 },
    { &quot;weight&quot;, 1.2 },
    { &quot;specs&quot;, new Dictionary&lt;string, object&gt; {
        { &quot;cpu&quot;, &quot;i7&quot; }, { &quot;ram&quot;, &quot;16GB&quot; }, { &quot;ssd&quot;, &quot;512GB&quot; }
    }},
    { &quot;accessories&quot;, new[] { &quot;charger&quot;, &quot;bag&quot; } },
    { &quot;warranty&quot;, new Dictionary&lt;string, object&gt; {
        { &quot;period&quot;, &quot;2 years&quot; }, { &quot;international&quot;, true }
    }}
}, i =&gt; i.Id(&quot;B&quot;));

client.Index(new Dictionary&lt;string, object&gt;
{
    { &quot;name&quot;, &quot;游戏键盘&quot; },
    { &quot;price&quot;, 499 },
    { &quot;features&quot;, new[] { &quot;RGB&quot;, &quot;机械轴&quot;, &quot;多媒体按键&quot; } }
}, i =&gt; i.Id(&quot;C&quot;));
</code></pre>
<h3 id="3-查询所有商品">3. 查询所有商品</h3>
<pre><code class="language-csharp">var searchAll = client.Search&lt;Dictionary&lt;string, object&gt;&gt;(s =&gt; s
    .Index(&quot;products&quot;)
    .Query(q =&gt; q.MatchAll())
);

foreach (var doc in searchAll.Hits)
{
    Console.WriteLine($&quot;ID: {doc.Id} -&gt; {doc.Source[&quot;name&quot;]}&quot;);
}
</code></pre>
<h3 id="4-条件查询品牌为-lenovo">4. 条件查询：品牌为 Lenovo</h3>
<pre><code class="language-csharp">var result = client.Search&lt;Dictionary&lt;string, object&gt;&gt;(s =&gt; s
    .Index(&quot;products&quot;)
    .Query(q =&gt; q.Match(m =&gt; m.Field(&quot;brand&quot;).Query(&quot;Lenovo&quot;)))
);

foreach (var hit in result.Hits)
{
    Console.WriteLine($&quot;Brand = Lenovo -&gt; {hit.Source[&quot;name&quot;]}&quot;);
}
</code></pre>
<hr>
<h2 id="四-总结建议">✅ 四、总结建议</h2>
<table>
<thead>
<tr>
<th>要点</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据结构是否必须固定？</td>
<td>❌ 不需要，使用 <code>Map</code> 或 <code>Dictionary&lt;string, object&gt;</code> 实现动态结构</td>
</tr>
<tr>
<td>Elasticsearch 支持动态字段吗？</td>
<td>✅ 默认 <code>dynamic: true</code>，会自动添加新字段</td>
</tr>
<tr>
<td>性能是否受影响？</td>
<td>✔️ 查询性能 OK，但字段太多时建议定期整理 mapping 或设置模板</td>
</tr>
<tr>
<td>如何查询嵌套字段？</td>
<td>可使用嵌套查询（nested query）或 dot-notation（如 <code>specs.color</code>）</td>
</tr>
</tbody>
</table>
<hr>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://yuzhupeng.top/myblogs/post/java-spring-rules-andkai-fa-gui-fan/">
                  <h3 class="post-title">
                    java spring rules &amp;开发规范
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
